   1               		.file	"lcd_595_softspi.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	SoftSPI_Init
 107               	SoftSPI_Init:
   1:lcd_595_softspi.c **** // LCD Control Functions
   2:lcd_595_softspi.c **** // Target : ATMEGA88 (ATMEGA168)
   3:lcd_595_softspi.c **** // Clock  : 1MHz (Fuse : CKDIV8 = 0, Fullswing crystal)
   4:lcd_595_softspi.c **** //
   5:lcd_595_softspi.c **** 
   6:lcd_595_softspi.c **** #include <avr/io.h>
   7:lcd_595_softspi.c **** #include <util/delay.h>
   8:lcd_595_softspi.c **** #include <avr/interrupt.h>
   9:lcd_595_softspi.c **** #include "lcd_595_softspi.h"
  10:lcd_595_softspi.c **** 
  11:lcd_595_softspi.c **** // SPI port Dfinition
  12:lcd_595_softspi.c **** #define DDR_SPI         DDRB
  13:lcd_595_softspi.c **** #define PORT_SPI        PORTB
  14:lcd_595_softspi.c **** #define DD_MOSI         PB0
  15:lcd_595_softspi.c **** #define DD_SCK          PB1
  16:lcd_595_softspi.c **** #define DD_RCK          PB2
  17:lcd_595_softspi.c **** 
  18:lcd_595_softspi.c **** unsigned char E;
  19:lcd_595_softspi.c **** unsigned char RS;
  20:lcd_595_softspi.c **** unsigned char DATA;
  21:lcd_595_softspi.c **** 
  22:lcd_595_softspi.c **** void SoftSPI_Init(void){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  23:lcd_595_softspi.c ****     /*MOSI,SCK=出力、他は入力に設定 */
  24:lcd_595_softspi.c ****     DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_RCK);
 116               	.LM1:
 117 0000 84B1      		in r24,36-32
 118 0002 8760      		ori r24,lo8(7)
 119 0004 84B9      		out 36-32,r24
 120               	/* epilogue start */
  25:lcd_595_softspi.c **** }
 122               	.LM2:
 123 0006 0895      		ret
 125               	.Lscope1:
 128               	.global	SoftSPI_TX
 130               	SoftSPI_TX:
  26:lcd_595_softspi.c **** 
  27:lcd_595_softspi.c **** void SoftSPI_TX(unsigned char cData){
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 139               	.LM4:
 140 0008 27E0      		ldi r18,lo8(7)
 141 000a 30E0      		ldi r19,hi8(7)
  28:lcd_595_softspi.c ****     unsigned int n;
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
  31:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
  32:lcd_595_softspi.c ****         PORT_SPI |= (0x01&(cData>>(7-n)))<<DD_MOSI; // Set Data bit
 143               	.LM5:
 144 000c 90E0      		ldi r25,lo8(0)
 145               	.L3:
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
 147               	.LM6:
 148 000e 2998      		cbi 37-32,1
  31:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
 150               	.LM7:
 151 0010 2898      		cbi 37-32,0
 153               	.LM8:
 154 0012 65B1      		in r22,37-32
 155 0014 AC01      		movw r20,r24
 156 0016 022E      		mov r0,r18
 157 0018 00C0      		rjmp 2f
 158 001a 5595      	1:	asr r21
 159 001c 4795      		ror r20
 160 001e 0A94      	2:	dec r0
 161 0020 02F4      		brpl 1b
 162 0022 4170      		andi r20,lo8(1)
 163 0024 462B      		or r20,r22
 164 0026 45B9      		out 37-32,r20
  33:lcd_595_softspi.c ****         PORT_SPI |= (1<<DD_SCK);                // Set SCK "H"
 166               	.LM9:
 167 0028 299A      		sbi 37-32,1
 168 002a 2150      		subi r18,lo8(-(-1))
 169 002c 3040      		sbci r19,hi8(-(-1))
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
 171               	.LM10:
 172 002e 4FEF      		ldi r20,hi8(-1)
 173 0030 2F3F      		cpi r18,lo8(-1)
 174 0032 3407      		cpc r19,r20
 175 0034 01F4      		brne .L3
 176               	/* epilogue start */
  34:lcd_595_softspi.c ****     }
  35:lcd_595_softspi.c **** }
 178               	.LM11:
 179 0036 0895      		ret
 181               	.Lscope2:
 186               	.global	send_bits_595
 188               	send_bits_595:
  36:lcd_595_softspi.c **** 
  37:lcd_595_softspi.c **** void send_bits_595(unsigned char RS, unsigned char E, unsigned char DATA){
 190               	.LM12:
 191               	.LFBB3:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
  38:lcd_595_softspi.c ****     unsigned char bits;
  39:lcd_595_softspi.c ****     bits = 0x3f & ( (RS<<5)|(E<<4)|DATA );
 197               	.LM13:
 198 0038 8295      		swap r24
 199 003a 880F      		lsl r24
 200 003c 807E      		andi r24,lo8(-32)
 201 003e 842B      		or r24,r20
 202 0040 6295      		swap r22
 203 0042 607F      		andi r22,lo8(-16)
 204 0044 682B      		or r22,r24
  40:lcd_595_softspi.c ****     SoftSPI_TX(bits);
 206               	.LM14:
 207 0046 862F      		mov r24,r22
 208 0048 8F73      		andi r24,lo8(63)
 209 004a 0E94 0000 		call SoftSPI_TX
  41:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 211               	.LM15:
 212 004e 2A98      		cbi 37-32,2
  42:lcd_595_softspi.c ****     PORT_SPI |=  (1<<DD_RCK);   // Set RCK "H"
 214               	.LM16:
 215 0050 2A9A      		sbi 37-32,2
  43:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 217               	.LM17:
 218 0052 2A98      		cbi 37-32,2
 219               	/* epilogue start */
  44:lcd_595_softspi.c **** }
 221               	.LM18:
 222 0054 0895      		ret
 224               	.Lscope3:
 227               	.global	lcd_set_4bit
 229               	lcd_set_4bit:
  45:lcd_595_softspi.c **** 
  46:lcd_595_softspi.c **** // fuction for sending control bitpattern
  47:lcd_595_softspi.c **** void lcd_set_4bit(unsigned char bitpattern){
 231               	.LM19:
 232               	.LFBB4:
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 0 */
 236               	.L__stack_usage = 0
  48:lcd_595_softspi.c **** 	DATA    =   0x0f & bitpattern; // set sending data
 238               	.LM20:
 239 0056 482F      		mov r20,r24
 240 0058 4F70      		andi r20,lo8(15)
 241 005a 4093 0000 		sts DATA,r20
  49:lcd_595_softspi.c **** 	E       =   0;
 243               	.LM21:
 244 005e 1092 0000 		sts E,__zero_reg__
  50:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 246               	.LM22:
 247 0062 8091 0000 		lds r24,RS
 248 0066 60E0      		ldi r22,lo8(0)
 249 0068 0E94 0000 		call send_bits_595
  51:lcd_595_softspi.c **** 	E       =   1;
 251               	.LM23:
 252 006c 81E0      		ldi r24,lo8(1)
 253 006e 8093 0000 		sts E,r24
  52:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 255               	.LM24:
 256 0072 8091 0000 		lds r24,RS
 257 0076 61E0      		ldi r22,lo8(1)
 258 0078 4091 0000 		lds r20,DATA
 259 007c 0E94 0000 		call send_bits_595
  53:lcd_595_softspi.c **** 	E       =   0;
 261               	.LM25:
 262 0080 1092 0000 		sts E,__zero_reg__
  54:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 264               	.LM26:
 265 0084 8091 0000 		lds r24,RS
 266 0088 60E0      		ldi r22,lo8(0)
 267 008a 4091 0000 		lds r20,DATA
 268 008e 0E94 0000 		call send_bits_595
 269               	/* epilogue start */
  55:lcd_595_softspi.c **** }
 271               	.LM27:
 272 0092 0895      		ret
 274               	.Lscope4:
 276               	.global	lcd_init
 278               	lcd_init:
  56:lcd_595_softspi.c **** 
  57:lcd_595_softspi.c **** // Initializing LCD
  58:lcd_595_softspi.c **** void lcd_init(void){
 280               	.LM28:
 281               	.LFBB5:
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
  59:lcd_595_softspi.c **** 
  60:lcd_595_softspi.c **** 	// set enable "0"
  61:lcd_595_softspi.c ****     E       = 0;
 287               	.LM29:
 288 0094 1092 0000 		sts E,__zero_reg__
  62:lcd_595_softspi.c ****     // set instruction input mode
  63:lcd_595_softspi.c **** 	RS      = 0;
 290               	.LM30:
 291 0098 1092 0000 		sts RS,__zero_reg__
  64:lcd_595_softspi.c **** 	// initialize data port
  65:lcd_595_softspi.c **** 	DATA	= 0x00;
 293               	.LM31:
 294 009c 1092 0000 		sts DATA,__zero_reg__
  66:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 296               	.LM32:
 297 00a0 80E0      		ldi r24,lo8(0)
 298 00a2 60E0      		ldi r22,lo8(0)
 299 00a4 40E0      		ldi r20,lo8(0)
 300 00a6 0E94 0000 		call send_bits_595
 301               	.LBB26:
 302               	.LBB27:
 304               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 306               	.LM33:
 307 00aa 8FEF      		 ldi r24,lo8(63999)
 308 00ac 99EF      	    ldi r25,hi8(63999)
 309 00ae A0E0      	    ldi r26,hlo8(63999)
 310 00b0 8150      	    1:subi r24,1
 311 00b2 9040      	    sbci r25,0
 312 00b4 A040      	    sbci r26,0
 313 00b6 01F4      	    brne 1b
 314 00b8 00C0      		rjmp .
 315 00ba 0000      		nop
 316               	.LBE27:
 317               	.LBE26:
 319               	.Ltext2:
  67:lcd_595_softspi.c ****     
  68:lcd_595_softspi.c **** 	// wait more than 15ms
  69:lcd_595_softspi.c **** 	_delay_ms(20);
  70:lcd_595_softspi.c **** 
  71:lcd_595_softspi.c **** 	// set 8-bit mode
  72:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 321               	.LM34:
 322 00bc 83E0      		ldi r24,lo8(3)
 323 00be 0E94 0000 		call lcd_set_4bit
 324               	.LBB28:
 325               	.LBB29:
 327               	.Ltext3:
 329               	.LM35:
 330 00c2 AFE1      		 ldi r26,lo8(19999)
 331 00c4 BEE4      	    ldi r27,hi8(19999)
 332 00c6 1197      	    1:sbiw r26,1
 333 00c8 01F4      	    brne 1b
 334 00ca 00C0      		rjmp .
 335 00cc 0000      		nop
 336               	.LBE29:
 337               	.LBE28:
 339               	.Ltext4:
  73:lcd_595_softspi.c **** 	_delay_ms(5);
  74:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 341               	.LM36:
 342 00ce 83E0      		ldi r24,lo8(3)
 343 00d0 0E94 0000 		call lcd_set_4bit
 344               	.LBB30:
 345               	.LBB31:
 347               	.Ltext5:
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 349               	.LM37:
 350 00d4 87EB      		 ldi r24,lo8(439)
 351 00d6 91E0      	    ldi r25,hi8(439)
 352 00d8 0197      	    1:sbiw r24,1
 353 00da 01F4      	    brne 1b
 354 00dc 00C0      		rjmp .
 355 00de 0000      		nop
 356               	.LBE31:
 357               	.LBE30:
 359               	.Ltext6:
  75:lcd_595_softspi.c **** 	_delay_us(110);
  76:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 361               	.LM38:
 362 00e0 83E0      		ldi r24,lo8(3)
 363 00e2 0E94 0000 		call lcd_set_4bit
 364               	.LBB32:
 365               	.LBB33:
 367               	.Ltext7:
 369               	.LM39:
 370 00e6 A7EC      		 ldi r26,lo8(199)
 371 00e8 B0E0      	    ldi r27,hi8(199)
 372 00ea 1197      	    1:sbiw r26,1
 373 00ec 01F4      	    brne 1b
 374 00ee 00C0      		rjmp .
 375 00f0 0000      		nop
 376               	.LBE33:
 377               	.LBE32:
 379               	.Ltext8:
  77:lcd_595_softspi.c **** 	_delay_us(50);
  78:lcd_595_softspi.c **** 	
  79:lcd_595_softspi.c **** 	// set 4-bit mode
  80:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 381               	.LM40:
 382 00f2 82E0      		ldi r24,lo8(2)
 383 00f4 0E94 0000 		call lcd_set_4bit
 384               	.LBB34:
 385               	.LBB35:
 387               	.Ltext9:
 389               	.LM41:
 390 00f8 87EC      		 ldi r24,lo8(199)
 391 00fa 90E0      	    ldi r25,hi8(199)
 392 00fc 0197      	    1:sbiw r24,1
 393 00fe 01F4      	    brne 1b
 394 0100 00C0      		rjmp .
 395 0102 0000      		nop
 396               	.LBE35:
 397               	.LBE34:
 399               	.Ltext10:
  81:lcd_595_softspi.c **** 	_delay_us(50);
  82:lcd_595_softspi.c **** 
  83:lcd_595_softspi.c **** 	// function setting
  84:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 401               	.LM42:
 402 0104 82E0      		ldi r24,lo8(2)
 403 0106 0E94 0000 		call lcd_set_4bit
  85:lcd_595_softspi.c **** 	lcd_set_4bit(0x08);
 405               	.LM43:
 406 010a 88E0      		ldi r24,lo8(8)
 407 010c 0E94 0000 		call lcd_set_4bit
 408               	.LBB36:
 409               	.LBB37:
 411               	.Ltext11:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 413               	.LM44:
 414 0110 AFE9      		 ldi r26,lo8(3999)
 415 0112 BFE0      	    ldi r27,hi8(3999)
 416 0114 1197      	    1:sbiw r26,1
 417 0116 01F4      	    brne 1b
 418 0118 00C0      		rjmp .
 419 011a 0000      		nop
 420               	.LBE37:
 421               	.LBE36:
 423               	.Ltext12:
  86:lcd_595_softspi.c **** 	_delay_ms(1);
  87:lcd_595_softspi.c **** 
  88:lcd_595_softspi.c **** 	// set display on, cursol off and blink off
  89:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 425               	.LM45:
 426 011c 80E0      		ldi r24,lo8(0)
 427 011e 0E94 0000 		call lcd_set_4bit
  90:lcd_595_softspi.c **** 	lcd_set_4bit(0x0c);
 429               	.LM46:
 430 0122 8CE0      		ldi r24,lo8(12)
 431 0124 0E94 0000 		call lcd_set_4bit
 432               	.LBB38:
 433               	.LBB39:
 435               	.Ltext13:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 437               	.LM47:
 438 0128 8FE9      		 ldi r24,lo8(3999)
 439 012a 9FE0      	    ldi r25,hi8(3999)
 440 012c 0197      	    1:sbiw r24,1
 441 012e 01F4      	    brne 1b
 442 0130 00C0      		rjmp .
 443 0132 0000      		nop
 444               	.LBE39:
 445               	.LBE38:
 447               	.Ltext14:
  91:lcd_595_softspi.c **** 	_delay_ms(1);
  92:lcd_595_softspi.c **** 
  93:lcd_595_softspi.c **** 	// set entry mode (cursol direction : right, disable shift)
  94:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 449               	.LM48:
 450 0134 80E0      		ldi r24,lo8(0)
 451 0136 0E94 0000 		call lcd_set_4bit
  95:lcd_595_softspi.c **** 	lcd_set_4bit(0x06);
 453               	.LM49:
 454 013a 86E0      		ldi r24,lo8(6)
 455 013c 0E94 0000 		call lcd_set_4bit
 456               	.LBB40:
 457               	.LBB41:
 459               	.Ltext15:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 461               	.LM50:
 462 0140 AFE9      		 ldi r26,lo8(3999)
 463 0142 BFE0      	    ldi r27,hi8(3999)
 464 0144 1197      	    1:sbiw r26,1
 465 0146 01F4      	    brne 1b
 466 0148 00C0      		rjmp .
 467 014a 0000      		nop
 468               	.LBE41:
 469               	.LBE40:
 471               	.Ltext16:
  96:lcd_595_softspi.c **** 	_delay_ms(1);
  97:lcd_595_softspi.c **** 
  98:lcd_595_softspi.c **** 	// clear display
  99:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 473               	.LM51:
 474 014c 80E0      		ldi r24,lo8(0)
 475 014e 0E94 0000 		call lcd_set_4bit
 100:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 477               	.LM52:
 478 0152 81E0      		ldi r24,lo8(1)
 479 0154 0E94 0000 		call lcd_set_4bit
 480               	.LBB42:
 481               	.LBB43:
 483               	.Ltext17:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 485               	.LM53:
 486 0158 8FE3      		 ldi r24,lo8(7999)
 487 015a 9FE1      	    ldi r25,hi8(7999)
 488 015c 0197      	    1:sbiw r24,1
 489 015e 01F4      	    brne 1b
 490 0160 00C0      		rjmp .
 491 0162 0000      		nop
 492               	.LBE43:
 493               	.LBE42:
 495               	.Ltext18:
 101:lcd_595_softspi.c **** 	_delay_ms(2);
 102:lcd_595_softspi.c **** 
 103:lcd_595_softspi.c **** 	// clear cursol position
 104:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 497               	.LM54:
 498 0164 80E0      		ldi r24,lo8(0)
 499 0166 0E94 0000 		call lcd_set_4bit
 105:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 501               	.LM55:
 502 016a 82E0      		ldi r24,lo8(2)
 503 016c 0E94 0000 		call lcd_set_4bit
 504               	.LBB44:
 505               	.LBB45:
 507               	.Ltext19:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 509               	.LM56:
 510 0170 AFE3      		 ldi r26,lo8(7999)
 511 0172 BFE1      	    ldi r27,hi8(7999)
 512 0174 1197      	    1:sbiw r26,1
 513 0176 01F4      	    brne 1b
 514 0178 00C0      		rjmp .
 515 017a 0000      		nop
 516               	.LBE45:
 517               	.LBE44:
 519               	.Ltext20:
 106:lcd_595_softspi.c **** 	_delay_ms(2);
 107:lcd_595_softspi.c **** 
 108:lcd_595_softspi.c **** 	// set data input mode
 109:lcd_595_softspi.c ****     RS      =   1;
 521               	.LM57:
 522 017c 81E0      		ldi r24,lo8(1)
 523 017e 8093 0000 		sts RS,r24
 524               	/* epilogue start */
 110:lcd_595_softspi.c **** }
 526               	.LM58:
 527 0182 0895      		ret
 529               	.Lscope5:
 532               	.global	lcd_set_char
 534               	lcd_set_char:
 111:lcd_595_softspi.c **** 
 112:lcd_595_softspi.c **** // LCD character allocation
 113:lcd_595_softspi.c **** void lcd_locate(unsigned char row, unsigned char col)
 114:lcd_595_softspi.c **** {
 115:lcd_595_softspi.c **** 	// set instruction input mode
 116:lcd_595_softspi.c ****     RS      =   0;
 117:lcd_595_softspi.c **** //	lcd_set_char(0x80 | col | (0x40 * row) );
 118:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 119:lcd_595_softspi.c **** 	// set data input mode
 120:lcd_595_softspi.c ****     RS      =   1;
 121:lcd_595_softspi.c **** }
 122:lcd_595_softspi.c **** 
 123:lcd_595_softspi.c **** // LCD character (1 byte) sending
 124:lcd_595_softspi.c **** void lcd_set_char(unsigned char c)
 125:lcd_595_softspi.c **** {
 536               	.LM59:
 537               	.LFBB6:
 538 0184 CF93      		push r28
 539               	/* prologue: function */
 540               	/* frame size = 0 */
 541               	/* stack size = 1 */
 542               	.L__stack_usage = 1
 543 0186 C82F      		mov r28,r24
 126:lcd_595_softspi.c **** 	lcd_set_4bit(c >> 4); // Upper Bit
 545               	.LM60:
 546 0188 8295      		swap r24
 547 018a 8F70      		andi r24,lo8(15)
 548 018c 0E94 0000 		call lcd_set_4bit
 127:lcd_595_softspi.c **** 	lcd_set_4bit(0x0f & c); // Lower Bit
 550               	.LM61:
 551 0190 8C2F      		mov r24,r28
 552 0192 8F70      		andi r24,lo8(15)
 553 0194 0E94 0000 		call lcd_set_4bit
 554               	.LBB46:
 555               	.LBB47:
 557               	.Ltext21:
 559               	.LM62:
 560 0198 87EC      		 ldi r24,lo8(199)
 561 019a 90E0      	    ldi r25,hi8(199)
 562 019c 0197      	    1:sbiw r24,1
 563 019e 01F4      	    brne 1b
 564 01a0 00C0      		rjmp .
 565 01a2 0000      		nop
 566               	/* epilogue start */
 567               	.LBE47:
 568               	.LBE46:
 570               	.Ltext22:
 128:lcd_595_softspi.c **** 	_delay_us(50);
 129:lcd_595_softspi.c **** }
 572               	.LM63:
 573 01a4 CF91      		pop r28
 574 01a6 0895      		ret
 576               	.Lscope6:
 580               	.global	lcd_locate
 582               	lcd_locate:
 114:lcd_595_softspi.c **** {
 584               	.LM64:
 585               	.LFBB7:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 116:lcd_595_softspi.c ****     RS      =   0;
 591               	.LM65:
 592 01a8 1092 0000 		sts RS,__zero_reg__
 118:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 594               	.LM66:
 595 01ac 982F      		mov r25,r24
 596 01ae 9170      		andi r25,lo8(1)
 597 01b0 9295      		swap r25
 598 01b2 990F      		lsl r25
 599 01b4 990F      		lsl r25
 600 01b6 907C      		andi r25,lo8(-64)
 601 01b8 9068      		ori r25,lo8(-128)
 602 01ba 8695      		lsr r24
 603 01bc 24E1      		ldi r18,lo8(20)
 604 01be 829F      		mul r24,r18
 605 01c0 802D      		mov r24,r0
 606 01c2 1124      		clr r1
 607 01c4 860F      		add r24,r22
 608 01c6 892B      		or r24,r25
 609 01c8 0E94 0000 		call lcd_set_char
 120:lcd_595_softspi.c ****     RS      =   1;
 611               	.LM67:
 612 01cc 81E0      		ldi r24,lo8(1)
 613 01ce 8093 0000 		sts RS,r24
 614               	/* epilogue start */
 121:lcd_595_softspi.c **** }
 616               	.LM68:
 617 01d2 0895      		ret
 619               	.Lscope7:
 621               	.global	lcd_set_str
 623               	lcd_set_str:
 130:lcd_595_softspi.c **** 
 131:lcd_595_softspi.c **** // LCD String Sending
 132:lcd_595_softspi.c **** void lcd_set_str(unsigned char *s)
 133:lcd_595_softspi.c **** {
 625               	.LM69:
 626               	.LFBB8:
 627 01d4 CF93      		push r28
 628 01d6 DF93      		push r29
 629               	/* prologue: function */
 630               	/* frame size = 0 */
 631               	/* stack size = 2 */
 632               	.L__stack_usage = 2
 634               	.LM70:
 635 01d8 EC01      		movw r28,r24
 134:lcd_595_softspi.c **** 	while (*s != 0) {
 637               	.LM71:
 638 01da 00C0      		rjmp .L11
 639               	.L12:
 135:lcd_595_softspi.c **** 		lcd_set_char(*s);
 641               	.LM72:
 642 01dc 0E94 0000 		call lcd_set_char
 643               	.L11:
 134:lcd_595_softspi.c **** 	while (*s != 0) {
 645               	.LM73:
 646 01e0 8991      		ld r24,Y+
 647 01e2 8823      		tst r24
 648 01e4 01F4      		brne .L12
 649               	/* epilogue start */
 136:lcd_595_softspi.c **** 		s++;
 137:lcd_595_softspi.c **** 	} 
 138:lcd_595_softspi.c **** }
 651               	.LM74:
 652 01e6 DF91      		pop r29
 653 01e8 CF91      		pop r28
 654 01ea 0895      		ret
 656               	.Lscope8:
 662               	.global	lcd_set_numeric
 664               	lcd_set_numeric:
 139:lcd_595_softspi.c **** 
 140:lcd_595_softspi.c **** // Display numeric on LCD display
 141:lcd_595_softspi.c **** void lcd_set_numeric(float num, unsigned int Nint, unsigned int Nfrac, unsigned int sign){
 666               	.LM75:
 667               	.LFBB9:
 668 01ec 2F92      		push r2
 669 01ee 3F92      		push r3
 670 01f0 4F92      		push r4
 671 01f2 5F92      		push r5
 672 01f4 6F92      		push r6
 673 01f6 7F92      		push r7
 674 01f8 8F92      		push r8
 675 01fa 9F92      		push r9
 676 01fc AF92      		push r10
 677 01fe BF92      		push r11
 678 0200 CF92      		push r12
 679 0202 DF92      		push r13
 680 0204 EF92      		push r14
 681 0206 FF92      		push r15
 682 0208 0F93      		push r16
 683 020a 1F93      		push r17
 684 020c CF93      		push r28
 685 020e DF93      		push r29
 686 0210 CDB7      		in r28,__SP_L__
 687 0212 DEB7      		in r29,__SP_H__
 688 0214 2897      		sbiw r28,8
 689 0216 0FB6      		in __tmp_reg__,__SREG__
 690 0218 F894      		cli
 691 021a DEBF      		out __SP_H__,r29
 692 021c 0FBE      		out __SREG__,__tmp_reg__
 693 021e CDBF      		out __SP_L__,r28
 694               	/* prologue: function */
 695               	/* frame size = 8 */
 696               	/* stack size = 26 */
 697               	.L__stack_usage = 26
 698 0220 6B01      		movw r12,r22
 699 0222 7C01      		movw r14,r24
 700 0224 1A01      		movw r2,r20
 701 0226 2901      		movw r4,r18
 142:lcd_595_softspi.c ****     unsigned long int DivFactor = 1;
 143:lcd_595_softspi.c **** 	unsigned int n, m;
 144:lcd_595_softspi.c **** 	unsigned int d[10];
 145:lcd_595_softspi.c ****     unsigned int valid = 0;
 146:lcd_595_softspi.c ****     
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 703               	.LM76:
 704 0228 80E0      		ldi r24,lo8(0)
 705 022a 90E0      		ldi r25,hi8(0)
 706 022c 4C01      		movw r8,r24
 707 022e 00C0      		rjmp .L14
 708               	.L15:
 148:lcd_595_softspi.c ****         num = num * 10;
 710               	.LM77:
 711 0230 C701      		movw r24,r14
 712 0232 B601      		movw r22,r12
 713 0234 20E0      		ldi r18,lo8(0x41200000)
 714 0236 30E0      		ldi r19,hi8(0x41200000)
 715 0238 40E2      		ldi r20,hlo8(0x41200000)
 716 023a 51E4      		ldi r21,hhi8(0x41200000)
 717 023c 0E94 0000 		call __mulsf3
 718 0240 C62E      		mov r12,r22
 719 0242 D72E      		mov r13,r23
 720 0244 E82E      		mov r14,r24
 721 0246 F92E      		mov r15,r25
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 723               	.LM78:
 724 0248 0894      		sec
 725 024a 811C      		adc r8,__zero_reg__
 726 024c 911C      		adc r9,__zero_reg__
 727               	.L14:
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 729               	.LM79:
 730 024e 8414      		cp r8,r4
 731 0250 9504      		cpc r9,r5
 732 0252 01F4      		brne .L15
 149:lcd_595_softspi.c ****     }
 150:lcd_595_softspi.c ****     
 151:lcd_595_softspi.c ****     // Detect sign
 152:lcd_595_softspi.c ****     if( sign == 1){
 734               	.LM80:
 735 0254 0130      		cpi r16,1
 736 0256 1105      		cpc r17,__zero_reg__
 737 0258 01F4      		brne .L16
 153:lcd_595_softspi.c ****         if( num < 0 ){
 739               	.LM81:
 740 025a C701      		movw r24,r14
 741 025c B601      		movw r22,r12
 742 025e 20E0      		ldi r18,lo8(0x0)
 743 0260 30E0      		ldi r19,hi8(0x0)
 744 0262 A901      		movw r20,r18
 745 0264 0E94 0000 		call __ltsf2
 746 0268 87FF      		sbrs r24,7
 747 026a 00C0      		rjmp .L34
 154:lcd_595_softspi.c ****             lcd_set_char('-');
 749               	.LM82:
 750 026c 8DE2      		ldi r24,lo8(45)
 751 026e 0E94 0000 		call lcd_set_char
 155:lcd_595_softspi.c ****             num = -num;
 753               	.LM83:
 754 0272 F7FA      		bst r15,7
 755 0274 F094      		com r15
 756 0276 F7F8      		bld r15,7
 757 0278 F094      		com r15
 758               	.L16:
 156:lcd_595_softspi.c ****         }else{
 157:lcd_595_softspi.c ****             lcd_set_char('+');
 158:lcd_595_softspi.c ****         }
 159:lcd_595_softspi.c ****     }
 160:lcd_595_softspi.c ****     // end of
 161:lcd_595_softspi.c **** 				
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 163:lcd_595_softspi.c ****         
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 165:lcd_595_softspi.c ****             lcd_set_char('.');
 166:lcd_595_softspi.c ****         }
 167:lcd_595_softspi.c ****         
 168:lcd_595_softspi.c ****         DivFactor = 1;
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 171:lcd_595_softspi.c ****         }
 172:lcd_595_softspi.c ****         
 173:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 174:lcd_595_softspi.c ****         if( (valid == 0) && ( d[n]!=0 || n==Nint-1) ) valid = 1;
 760               	.LM84:
 761 027a 00E0      		ldi r16,lo8(0)
 762 027c 10E0      		ldi r17,hi8(0)
 763 027e 6624      		clr r6
 764 0280 7724      		clr r7
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 766               	.LM85:
 767 0282 9201      		movw r18,r4
 768 0284 220D      		add r18,r2
 769 0286 331D      		adc r19,r3
 770 0288 3A83      		std Y+2,r19
 771 028a 2983      		std Y+1,r18
 772 028c 2150      		subi r18,lo8(-(-1))
 773 028e 3040      		sbci r19,hi8(-(-1))
 774 0290 3C83      		std Y+4,r19
 775 0292 2B83      		std Y+3,r18
 777               	.LM86:
 778 0294 C101      		movw r24,r2
 779 0296 0197      		sbiw r24,1
 780 0298 9E83      		std Y+6,r25
 781 029a 8D83      		std Y+5,r24
 782 029c 7886      		std Y+8,r7
 783 029e 6F82      		std Y+7,r6
 784 02a0 00C0      		rjmp .L19
 785               	.L34:
 157:lcd_595_softspi.c ****             lcd_set_char('+');
 787               	.LM87:
 788 02a2 8BE2      		ldi r24,lo8(43)
 789 02a4 0E94 0000 		call lcd_set_char
 790 02a8 00C0      		rjmp .L16
 791               	.L29:
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 793               	.LM88:
 794 02aa 0215      		cp r16,r2
 795 02ac 1305      		cpc r17,r3
 796 02ae 01F4      		brne .L20
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 798               	.LM89:
 799 02b0 4114      		cp r4,__zero_reg__
 800 02b2 5104      		cpc r5,__zero_reg__
 801 02b4 01F0      		breq .L20
 165:lcd_595_softspi.c ****             lcd_set_char('.');
 803               	.LM90:
 804 02b6 8EE2      		ldi r24,lo8(46)
 805 02b8 0E94 0000 		call lcd_set_char
 806               	.L20:
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 808               	.LM91:
 809 02bc 3801      		movw r6,r16
 168:lcd_595_softspi.c ****         DivFactor = 1;
 811               	.LM92:
 812 02be 81E0      		ldi r24,lo8(1)
 813 02c0 882E      		mov r8,r24
 814 02c2 912C      		mov r9,__zero_reg__
 815 02c4 A12C      		mov r10,__zero_reg__
 816 02c6 B12C      		mov r11,__zero_reg__
 817 02c8 C501      		movw r24,r10
 818 02ca B401      		movw r22,r8
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 820               	.LM93:
 821 02cc 00C0      		rjmp .L21
 822               	.L22:
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 824               	.LM94:
 825 02ce 2AE0      		ldi r18,lo8(10)
 826 02d0 30E0      		ldi r19,hi8(10)
 827 02d2 40E0      		ldi r20,hlo8(10)
 828 02d4 50E0      		ldi r21,hhi8(10)
 829 02d6 0E94 0000 		call __mulsi3
 830               	.L21:
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 832               	.LM95:
 833 02da 0894      		sec
 834 02dc 611C      		adc r6,__zero_reg__
 835 02de 711C      		adc r7,__zero_reg__
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 837               	.LM96:
 838 02e0 E981      		ldd r30,Y+1
 839 02e2 FA81      		ldd r31,Y+2
 840 02e4 6E16      		cp r6,r30
 841 02e6 7F06      		cpc r7,r31
 842 02e8 00F0      		brlo .L22
 843 02ea 4B01      		movw r8,r22
 844 02ec 5C01      		movw r10,r24
 173:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 846               	.LM97:
 847 02ee 0E94 0000 		call __floatunsisf
 848 02f2 9B01      		movw r18,r22
 849 02f4 AC01      		movw r20,r24
 850 02f6 C701      		movw r24,r14
 851 02f8 B601      		movw r22,r12
 852 02fa 0E94 0000 		call __divsf3
 853 02fe 0E94 0000 		call __fixunssfsi
 854 0302 DC01      		movw r26,r24
 855 0304 CB01      		movw r24,r22
 856 0306 3C01      		movw r6,r24
 858               	.LM98:
 859 0308 2F81      		ldd r18,Y+7
 860 030a 3885      		ldd r19,Y+8
 861 030c 2115      		cp r18,__zero_reg__
 862 030e 3105      		cpc r19,__zero_reg__
 863 0310 01F4      		brne .L30
 865               	.LM99:
 866 0312 81E0      		ldi r24,lo8(1)
 867 0314 90E0      		ldi r25,hi8(1)
 868 0316 9887      		std Y+8,r25
 869 0318 8F83      		std Y+7,r24
 870 031a 6114      		cp r6,__zero_reg__
 871 031c 7104      		cpc r7,__zero_reg__
 872 031e 01F4      		brne .L23
 874               	.LM100:
 875 0320 ED81      		ldd r30,Y+5
 876 0322 FE81      		ldd r31,Y+6
 877 0324 0E17      		cp r16,r30
 878 0326 1F07      		cpc r17,r31
 879 0328 01F0      		breq .L23
 880 032a 1886      		std Y+8,__zero_reg__
 881 032c 1F82      		std Y+7,__zero_reg__
 882 032e 00C0      		rjmp .L23
 883               	.L30:
 885               	.LM101:
 886 0330 21E0      		ldi r18,lo8(1)
 887 0332 30E0      		ldi r19,hi8(1)
 888 0334 3887      		std Y+8,r19
 889 0336 2F83      		std Y+7,r18
 890               	.L23:
 175:lcd_595_softspi.c ****         num = num - d[n]*DivFactor;
 892               	.LM102:
 893 0338 B301      		movw r22,r6
 894 033a 80E0      		ldi r24,lo8(0)
 895 033c 90E0      		ldi r25,hi8(0)
 896 033e A501      		movw r20,r10
 897 0340 9401      		movw r18,r8
 898 0342 0E94 0000 		call __mulsi3
 899 0346 0E94 0000 		call __floatunsisf
 900 034a 9B01      		movw r18,r22
 901 034c AC01      		movw r20,r24
 902 034e C701      		movw r24,r14
 903 0350 B601      		movw r22,r12
 904 0352 0E94 0000 		call __subsf3
 905 0356 6B01      		movw r12,r22
 906 0358 E82E      		mov r14,r24
 907 035a F92E      		mov r15,r25
 176:lcd_595_softspi.c ****         
 177:lcd_595_softspi.c ****         if( (valid == 1)|(n == (Nint+Nfrac-1)) ) lcd_set_char(0x30 + d[n]);
 909               	.LM103:
 910 035c EF81      		ldd r30,Y+7
 911 035e F885      		ldd r31,Y+8
 912 0360 3097      		sbiw r30,0
 913 0362 01F4      		brne .L33
 914 0364 2B81      		ldd r18,Y+3
 915 0366 3C81      		ldd r19,Y+4
 916 0368 0217      		cp r16,r18
 917 036a 1307      		cpc r17,r19
 918 036c 01F4      		brne .L35
 919               	.L33:
 921               	.LM104:
 922 036e 862D      		mov r24,r6
 923 0370 805D      		subi r24,lo8(-(48))
 924 0372 00C0      		rjmp .L36
 925               	.L35:
 178:lcd_595_softspi.c ****         else if( valid == 0 )                   lcd_set_char(0x20);
 927               	.LM105:
 928 0374 80E2      		ldi r24,lo8(32)
 929               	.L36:
 930 0376 0E94 0000 		call lcd_set_char
 931 037a 0F5F      		subi r16,lo8(-(1))
 932 037c 1F4F      		sbci r17,hi8(-(1))
 933               	.L19:
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 935               	.LM106:
 936 037e 8B81      		ldd r24,Y+3
 937 0380 9C81      		ldd r25,Y+4
 938 0382 8017      		cp r24,r16
 939 0384 9107      		cpc r25,r17
 940 0386 00F0      		brlo .+2
 941 0388 00C0      		rjmp .L29
 942               	/* epilogue start */
 179:lcd_595_softspi.c ****         else                                    lcd_set_char(0xff);
 180:lcd_595_softspi.c ****     }
 181:lcd_595_softspi.c **** }
 944               	.LM107:
 945 038a 2896      		adiw r28,8
 946 038c 0FB6      		in __tmp_reg__,__SREG__
 947 038e F894      		cli
 948 0390 DEBF      		out __SP_H__,r29
 949 0392 0FBE      		out __SREG__,__tmp_reg__
 950 0394 CDBF      		out __SP_L__,r28
 951 0396 DF91      		pop r29
 952 0398 CF91      		pop r28
 953 039a 1F91      		pop r17
 954 039c 0F91      		pop r16
 955 039e FF90      		pop r15
 956 03a0 EF90      		pop r14
 957 03a2 DF90      		pop r13
 958 03a4 CF90      		pop r12
 959 03a6 BF90      		pop r11
 960 03a8 AF90      		pop r10
 961 03aa 9F90      		pop r9
 962 03ac 8F90      		pop r8
 963 03ae 7F90      		pop r7
 964 03b0 6F90      		pop r6
 965 03b2 5F90      		pop r5
 966 03b4 4F90      		pop r4
 967 03b6 3F90      		pop r3
 968 03b8 2F90      		pop r2
 969 03ba 0895      		ret
 976               	.Lscope9:
 978               	.global	lcd_clear
 980               	lcd_clear:
 182:lcd_595_softspi.c **** 
 183:lcd_595_softspi.c **** // Clear LCD
 184:lcd_595_softspi.c **** void lcd_clear(void){
 982               	.LM108:
 983               	.LFBB10:
 984               	/* prologue: function */
 985               	/* frame size = 0 */
 986               	/* stack size = 0 */
 987               	.L__stack_usage = 0
 185:lcd_595_softspi.c **** 	// clear display
 186:lcd_595_softspi.c ****     RS      =   0;
 989               	.LM109:
 990 03bc 1092 0000 		sts RS,__zero_reg__
 187:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 992               	.LM110:
 993 03c0 80E0      		ldi r24,lo8(0)
 994 03c2 0E94 0000 		call lcd_set_4bit
 188:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 996               	.LM111:
 997 03c6 81E0      		ldi r24,lo8(1)
 998 03c8 0E94 0000 		call lcd_set_4bit
 999               	.LBB48:
 1000               	.LBB49:
 1002               	.Ltext23:
 1004               	.LM112:
 1005 03cc 85E3      		 ldi r24,lo8(53)
 1006 03ce 8A95      	    1:dec r24
 1007 03d0 01F4      	    brne 1b
 1008 03d2 0000      		nop
 1009               	.LBE49:
 1010               	.LBE48:
 1012               	.Ltext24:
 189:lcd_595_softspi.c ****     _delay_us(10);
 190:lcd_595_softspi.c **** //    _delay_ms(1);
 191:lcd_595_softspi.c ****     RS      =   1;
 1014               	.LM113:
 1015 03d4 81E0      		ldi r24,lo8(1)
 1016 03d6 8093 0000 		sts RS,r24
 192:lcd_595_softspi.c **** 	lcd_locate(0,0);
 1018               	.LM114:
 1019 03da 80E0      		ldi r24,lo8(0)
 1020 03dc 60E0      		ldi r22,lo8(0)
 1021 03de 0E94 0000 		call lcd_locate
 1022               	/* epilogue start */
 193:lcd_595_softspi.c **** }
 1024               	.LM115:
 1025 03e2 0895      		ret
 1027               	.Lscope10:
 1031               	.global	lcd_set_CGRAMaddr
 1033               	lcd_set_CGRAMaddr:
 194:lcd_595_softspi.c **** 
 195:lcd_595_softspi.c **** // Set CGRAM address
 196:lcd_595_softspi.c **** void lcd_set_CGRAMaddr(unsigned char code,unsigned char addr)
 197:lcd_595_softspi.c **** {
 1035               	.LM116:
 1036               	.LFBB11:
 1037               	/* prologue: function */
 1038               	/* frame size = 0 */
 1039               	/* stack size = 0 */
 1040               	.L__stack_usage = 0
 198:lcd_595_softspi.c **** 	// set instruction input mode
 199:lcd_595_softspi.c ****     RS      =   0;
 1042               	.LM117:
 1043 03e4 1092 0000 		sts RS,__zero_reg__
 200:lcd_595_softspi.c ****     lcd_set_char(0x40 | code<<3 | addr );
 1045               	.LM118:
 1046 03e8 6064      		ori r22,lo8(64)
 1047 03ea 880F      		lsl r24
 1048 03ec 880F      		lsl r24
 1049 03ee 880F      		lsl r24
 1050 03f0 862B      		or r24,r22
 1051 03f2 0E94 0000 		call lcd_set_char
 201:lcd_595_softspi.c **** 	// set data input mode
 202:lcd_595_softspi.c ****     RS      =   1;
 1053               	.LM119:
 1054 03f6 81E0      		ldi r24,lo8(1)
 1055 03f8 8093 0000 		sts RS,r24
 1056               	/* epilogue start */
 203:lcd_595_softspi.c **** }
 1058               	.LM120:
 1059 03fc 0895      		ret
 1061               	.Lscope11:
 1062               		.comm DATA,1,1
 1063               		.comm RS,1,1
 1064               		.comm E,1,1
 1069               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 lcd_595_softspi.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:107    .text:00000000 SoftSPI_Init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:130    .text:00000008 SoftSPI_TX
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:188    .text:00000038 send_bits_595
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:229    .text:00000056 lcd_set_4bit
                            *COM*:00000001 DATA
                            *COM*:00000001 E
                            *COM*:00000001 RS
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:278    .text:00000094 lcd_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:534    .text:00000184 lcd_set_char
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:582    .text:000001a8 lcd_locate
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:623    .text:000001d4 lcd_set_str
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:664    .text:000001ec lcd_set_numeric
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:980    .text:000003bc lcd_clear
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cceOFgQD.s:1033   .text:000003e4 lcd_set_CGRAMaddr

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsf3
__ltsf2
__mulsi3
__floatunsisf
__divsf3
__fixunssfsi
__subsf3
