   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 110               	.global	set_initial_t_id
 112               	set_initial_t_id:
   1:main.c        **** //
   2:main.c        **** //             Multi Function Meter
   3:main.c        **** //                  Revision 7
   4:main.c        **** //
   5:main.c        **** //    Display data of Defi Link Unit 2 daisy chain
   6:main.c        **** //   "Measure Defi Link Unit 2 data interval freqency"
   7:main.c        **** //
   8:main.c        **** //      Display : SC2004
   9:main.c        **** //
  10:main.c        **** //      Added feature
  11:main.c        **** //          Fuel Pump Drive
  12:main.c        **** //          USART-USB output
  13:main.c        **** //
  14:main.c        **** //      Program
  15:main.c        **** //          use FLASH memory for constant variables
  16:main.c        **** //
  17:main.c        **** 
  18:main.c        **** // #include <math.h>
  19:main.c        **** 
  20:main.c        **** #include <avr/io.h>
  21:main.c        **** #include <avr/interrupt.h>
  22:main.c        **** #include <util/delay.h>
  23:main.c        **** #include <avr/pgmspace.h>
  24:main.c        **** 
  25:main.c        **** #include "lcd_595_softspi.h"
  26:main.c        **** #include "ledarray_595_softspi.h"
  27:main.c        **** #include "ExtInterrupt.h"
  28:main.c        **** #include "usart.h"
  29:main.c        **** #include "tictoc.h"
  30:main.c        **** #include "TachoMeter.h"
  31:main.c        **** // #include "facemark.h"
  32:main.c        **** 
  33:main.c        **** // USB communication ( 0:disble , 1:enable )
  34:main.c        **** #define USB_COM         1
  35:main.c        **** 
  36:main.c        **** // MCU clock speed (for USART & Tacho)
  37:main.c        **** #define FOSC			16000000    // Clock Speed
  38:main.c        **** 
  39:main.c        **** // USART transmission speed definition
  40:main.c        **** #define BAUD			19200       // USART baud rate
  41:main.c        **** #define UBRR			FOSC/16/BAUD-1
  42:main.c        **** 
  43:main.c        **** // Number of Display data
  44:main.c        **** #define Ndata           2
  45:main.c        **** 
  46:main.c        **** // Wait time interval for display
  47:main.c        **** #define	DISP_WAIT		250     // unit : ms
  48:main.c        **** 
  49:main.c        **** // LCD width
  50:main.c        **** #define LCD_W           16
  51:main.c        **** 
  52:main.c        **** // Display character width of Defi Link Tap "name + data"
  53:main.c        **** //#define DISP_W          11
  54:main.c        **** #define DISP_W          7
  55:main.c        **** 
  56:main.c        **** // Threshold for Defi Link Unit Communication Error
  57:main.c        **** #define LINKTAP_TIMEOUT 300
  58:main.c        **** 
  59:main.c        **** // Definition of Global Variables
  60:main.c        **** 
  61:main.c        **** uint8_t     chg_index   = Ndata;
  62:main.c        **** uint16_t    chg_count   = 0xffff;
  63:main.c        **** 
  64:main.c        **** //
  65:main.c        **** const uint8_t   RxID[] = {
  66:main.c        ****         0x01,	// Turbo
  67:main.c        ****         0x02,	// Tacho
  68:main.c        ****         0x03,	// Oil pres.
  69:main.c        ****         0x04,	// Fuel pres.
  70:main.c        ****         0x05,	// Ext. Temp.
  71:main.c        ****         0x07,	// Oil Temp.
  72:main.c        ****         0x0f	// Water Temp.
  73:main.c        **** };
  74:main.c        **** 
  75:main.c        **** // Measure Tarfet ID Declarations
  76:main.c        **** uint8_t     t_id[Ndata];
  77:main.c        **** void set_initial_t_id(void){
 114               	.LM0:
 115               	.LFBB1:
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
  78:main.c        ****     t_id[0] = 3;
 121               	.LM1:
 122 0000 83E0      		ldi r24,lo8(3)
 123 0002 8093 0000 		sts t_id,r24
  79:main.c        ****     t_id[1] = 0;
 125               	.LM2:
 126 0006 1092 0000 		sts t_id+1,__zero_reg__
 127               	/* epilogue start */
  80:main.c        **** }
 129               	.LM3:
 130 000a 0895      		ret
 132               	.Lscope1:
 133               		.data
 134               	.LC0:
 135 0000 4241 4449 		.string	"BADISR ERROR"
 135      5352 2045 
 135      5252 4F52 
 135      00
 136               		.text
 138               	.global	__vector_default
 140               	__vector_default:
  81:main.c        **** 
  82:main.c        **** const char RxName_0[] PROGMEM = "BS";
  83:main.c        **** const char RxName_1[] PROGMEM = "TC";
  84:main.c        **** const char RxName_2[] PROGMEM = "OP";
  85:main.c        **** const char RxName_3[] PROGMEM = "FP";
  86:main.c        **** const char RxName_4[] PROGMEM = "ET";
  87:main.c        **** const char RxName_5[] PROGMEM = "OT";
  88:main.c        **** const char RxName_6[] PROGMEM = "WT";
  89:main.c        **** PGM_P const PROGMEM RxName[] = {
  90:main.c        ****     RxName_0,
  91:main.c        ****     RxName_1,
  92:main.c        ****     RxName_2,
  93:main.c        ****     RxName_3,
  94:main.c        ****     RxName_4,
  95:main.c        ****     RxName_5,
  96:main.c        ****     RxName_6
  97:main.c        **** };
  98:main.c        **** 
  99:main.c        **** const char   opening_message_0[] PROGMEM = "Fuel Pump Driver";
 100:main.c        **** const char   opening_message_1[] PROGMEM = "Firmware Rev. 10";
 101:main.c        **** PGM_P const PROGMEM opening_message[] = {
 102:main.c        ****     opening_message_0,
 103:main.c        ****     opening_message_1
 104:main.c        **** };
 105:main.c        **** 
 106:main.c        **** uint8_t     RxNameLength[7];
 107:main.c        **** 
 108:main.c        **** uint8_t     lcd_update  = 1;            // if bit is "1" then Re-draw LCD
 109:main.c        **** 
 110:main.c        **** unsigned char	data[Ndata][4];         // Receive data from Defi Link Control Unit
 111:main.c        **** //	data[*][0] : Control
 112:main.c        **** //	data[*][1] : Angle Data (MSB)
 113:main.c        **** //	data[*][2] : Angle Data
 114:main.c        **** //	data[*][3] : Angle Data (LSB)
 115:main.c        **** 
 116:main.c        **** volatile unsigned char	data_updated[Ndata];    // Data of packet
 117:main.c        **** 
 118:main.c        **** // Tacho Meter Variables Declaration
 119:main.c        **** unsigned long int   rpm = 0;
 120:main.c        **** 
 121:main.c        **** // Variables for timer
 122:main.c        **** uint16_t    timer2_cnt;
 123:main.c        **** uint16_t    disp_cnt_last = 0;
 124:main.c        **** uint16_t    disp_delay_cnt;
 125:main.c        **** 
 126:main.c        **** uint16_t   Ndiv0;
 127:main.c        **** uint16_t   Ndiv1;
 128:main.c        **** uint16_t   Ndiv2;
 129:main.c        **** uint8_t    USART_index;
 130:main.c        **** uint8_t    USART_data_index = 0xff; // do not initialize to "0"
 131:main.c        **** 
 132:main.c        **** // Bad ISR interrput detector for debugging
 133:main.c        **** ISR(BADISR_vect){
 142               	.LM4:
 143               	.LFBB2:
 144 000c 1F92      		push r1
 145 000e 0F92      		push r0
 146 0010 0FB6      		in r0,__SREG__
 147 0012 0F92      		push r0
 148 0014 1124      		clr __zero_reg__
 149               	/* prologue: Signal */
 150               	/* frame size = 0 */
 151               	/* stack size = 3 */
 152               	.L__stack_usage = 3
 134:main.c        ****     cli();    // disable interrupt
 154               	.LM5:
 155               	/* #APP */
 156               	 ;  134 "main.c" 1
 157 0016 F894      		cli
 158               	 ;  0 "" 2
 135:main.c        ****     lcd_locate(0,0);
 160               	.LM6:
 161               	/* #NOAPP */
 162 0018 80E0      		ldi r24,lo8(0)
 163 001a 60E0      		ldi r22,lo8(0)
 164 001c 0E94 0000 		call lcd_locate
 136:main.c        ****     lcd_set_str("BADISR ERROR");
 166               	.LM7:
 167 0020 80E0      		ldi r24,lo8(.LC0)
 168 0022 90E0      		ldi r25,hi8(.LC0)
 169 0024 0E94 0000 		call lcd_set_str
 170               	.L3:
 171 0028 00C0      		rjmp .L3
 173               	.Lscope2:
 175               	.global	timer0_init
 177               	timer0_init:
 137:main.c        ****     while(1);  // stop overall program
 138:main.c        **** }
 139:main.c        **** 
 140:main.c        **** 
 141:main.c        **** // 8-bit timer intialazation for PWM FuelPump Driver
 142:main.c        **** void timer0_init(void) {
 179               	.LM8:
 180               	.LFBB3:
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 0 */
 184               	.L__stack_usage = 0
 143:main.c        ****     // Fast PWM operation
 144:main.c        ****     TCCR0A  = 0b00100011;	// Timer/Counter0 Control Register A
 186               	.LM9:
 187 002a 83E2      		ldi r24,lo8(35)
 188 002c 84BD      		out 68-32,r24
 145:main.c        ****     TCCR0B  = 0b00001010;	// Timer/Counter0 Control Register B
 190               	.LM10:
 191 002e 8AE0      		ldi r24,lo8(10)
 192 0030 85BD      		out 69-32,r24
 146:main.c        ****     TIMSK0  = 0b00000000;   // ovfl interrupt is enabled for delay timer
 194               	.LM11:
 195 0032 1092 6E00 		sts 110,__zero_reg__
 147:main.c        ****     TCNT0   = 0x00;         // Initialize 8-bit counter bit
 197               	.LM12:
 198 0036 16BC      		out 70-32,__zero_reg__
 148:main.c        ****     OCR0A   = 0xff;         // Top value for Fuel Pump driver PWM
 200               	.LM13:
 201 0038 8FEF      		ldi r24,lo8(-1)
 202 003a 87BD      		out 71-32,r24
 149:main.c        ****     OCR0B   = 0xff;         // Compare value for Fuel Pump driver PWM
 204               	.LM14:
 205 003c 88BD      		out 72-32,r24
 150:main.c        **** 
 151:main.c        ****     switch( TCCR0B & 0b00000111 ){
 207               	.LM15:
 208 003e 85B5      		in r24,69-32
 209 0040 90E0      		ldi r25,lo8(0)
 210 0042 8770      		andi r24,lo8(7)
 211 0044 9070      		andi r25,hi8(7)
 212 0046 8330      		cpi r24,3
 213 0048 9105      		cpc r25,__zero_reg__
 214 004a 01F0      		breq .L8
 215 004c 8430      		cpi r24,4
 216 004e 9105      		cpc r25,__zero_reg__
 217 0050 04F4      		brge .L11
 218 0052 8130      		cpi r24,1
 219 0054 9105      		cpc r25,__zero_reg__
 220 0056 01F0      		breq .L13
 221 0058 8230      		cpi r24,2
 222 005a 9105      		cpc r25,__zero_reg__
 223 005c 01F4      		brne .L5
 224 005e 00C0      		rjmp .L14
 225               	.L11:
 226 0060 8430      		cpi r24,4
 227 0062 9105      		cpc r25,__zero_reg__
 228 0064 01F0      		breq .L9
 229 0066 8530      		cpi r24,5
 230 0068 9105      		cpc r25,__zero_reg__
 231 006a 01F4      		brne .L5
 232 006c 00C0      		rjmp .L15
 233               	.L14:
 152:main.c        ****         case 0b001 :
 153:main.c        ****             Ndiv0 = 1;
 154:main.c        ****             break;
 155:main.c        ****         case 0b010 :
 156:main.c        ****             Ndiv0 = 8;
 235               	.LM16:
 236 006e 88E0      		ldi r24,lo8(8)
 237 0070 90E0      		ldi r25,hi8(8)
 238 0072 00C0      		rjmp .L13
 239               	.L8:
 157:main.c        ****             break;
 158:main.c        ****         case 0b011 :
 159:main.c        ****             Ndiv0 = 64;
 241               	.LM17:
 242 0074 80E4      		ldi r24,lo8(64)
 243 0076 90E0      		ldi r25,hi8(64)
 244 0078 00C0      		rjmp .L13
 245               	.L9:
 160:main.c        ****             break;
 161:main.c        ****         case 0b100 :
 162:main.c        ****             Ndiv0 = 256;
 247               	.LM18:
 248 007a 80E0      		ldi r24,lo8(256)
 249 007c 91E0      		ldi r25,hi8(256)
 250 007e 00C0      		rjmp .L13
 251               	.L15:
 163:main.c        ****             break;
 164:main.c        ****         case 0b101 :
 165:main.c        ****             Ndiv0 = 1024;
 253               	.LM19:
 254 0080 80E0      		ldi r24,lo8(1024)
 255 0082 94E0      		ldi r25,hi8(1024)
 256 0084 00C0      		rjmp .L13
 257               	.L5:
 166:main.c        ****             break;
 167:main.c        ****         default :
 168:main.c        ****             Ndiv0 = 1;
 259               	.LM20:
 260 0086 81E0      		ldi r24,lo8(1)
 261 0088 90E0      		ldi r25,hi8(1)
 262               	.L13:
 263 008a 9093 0000 		sts Ndiv0+1,r25
 264 008e 8093 0000 		sts Ndiv0,r24
 265 0092 0895      		ret
 267               	.Lscope3:
 269               	.global	timer1_init
 271               	timer1_init:
 169:main.c        ****             break;
 170:main.c        ****     }
 171:main.c        ****     
 172:main.c        **** }
 173:main.c        **** 
 174:main.c        **** // 16-bit Counter intialazation for Tacho Meter
 175:main.c        **** void timer1_init(void) {
 273               	.LM21:
 274               	.LFBB4:
 275               	/* prologue: function */
 276               	/* frame size = 0 */
 277               	/* stack size = 0 */
 278               	.L__stack_usage = 0
 176:main.c        **** 	TCCR1A  = 0b00000000;	// Timer/Counter1 Control Register A
 280               	.LM22:
 281 0094 1092 8000 		sts 128,__zero_reg__
 177:main.c        **** 	TCCR1B  = 0b00000011;	// Timer/Counter1 Control Register B
 283               	.LM23:
 284 0098 83E0      		ldi r24,lo8(3)
 285 009a 8093 8100 		sts 129,r24
 178:main.c        **** 	TCCR1C  = 0b00000000;
 287               	.LM24:
 288 009e 1092 8200 		sts 130,__zero_reg__
 179:main.c        **** 	TIMSK1  = 0b00000001;
 290               	.LM25:
 291 00a2 81E0      		ldi r24,lo8(1)
 292 00a4 8093 6F00 		sts 111,r24
 180:main.c        **** 	TCNT1   = 0x0000;         // Initialize 16-bit counter bit
 294               	.LM26:
 295 00a8 1092 8500 		sts 132+1,__zero_reg__
 296 00ac 1092 8400 		sts 132,__zero_reg__
 181:main.c        **** 	OCR1A   = 0xffff;         // 16-bit register for compare
 298               	.LM27:
 299 00b0 8FEF      		ldi r24,lo8(-1)
 300 00b2 9FEF      		ldi r25,hi8(-1)
 301 00b4 9093 8900 		sts 136+1,r25
 302 00b8 8093 8800 		sts 136,r24
 182:main.c        **** 
 183:main.c        ****     switch( TCCR1B & 0b00000111 ){
 304               	.LM28:
 305 00bc 8091 8100 		lds r24,129
 306 00c0 90E0      		ldi r25,lo8(0)
 307 00c2 8770      		andi r24,lo8(7)
 308 00c4 9070      		andi r25,hi8(7)
 309 00c6 8330      		cpi r24,3
 310 00c8 9105      		cpc r25,__zero_reg__
 311 00ca 01F0      		breq .L20
 312 00cc 8430      		cpi r24,4
 313 00ce 9105      		cpc r25,__zero_reg__
 314 00d0 04F4      		brge .L23
 315 00d2 8130      		cpi r24,1
 316 00d4 9105      		cpc r25,__zero_reg__
 317 00d6 01F0      		breq .L25
 318 00d8 8230      		cpi r24,2
 319 00da 9105      		cpc r25,__zero_reg__
 320 00dc 01F4      		brne .L17
 321 00de 00C0      		rjmp .L26
 322               	.L23:
 323 00e0 8430      		cpi r24,4
 324 00e2 9105      		cpc r25,__zero_reg__
 325 00e4 01F0      		breq .L21
 326 00e6 8530      		cpi r24,5
 327 00e8 9105      		cpc r25,__zero_reg__
 328 00ea 01F4      		brne .L17
 329 00ec 00C0      		rjmp .L27
 330               	.L26:
 184:main.c        ****         case 0b001 :
 185:main.c        ****             Ndiv1 = 1;
 186:main.c        ****             break;
 187:main.c        ****         case 0b010 :
 188:main.c        ****             Ndiv1 = 8;
 332               	.LM29:
 333 00ee 88E0      		ldi r24,lo8(8)
 334 00f0 90E0      		ldi r25,hi8(8)
 335 00f2 00C0      		rjmp .L25
 336               	.L20:
 189:main.c        ****             break;
 190:main.c        ****         case 0b011 :
 191:main.c        ****             Ndiv1 = 64;
 338               	.LM30:
 339 00f4 80E4      		ldi r24,lo8(64)
 340 00f6 90E0      		ldi r25,hi8(64)
 341 00f8 00C0      		rjmp .L25
 342               	.L21:
 192:main.c        ****             break;
 193:main.c        ****         case 0b100 :
 194:main.c        ****             Ndiv1 = 256;
 344               	.LM31:
 345 00fa 80E0      		ldi r24,lo8(256)
 346 00fc 91E0      		ldi r25,hi8(256)
 347 00fe 00C0      		rjmp .L25
 348               	.L27:
 195:main.c        ****             break;
 196:main.c        ****         case 0b101 :
 197:main.c        ****             Ndiv1 = 1024;
 350               	.LM32:
 351 0100 80E0      		ldi r24,lo8(1024)
 352 0102 94E0      		ldi r25,hi8(1024)
 353 0104 00C0      		rjmp .L25
 354               	.L17:
 198:main.c        ****             break;
 199:main.c        ****         default :
 200:main.c        ****             Ndiv1 = 1;
 356               	.LM33:
 357 0106 81E0      		ldi r24,lo8(1)
 358 0108 90E0      		ldi r25,hi8(1)
 359               	.L25:
 360 010a 9093 0000 		sts Ndiv1+1,r25
 361 010e 8093 0000 		sts Ndiv1,r24
 362 0112 0895      		ret
 364               	.Lscope4:
 366               	.global	timer2_init
 368               	timer2_init:
 201:main.c        ****             break;
 202:main.c        ****     }
 203:main.c        ****     
 204:main.c        **** }
 205:main.c        **** 
 206:main.c        **** // 8-bit timer intialazation for Timing Control, LEDarray duty
 207:main.c        **** void timer2_init(void) {
 370               	.LM34:
 371               	.LFBB5:
 372               	/* prologue: function */
 373               	/* frame size = 0 */
 374               	/* stack size = 0 */
 375               	.L__stack_usage = 0
 208:main.c        ****     TCCR2A  = 0b00000000;	// Timer/Counter2 Control Register A
 377               	.LM35:
 378 0114 1092 B000 		sts 176,__zero_reg__
 209:main.c        ****     TCCR2B  = 0b00000111;	// Timer/Counter2 Control Register B
 380               	.LM36:
 381 0118 87E0      		ldi r24,lo8(7)
 382 011a 8093 B100 		sts 177,r24
 210:main.c        ****     TIMSK2  = 0b00000011;   // ovfl interrupt is enabled for delay timer
 384               	.LM37:
 385 011e 83E0      		ldi r24,lo8(3)
 386 0120 8093 7000 		sts 112,r24
 211:main.c        ****     TCNT2   = 0x00;         // Initialize 8-bit counter bit
 388               	.LM38:
 389 0124 1092 B200 		sts 178,__zero_reg__
 212:main.c        ****     OCR2A   = 8;
 391               	.LM39:
 392 0128 88E0      		ldi r24,lo8(8)
 393 012a 8093 B300 		sts 179,r24
 213:main.c        ****     
 214:main.c        ****     switch( TCCR2B & 0b00000111 ){
 395               	.LM40:
 396 012e 8091 B100 		lds r24,177
 397 0132 90E0      		ldi r25,lo8(0)
 398 0134 8770      		andi r24,lo8(7)
 399 0136 9070      		andi r25,hi8(7)
 400 0138 8430      		cpi r24,4
 401 013a 9105      		cpc r25,__zero_reg__
 402 013c 01F0      		breq .L33
 403 013e 8530      		cpi r24,5
 404 0140 9105      		cpc r25,__zero_reg__
 405 0142 04F4      		brge .L37
 406 0144 8230      		cpi r24,2
 407 0146 9105      		cpc r25,__zero_reg__
 408 0148 01F0      		breq .L31
 409 014a 8330      		cpi r24,3
 410 014c 9105      		cpc r25,__zero_reg__
 411 014e 04F4      		brge .L32
 412 0150 8130      		cpi r24,1
 413 0152 9105      		cpc r25,__zero_reg__
 414 0154 01F4      		brne .L29
 415 0156 00C0      		rjmp .L39
 416               	.L37:
 417 0158 8630      		cpi r24,6
 418 015a 9105      		cpc r25,__zero_reg__
 419 015c 01F0      		breq .L35
 420 015e 8630      		cpi r24,6
 421 0160 9105      		cpc r25,__zero_reg__
 422 0162 04F0      		brlt .L34
 423 0164 8730      		cpi r24,7
 424 0166 9105      		cpc r25,__zero_reg__
 425 0168 01F4      		brne .L29
 426 016a 00C0      		rjmp .L40
 427               	.L31:
 215:main.c        ****         case 0b001 :
 216:main.c        ****             Ndiv2 = 1;
 217:main.c        ****             break;
 218:main.c        ****         case 0b010 :
 219:main.c        ****             Ndiv2 = 8;
 429               	.LM41:
 430 016c 88E0      		ldi r24,lo8(8)
 431 016e 90E0      		ldi r25,hi8(8)
 432 0170 00C0      		rjmp .L39
 433               	.L32:
 220:main.c        ****             break;
 221:main.c        ****         case 0b011 :
 222:main.c        ****             Ndiv2 = 32;
 435               	.LM42:
 436 0172 80E2      		ldi r24,lo8(32)
 437 0174 90E0      		ldi r25,hi8(32)
 438 0176 00C0      		rjmp .L39
 439               	.L33:
 223:main.c        ****             break;
 224:main.c        ****         case 0b100 :
 225:main.c        ****             Ndiv2 = 64;
 441               	.LM43:
 442 0178 80E4      		ldi r24,lo8(64)
 443 017a 90E0      		ldi r25,hi8(64)
 444 017c 00C0      		rjmp .L39
 445               	.L34:
 226:main.c        ****             break;
 227:main.c        ****         case 0b101 :
 228:main.c        ****             Ndiv2 = 128;
 447               	.LM44:
 448 017e 80E8      		ldi r24,lo8(128)
 449 0180 90E0      		ldi r25,hi8(128)
 450 0182 00C0      		rjmp .L39
 451               	.L35:
 229:main.c        ****             break;
 230:main.c        ****         case 0b110 :
 231:main.c        ****             Ndiv2 = 256;
 453               	.LM45:
 454 0184 80E0      		ldi r24,lo8(256)
 455 0186 91E0      		ldi r25,hi8(256)
 456 0188 00C0      		rjmp .L39
 457               	.L40:
 232:main.c        ****             break;
 233:main.c        ****         case 0b111 :
 234:main.c        ****             Ndiv2 = 1024;
 459               	.LM46:
 460 018a 80E0      		ldi r24,lo8(1024)
 461 018c 94E0      		ldi r25,hi8(1024)
 462 018e 00C0      		rjmp .L39
 463               	.L29:
 235:main.c        ****             break;
 236:main.c        ****         default :
 237:main.c        ****             Ndiv2 = 1;
 465               	.LM47:
 466 0190 81E0      		ldi r24,lo8(1)
 467 0192 90E0      		ldi r25,hi8(1)
 468               	.L39:
 469 0194 9093 0000 		sts Ndiv2+1,r25
 470 0198 8093 0000 		sts Ndiv2,r24
 471 019c 0895      		ret
 473               	.Lscope5:
 475               	.global	__vector_18
 477               	__vector_18:
 238:main.c        ****             break;
 239:main.c        ****     }
 240:main.c        ****     
 241:main.c        **** }
 242:main.c        **** 
 243:main.c        **** ISR(USART_RX_vect){
 479               	.LM48:
 480               	.LFBB6:
 481 019e 1F92      		push r1
 482 01a0 0F92      		push r0
 483 01a2 0FB6      		in r0,__SREG__
 484 01a4 0F92      		push r0
 485 01a6 1124      		clr __zero_reg__
 486 01a8 2F93      		push r18
 487 01aa 3F93      		push r19
 488 01ac 4F93      		push r20
 489 01ae 5F93      		push r21
 490 01b0 6F93      		push r22
 491 01b2 7F93      		push r23
 492 01b4 8F93      		push r24
 493 01b6 9F93      		push r25
 494 01b8 AF93      		push r26
 495 01ba BF93      		push r27
 496 01bc EF93      		push r30
 497 01be FF93      		push r31
 498               	/* prologue: Signal */
 499               	/* frame size = 0 */
 500               	/* stack size = 15 */
 501               	.L__stack_usage = 15
 244:main.c        ****     uint8_t    usart_data;
 245:main.c        ****     uint8_t    index;
 246:main.c        ****     
 247:main.c        ****     usart_data = USART_receive(); // Synchronize & Detect receiver ID
 503               	.LM49:
 504 01c0 0E94 0000 		call USART_receive
 248:main.c        ****     
 249:main.c        ****     if( (usart_data & 0xf0) == 0x00){ // received data is ID ?
 506               	.LM50:
 507 01c4 982F      		mov r25,r24
 508 01c6 907F      		andi r25,lo8(-16)
 509 01c8 01F4      		brne .L42
 250:main.c        ****         // Is it display target ID ?
 251:main.c        ****         for(index=0;index<Ndata;index++){
 252:main.c        ****             if ( usart_data == RxID[t_id[index]] ){
 511               	.LM51:
 512 01ca E091 0000 		lds r30,t_id
 513 01ce F0E0      		ldi r31,lo8(0)
 514 01d0 E050      		subi r30,lo8(-(RxID))
 515 01d2 F040      		sbci r31,hi8(-(RxID))
 516 01d4 9081      		ld r25,Z
 517 01d6 8917      		cp r24,r25
 518 01d8 01F0      		breq .L46
 520               	.LM52:
 521 01da E091 0000 		lds r30,t_id+1
 522 01de F0E0      		ldi r31,lo8(0)
 523 01e0 E050      		subi r30,lo8(-(RxID))
 524 01e2 F040      		sbci r31,hi8(-(RxID))
 525 01e4 9081      		ld r25,Z
 526 01e6 8917      		cp r24,r25
 527 01e8 01F4      		brne .L41
 251:main.c        ****         for(index=0;index<Ndata;index++){
 529               	.LM53:
 530 01ea 81E0      		ldi r24,lo8(1)
 531 01ec 00C0      		rjmp .L43
 532               	.L46:
 534               	.LM54:
 535 01ee 80E0      		ldi r24,lo8(0)
 536               	.L43:
 253:main.c        ****                 USART_index = index;
 538               	.LM55:
 539 01f0 8093 0000 		sts USART_index,r24
 254:main.c        ****                 USART_data_index = 0;
 541               	.LM56:
 542 01f4 1092 0000 		sts USART_data_index,__zero_reg__
 255:main.c        ****                 break;
 544               	.LM57:
 545 01f8 00C0      		rjmp .L41
 546               	.L42:
 256:main.c        ****             }
 257:main.c        ****         }
 258:main.c        ****         
 259:main.c        ****     }else if( USART_data_index < 4 ){ // capture meter data
 548               	.LM58:
 549 01fa 9091 0000 		lds r25,USART_data_index
 550 01fe 9430      		cpi r25,lo8(4)
 551 0200 00F4      		brsh .L41
 260:main.c        ****         data[USART_index][USART_data_index] = usart_data;
 553               	.LM59:
 554 0202 2091 0000 		lds r18,USART_index
 555 0206 30E0      		ldi r19,lo8(0)
 556 0208 F901      		movw r30,r18
 557 020a EE0F      		lsl r30
 558 020c FF1F      		rol r31
 559 020e EE0F      		lsl r30
 560 0210 FF1F      		rol r31
 561 0212 E90F      		add r30,r25
 562 0214 F11D      		adc r31,__zero_reg__
 563 0216 E050      		subi r30,lo8(-(data))
 564 0218 F040      		sbci r31,hi8(-(data))
 565 021a 8083      		st Z,r24
 261:main.c        ****         if( USART_data_index == 3 ){
 567               	.LM60:
 568 021c 9330      		cpi r25,lo8(3)
 569 021e 01F4      		brne .L45
 262:main.c        ****             data_updated[USART_index] = 1;
 571               	.LM61:
 572 0220 2050      		subi r18,lo8(-(data_updated))
 573 0222 3040      		sbci r19,hi8(-(data_updated))
 574 0224 81E0      		ldi r24,lo8(1)
 575 0226 F901      		movw r30,r18
 576 0228 8083      		st Z,r24
 263:main.c        ****             USART_data_index = 0xff;
 578               	.LM62:
 579 022a 8FEF      		ldi r24,lo8(-1)
 580 022c 8093 0000 		sts USART_data_index,r24
 581 0230 00C0      		rjmp .L41
 582               	.L45:
 264:main.c        ****         }else{
 265:main.c        ****             USART_data_index++;
 584               	.LM63:
 585 0232 9F5F      		subi r25,lo8(-(1))
 586 0234 9093 0000 		sts USART_data_index,r25
 587               	.L41:
 588               	/* epilogue start */
 266:main.c        ****         }
 267:main.c        ****         
 268:main.c        ****     }
 269:main.c        ****     
 270:main.c        **** }
 590               	.LM64:
 591 0238 FF91      		pop r31
 592 023a EF91      		pop r30
 593 023c BF91      		pop r27
 594 023e AF91      		pop r26
 595 0240 9F91      		pop r25
 596 0242 8F91      		pop r24
 597 0244 7F91      		pop r23
 598 0246 6F91      		pop r22
 599 0248 5F91      		pop r21
 600 024a 4F91      		pop r20
 601 024c 3F91      		pop r19
 602 024e 2F91      		pop r18
 603 0250 0F90      		pop r0
 604 0252 0FBE      		out __SREG__,r0
 605 0254 0F90      		pop r0
 606 0256 1F90      		pop r1
 607 0258 1895      		reti
 613               	.Lscope6:
 615               	.global	__vector_9
 617               	__vector_9:
 271:main.c        **** 
 272:main.c        **** 
 273:main.c        **** // 8-bit Timer2 overflow
 274:main.c        **** ISR(TIMER2_OVF_vect){
 619               	.LM65:
 620               	.LFBB7:
 621 025a 1F92      		push r1
 622 025c 0F92      		push r0
 623 025e 0FB6      		in r0,__SREG__
 624 0260 0F92      		push r0
 625 0262 1124      		clr __zero_reg__
 626 0264 2F93      		push r18
 627 0266 3F93      		push r19
 628 0268 4F93      		push r20
 629 026a 5F93      		push r21
 630 026c 6F93      		push r22
 631 026e 7F93      		push r23
 632 0270 8F93      		push r24
 633 0272 9F93      		push r25
 634 0274 AF93      		push r26
 635 0276 BF93      		push r27
 636 0278 EF93      		push r30
 637 027a FF93      		push r31
 638               	/* prologue: Signal */
 639               	/* frame size = 0 */
 640               	/* stack size = 15 */
 641               	.L__stack_usage = 15
 275:main.c        ****     // increment counter for display update
 276:main.c        ****     timer2_cnt++;
 643               	.LM66:
 644 027c 8091 0000 		lds r24,timer2_cnt
 645 0280 9091 0000 		lds r25,timer2_cnt+1
 646 0284 0196      		adiw r24,1
 647 0286 9093 0000 		sts timer2_cnt+1,r25
 648 028a 8093 0000 		sts timer2_cnt,r24
 277:main.c        ****     
 278:main.c        ****     // ADC
 279:main.c        ****     ADCSRA |= _BV(ADSC);
 650               	.LM67:
 651 028e EAE7      		ldi r30,lo8(122)
 652 0290 F0E0      		ldi r31,hi8(122)
 653 0292 8081      		ld r24,Z
 654 0294 8064      		ori r24,lo8(64)
 655 0296 8083      		st Z,r24
 280:main.c        ****     
 281:main.c        ****     // LED array : display
 282:main.c        ****     LEDarray((unsigned int)rpm);
 657               	.LM68:
 658 0298 8091 0000 		lds r24,rpm
 659 029c 9091 0000 		lds r25,rpm+1
 660 02a0 0E94 0000 		call LEDarray
 661               	/* epilogue start */
 283:main.c        **** }
 663               	.LM69:
 664 02a4 FF91      		pop r31
 665 02a6 EF91      		pop r30
 666 02a8 BF91      		pop r27
 667 02aa AF91      		pop r26
 668 02ac 9F91      		pop r25
 669 02ae 8F91      		pop r24
 670 02b0 7F91      		pop r23
 671 02b2 6F91      		pop r22
 672 02b4 5F91      		pop r21
 673 02b6 4F91      		pop r20
 674 02b8 3F91      		pop r19
 675 02ba 2F91      		pop r18
 676 02bc 0F90      		pop r0
 677 02be 0FBE      		out __SREG__,r0
 678 02c0 0F90      		pop r0
 679 02c2 1F90      		pop r1
 680 02c4 1895      		reti
 682               	.Lscope7:
 684               	.global	__vector_7
 686               	__vector_7:
 284:main.c        **** 
 285:main.c        **** // 8-bit Timer2 overflow
 286:main.c        **** ISR(TIMER2_COMPA_vect){
 688               	.LM70:
 689               	.LFBB8:
 690 02c6 1F92      		push r1
 691 02c8 0F92      		push r0
 692 02ca 0FB6      		in r0,__SREG__
 693 02cc 0F92      		push r0
 694 02ce 1124      		clr __zero_reg__
 695 02d0 2F93      		push r18
 696 02d2 3F93      		push r19
 697 02d4 4F93      		push r20
 698 02d6 5F93      		push r21
 699 02d8 6F93      		push r22
 700 02da 7F93      		push r23
 701 02dc 8F93      		push r24
 702 02de 9F93      		push r25
 703 02e0 AF93      		push r26
 704 02e2 BF93      		push r27
 705 02e4 EF93      		push r30
 706 02e6 FF93      		push r31
 707               	/* prologue: Signal */
 708               	/* frame size = 0 */
 709               	/* stack size = 15 */
 710               	.L__stack_usage = 15
 287:main.c        ****     // LED array : off
 288:main.c        ****     send_bits_595_LED(0x00);
 712               	.LM71:
 713 02e8 80E0      		ldi r24,lo8(0)
 714 02ea 0E94 0000 		call send_bits_595_LED
 715               	/* epilogue start */
 289:main.c        **** }
 717               	.LM72:
 718 02ee FF91      		pop r31
 719 02f0 EF91      		pop r30
 720 02f2 BF91      		pop r27
 721 02f4 AF91      		pop r26
 722 02f6 9F91      		pop r25
 723 02f8 8F91      		pop r24
 724 02fa 7F91      		pop r23
 725 02fc 6F91      		pop r22
 726 02fe 5F91      		pop r21
 727 0300 4F91      		pop r20
 728 0302 3F91      		pop r19
 729 0304 2F91      		pop r18
 730 0306 0F90      		pop r0
 731 0308 0FBE      		out __SREG__,r0
 732 030a 0F90      		pop r0
 733 030c 1F90      		pop r1
 734 030e 1895      		reti
 736               	.Lscope8:
 738               	.global	StrLength
 740               	StrLength:
 290:main.c        **** 
 291:main.c        **** // Count character length
 292:main.c        **** int StrLength(const char *s){
 742               	.LM73:
 743               	.LFBB9:
 744               	/* prologue: function */
 745               	/* frame size = 0 */
 746               	/* stack size = 0 */
 747               	.L__stack_usage = 0
 293:main.c        ****     uint8_t n = 0;
 294:main.c        ****     while (*s++ != '\0')
 749               	.LM74:
 750 0310 FC01      		movw r30,r24
 751               	.L50:
 292:main.c        **** int StrLength(const char *s){
 753               	.LM75:
 754 0312 9E2F      		mov r25,r30
 755 0314 981B      		sub r25,r24
 757               	.LM76:
 758 0316 2191      		ld r18,Z+
 759 0318 2223      		tst r18
 760 031a 01F4      		brne .L50
 295:main.c        ****         n++;
 296:main.c        ****     return (n);
 297:main.c        **** }
 762               	.LM77:
 763 031c 892F      		mov r24,r25
 764 031e 90E0      		ldi r25,lo8(0)
 765               	/* epilogue start */
 766 0320 0895      		ret
 771               	.Lscope9:
 773               	.global	__vector_2
 775               	__vector_2:
 298:main.c        **** 
 299:main.c        **** // FP Maximum Drive Mode
 300:main.c        **** uint8_t         FP_maxmode = 0;         // Fuel Pump Maximum Drive Mode Flag
 301:main.c        **** ISR(INT1_vect){
 777               	.LM78:
 778               	.LFBB10:
 779 0322 1F92      		push r1
 780 0324 0F92      		push r0
 781 0326 0FB6      		in r0,__SREG__
 782 0328 0F92      		push r0
 783 032a 1124      		clr __zero_reg__
 784 032c 8F93      		push r24
 785 032e 9F93      		push r25
 786 0330 AF93      		push r26
 787 0332 BF93      		push r27
 788               	/* prologue: Signal */
 789               	/* frame size = 0 */
 790               	/* stack size = 7 */
 791               	.L__stack_usage = 7
 302:main.c        ****     if( FP_maxmode == 0){
 793               	.LM79:
 794 0334 8091 0000 		lds r24,FP_maxmode
 795 0338 8823      		tst r24
 796 033a 01F4      		brne .L53
 303:main.c        ****         FP_maxmode = 1;
 798               	.LM80:
 799 033c 81E0      		ldi r24,lo8(1)
 800 033e 8093 0000 		sts FP_maxmode,r24
 801 0342 00C0      		rjmp .L54
 802               	.L53:
 304:main.c        ****     }else{
 305:main.c        ****         FP_maxmode = 0;
 804               	.LM81:
 805 0344 1092 0000 		sts FP_maxmode,__zero_reg__
 806               	.L54:
 807               	.LBB23:
 808               	.LBB24:
 810               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 812               	.LM82:
 813 0348 8FEF      		 ldi r24,lo8(159999)
 814 034a 90E7      	    ldi r25,hi8(159999)
 815 034c A2E0      	    ldi r26,hlo8(159999)
 816 034e 8150      	    1:subi r24,1
 817 0350 9040      	    sbci r25,0
 818 0352 A040      	    sbci r26,0
 819 0354 01F4      	    brne 1b
 820 0356 00C0      		rjmp .
 821 0358 0000      		nop
 822               	/* epilogue start */
 823               	.LBE24:
 824               	.LBE23:
 826               	.Ltext2:
 306:main.c        ****     }
 307:main.c        ****     _delay_ms(50);
 308:main.c        **** }
 828               	.LM83:
 829 035a BF91      		pop r27
 830 035c AF91      		pop r26
 831 035e 9F91      		pop r25
 832 0360 8F91      		pop r24
 833 0362 0F90      		pop r0
 834 0364 0FBE      		out __SREG__,r0
 835 0366 0F90      		pop r0
 836 0368 1F90      		pop r1
 837 036a 1895      		reti
 839               	.Lscope10:
 841               	.global	DisplayItemInfo
 843               	DisplayItemInfo:
 309:main.c        **** // Display
 310:main.c        **** void DisplayItemInfo(void){
 845               	.LM84:
 846               	.LFBB11:
 847 036c CF93      		push r28
 848 036e DF93      		push r29
 849 0370 CDB7      		in r28,__SP_L__
 850 0372 DEB7      		in r29,__SP_H__
 851 0374 A097      		sbiw r28,32
 852 0376 0FB6      		in __tmp_reg__,__SREG__
 853 0378 F894      		cli
 854 037a DEBF      		out __SP_H__,r29
 855 037c 0FBE      		out __SREG__,__tmp_reg__
 856 037e CDBF      		out __SP_L__,r28
 857               	/* prologue: function */
 858               	/* frame size = 32 */
 859               	/* stack size = 34 */
 860               	.L__stack_usage = 34
 311:main.c        ****     int k=0;
 312:main.c        ****     char char_buffer[32];
 313:main.c        ****     for(k=0;k<Ndata;k++){
 314:main.c        ****         lcd_locate(k,0);
 862               	.LM85:
 863 0380 80E0      		ldi r24,lo8(0)
 864 0382 60E0      		ldi r22,lo8(0)
 865 0384 0E94 0000 		call lcd_locate
 866               	.LBB25:
 315:main.c        ****         strcpy_P( char_buffer, (char *)pgm_read_byte(&(RxName[t_id[k]])) );
 868               	.LM86:
 869 0388 E091 0000 		lds r30,t_id
 870 038c F0E0      		ldi r31,lo8(0)
 871 038e EE0F      		lsl r30
 872 0390 FF1F      		rol r31
 873 0392 E050      		subi r30,lo8(-(RxName))
 874 0394 F040      		sbci r31,hi8(-(RxName))
 875               	/* #APP */
 876               	 ;  315 "main.c" 1
 877 0396 6491      		lpm r22, Z
 878               		
 879               	 ;  0 "" 2
 880               	/* #NOAPP */
 881               	.LBE25:
 882 0398 CE01      		movw r24,r28
 883 039a 0196      		adiw r24,1
 884 039c 70E0      		ldi r23,lo8(0)
 885 039e 0E94 0000 		call strcpy_P
 316:main.c        ****         lcd_set_str((char *)char_buffer);    }
 887               	.LM87:
 888 03a2 CE01      		movw r24,r28
 889 03a4 0196      		adiw r24,1
 890 03a6 0E94 0000 		call lcd_set_str
 314:main.c        ****         lcd_locate(k,0);
 892               	.LM88:
 893 03aa 81E0      		ldi r24,lo8(1)
 894 03ac 60E0      		ldi r22,lo8(0)
 895 03ae 0E94 0000 		call lcd_locate
 896               	.LBB26:
 315:main.c        ****         strcpy_P( char_buffer, (char *)pgm_read_byte(&(RxName[t_id[k]])) );
 898               	.LM89:
 899 03b2 E091 0000 		lds r30,t_id+1
 900 03b6 F0E0      		ldi r31,lo8(0)
 901 03b8 EE0F      		lsl r30
 902 03ba FF1F      		rol r31
 903 03bc E050      		subi r30,lo8(-(RxName))
 904 03be F040      		sbci r31,hi8(-(RxName))
 905               	/* #APP */
 906               	 ;  315 "main.c" 1
 907 03c0 6491      		lpm r22, Z
 908               		
 909               	 ;  0 "" 2
 910               	/* #NOAPP */
 911               	.LBE26:
 912 03c2 CE01      		movw r24,r28
 913 03c4 0196      		adiw r24,1
 914 03c6 70E0      		ldi r23,lo8(0)
 915 03c8 0E94 0000 		call strcpy_P
 917               	.LM90:
 918 03cc CE01      		movw r24,r28
 919 03ce 0196      		adiw r24,1
 920 03d0 0E94 0000 		call lcd_set_str
 921               	/* epilogue start */
 317:main.c        ****     
 318:main.c        **** }
 923               	.LM91:
 924 03d4 A096      		adiw r28,32
 925 03d6 0FB6      		in __tmp_reg__,__SREG__
 926 03d8 F894      		cli
 927 03da DEBF      		out __SP_H__,r29
 928 03dc 0FBE      		out __SREG__,__tmp_reg__
 929 03de CDBF      		out __SP_L__,r28
 930 03e0 DF91      		pop r29
 931 03e2 CF91      		pop r28
 932 03e4 0895      		ret
 937               	.Lscope11:
 938               		.data
 939               	.LC1:
 940 000d 4650 2000 		.string	"FP "
 941               	.LC2:
 942 0011 5600      		.string	"V"
 943               	.LC3:
 944 0013 7270 6D00 		.string	"rpm"
 945               	.LC4:
 946 0017 4455 5459 		.string	"DUTY"
 946      00
 947               	.LC5:
 948 001c 2500      		.string	"%"
 949               	.LC6:
 950 001e 3D46 5020 		.string	"=FP MAX="
 950      4D41 583D 
 950      00
 951               	.LC7:
 952 0027 2C20 2020 		.string	",   "
 952      00
 953               	.LC8:
 954 002c 6B67 2F63 		.string	"kg/cm2,   "
 954      6D32 2C20 
 954      2020 00
 955               	.LC9:
 956 0037 252C 2020 		.string	"%,   "
 956      2000 
 957               	.LC10:
 958 003d 562C 2020 		.string	"V,   "
 958      2000 
 959               	.LC11:
 960 0043 6B67 2F63 		.string	"kg/cm2\n"
 960      6D32 0A00 
 961               		.section	.text.startup,"ax",@progbits
 963               	.global	main
 965               	main:
 319:main.c        **** 
 320:main.c        **** int main(void)
 321:main.c        **** {
 967               	.LM92:
 968               	.LFBB12:
 969 0000 CF93      		push r28
 970 0002 DF93      		push r29
 971 0004 CDB7      		in r28,__SP_L__
 972 0006 DEB7      		in r29,__SP_H__
 973 0008 CA54      		subi r28,lo8(-(-74))
 974 000a D040      		sbci r29,hi8(-(-74))
 975 000c 0FB6      		in __tmp_reg__,__SREG__
 976 000e F894      		cli
 977 0010 DEBF      		out __SP_H__,r29
 978 0012 0FBE      		out __SREG__,__tmp_reg__
 979 0014 CDBF      		out __SP_L__,r28
 980               	/* prologue: function */
 981               	/* frame size = 74 */
 982               	/* stack size = 76 */
 983               	.L__stack_usage = 76
 322:main.c        ****     
 323:main.c        ****     // for 74HC595 port setting for LCD
 324:main.c        ****     SoftSPI_Init();
 985               	.LM93:
 986 0016 0E94 0000 		call SoftSPI_Init
 325:main.c        ****     
 326:main.c        ****     // for 74HC595 port setting for LED array
 327:main.c        ****     SoftSPI_LED_Init();
 988               	.LM94:
 989 001a 0E94 0000 		call SoftSPI_LED_Init
 328:main.c        ****     
 329:main.c        ****     // Initialize LCD
 330:main.c        **** 	lcd_init();
 991               	.LM95:
 992 001e 0E94 0000 		call lcd_init
 331:main.c        **** 	
 332:main.c        ****     // Timer for PWM driver initialize
 333:main.c        ****     timer0_init();
 994               	.LM96:
 995 0022 0E94 0000 		call timer0_init
 334:main.c        ****     
 335:main.c        ****     // TachoMeter counter initialize
 336:main.c        ****     timer1_init();
 997               	.LM97:
 998 0026 0E94 0000 		call timer1_init
 337:main.c        **** 
 338:main.c        ****     // delay counter initialize
 339:main.c        ****     timer2_init();
 1000               	.LM98:
 1001 002a 0E94 0000 		call timer2_init
 340:main.c        ****     
 341:main.c        ****     // PWM output port definition
 342:main.c        ****     DDRD |= (1<<PD5); // PD5 (OCR0B enable)
 1003               	.LM99:
 1004 002e 559A      		sbi 42-32,5
 343:main.c        ****     
 344:main.c        **** 	// USART initialize
 345:main.c        **** 	USARTinit(UBRR);
 1006               	.LM100:
 1007 0030 83E3      		ldi r24,lo8(51)
 1008 0032 90E0      		ldi r25,hi8(51)
 1009 0034 0E94 0000 		call USARTinit
 346:main.c        **** 	
 347:main.c        ****     // ADC initialize
 348:main.c        ****     ADC_init();
 1011               	.LM101:
 1012 0038 0E94 0000 		call ADC_init
 349:main.c        ****     
 350:main.c        ****     // Ext. Interupt setting
 351:main.c        **** 	ExtInterrupt_init();
 1014               	.LM102:
 1015 003c 0E94 0000 		call ExtInterrupt_init
 352:main.c        ****     
 353:main.c        ****     // TicToc initialize
 354:main.c        ****     //debug
 355:main.c        **** //    tictoc_init(FOSC, Ndiv1);
 356:main.c        ****     
 357:main.c        ****     // Tacho Meter Initialize
 358:main.c        ****     TachoMeter_init(FOSC,Ndiv1);
 1017               	.LM103:
 1018 0040 2091 0000 		lds r18,Ndiv1
 1019 0044 3091 0000 		lds r19,Ndiv1+1
 1020 0048 40E0      		ldi r20,lo8(0)
 1021 004a 50E0      		ldi r21,hi8(0)
 1022 004c 60E0      		ldi r22,lo8(16000000)
 1023 004e 74E2      		ldi r23,hi8(16000000)
 1024 0050 84EF      		ldi r24,hlo8(16000000)
 1025 0052 90E0      		ldi r25,hhi8(16000000)
 1026 0054 0E94 0000 		call TachoMeter_init
 359:main.c        ****     
 360:main.c        ****     // LED array init
 361:main.c        **** //    LEDarray_init();
 362:main.c        ****     // debug
 363:main.c        **** //    lcd_locate(0,0);
 364:main.c        **** //    lcd_set_numeric(LEDarray_init(),4,0,0);
 365:main.c        **** //    _delay_ms(500);
 366:main.c        ****     
 367:main.c        ****     // Bar-Meter Initialize
 368:main.c        ****     BarMeter_init();
 1028               	.LM104:
 1029 0058 0E94 0000 		call BarMeter_init
 369:main.c        ****     
 370:main.c        ****     // Facemark character Initialize
 371:main.c        **** //    FaceMark_init();
 372:main.c        ****     
 373:main.c        ****     // Set Initial Target IDs
 374:main.c        ****     set_initial_t_id();
 1031               	.LM105:
 1032 005c 0E94 0000 		call set_initial_t_id
 1033 0060 B0E0      		ldi r27,lo8(Nsig.1755)
 1034 0062 AB2E      		mov r10,r27
 1035 0064 B0E0      		ldi r27,hi8(Nsig.1755)
 1036 0066 BB2E      		mov r11,r27
 1037 0068 10E0      		ldi r17,lo8(Nint.1756)
 1038 006a 612E      		mov r6,r17
 1039 006c 10E0      		ldi r17,hi8(Nint.1756)
 1040 006e 712E      		mov r7,r17
 1041 0070 00E0      		ldi r16,lo8(0)
 1042 0072 10E0      		ldi r17,hi8(0)
 375:main.c        ****     
 376:main.c        **** 	// Declarations
 377:main.c        ****    
 378:main.c        **** 	uint8_t         n, m;					// 'for' loop variables
 379:main.c        ****     
 380:main.c        **** 	uint8_t         index = 0;				// LCD displaying data index
 381:main.c        **** 	
 382:main.c        ****     char            char_buffer[32];        // Buffer for PROGMEM character variables
 383:main.c        ****     
 384:main.c        **** 	uint16_t		maxv = 2352;			// maximum decimal angle data value from 'Defi Link Unit II'
 385:main.c        ****     
 386:main.c        **** 	uint8_t         id;						// ID index for processing
 387:main.c        ****     
 388:main.c        ****     uint8_t         valid_packet[Ndata];	// Validtity indicator
 389:main.c        ****     uint16_t        monitor_cnt[Ndata];     // count value for update monitor
 390:main.c        **** 	
 391:main.c        **** 	uint8_t			low4bits[4];			// Extracted lower 4 bits from byte data
 392:main.c        **** 	uint16_t        dec_ang;				// Angle data (decimal)
 393:main.c        **** 	float        dec_nrm;				// Angle data (decimal)
 394:main.c        ****     float		value[Ndata];           // Decoded value
 395:main.c        ****     uint16_t        mult_factor[3];         // Multiplying factor for hexadecimal to decimal decodi
 396:main.c        ****     
 397:main.c        ****     uint16_t        ADCH_array[7];          // Array for averaging ADC output
 398:main.c        ****     uint16_t        ADCH_sum;               // for sum of ADC output
 399:main.c        ****     float           FP_Volt;                // Fuel Pump Voltage
 400:main.c        ****     
 401:main.c        ****     // value = eq_grad * dec_ang/maxv + eq_intercept
 402:main.c        ****     // Gradient-term of decoding equation
 403:main.c        **** 	static const uint16_t eq_grad[] PROGMEM = {
 404:main.c        ****         3,	// Turbo
 405:main.c        ****         9000,	// Tacho
 406:main.c        ****         10,	// Oil pres.
 407:main.c        ****         6,	// Fuel pres.
 408:main.c        ****         900,	// Ext. Temp.
 409:main.c        ****         100,	// Oil Temp.
 410:main.c        ****         100	// Water Temp.
 411:main.c        ****     };
 412:main.c        ****     
 413:main.c        ****     // Intercept-term of decoding equation
 414:main.c        ****     static const int16_t eq_intercept[] PROGMEM = {
 415:main.c        ****         -1,	// Turbo
 416:main.c        ****         0,	// Tacho
 417:main.c        ****         0,	// Oil pres.
 418:main.c        ****         0,	// Fuel pres.
 419:main.c        ****         200,	// Ext. Temp.
 420:main.c        ****         50,	// Oil Temp.
 421:main.c        ****         20	// Water Temp.
 422:main.c        ****     };
 423:main.c        ****     
 424:main.c        ****     // Definition of number of significant figure
 425:main.c        **** 	static const uint8_t   Nsig[] = {				// Number of significant figures
 426:main.c        ****         3,	// Turbo
 427:main.c        ****         4,	// Tacho
 428:main.c        ****         3,	// Oil pres.
 429:main.c        ****         3,	// Fuel pres.
 430:main.c        ****         4,	// Ext. Temp.
 431:main.c        ****         3,	// Oil Temp.
 432:main.c        ****         3	// Water Temp.
 433:main.c        ****     };
 434:main.c        ****     
 435:main.c        ****     // Deifinition of number of integer figure
 436:main.c        **** 	static const uint8_t	Nint[] = {				// Number of integr digits
 437:main.c        ****         1,	// Turbo
 438:main.c        ****         4,	// Tacho
 439:main.c        ****         2,	// Oil pres.
 440:main.c        ****         1,	// Fuel pres.
 441:main.c        ****         4,	// Ext. Temp.
 442:main.c        ****         3,	// Oil Temp.
 443:main.c        ****         3	// Water Temp.
 444:main.c        ****     };
 445:main.c        ****     
 446:main.c        ****     static const uint8_t	SIGN[] = {				// Show +/-, enable showing is '1'
 447:main.c        ****         1,	// Turbo
 448:main.c        ****         0,	// Tacho
 449:main.c        ****         0,	// Oil pres.
 450:main.c        ****         0,	// Fuel pres.
 451:main.c        ****         0,	// Ext. Temp.
 452:main.c        ****         0,	// Oil Temp.
 453:main.c        ****         0	// Water Temp.
 454:main.c        ****     };
 455:main.c        ****     
 456:main.c        ****     uint16_t	SCALE[7];               // Scaling factor for integer processing
 457:main.c        **** 	uint8_t     Nspace[7];				// Number of space between character and digits
 458:main.c        ****     
 459:main.c        ****     // Definition of Resolution for processing and number of space for display
 460:main.c        ****     for(n=0;n<7;n++){
 461:main.c        ****         SCALE[n] = 1;
 462:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 463:main.c        ****             SCALE[n] = SCALE[n] * 10;
 464:main.c        ****         }
 465:main.c        ****         strcpy_P( char_buffer, (char *)pgm_read_byte(&(RxName[n])) );
 466:main.c        ****         RxNameLength[n] = StrLength(char_buffer);
 467:main.c        ****         Nspace[n]       = DISP_W - RxNameLength[n] - ( Nsig[n] + (Nsig[n]!=Nint[n]) + SIGN[n] );
 1044               	.LM106:
 1045 0074 87E0      		ldi r24,lo8(7)
 1046 0076 882E      		mov r8,r24
 1047 0078 00C0      		rjmp .L57
 1048               	.L58:
 462:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1050               	.LM107:
 1051 007a 4F5F      		subi r20,lo8(-(1))
 1052               	.L61:
 462:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1054               	.LM108:
 1055 007c 242F      		mov r18,r20
 1056 007e 30E0      		ldi r19,lo8(0)
 1057 0080 2817      		cp r18,r24
 1058 0082 3907      		cpc r19,r25
 1059 0084 04F0      		brlt .L58
 1060               	.LBB27:
 465:main.c        ****         strcpy_P( char_buffer, (char *)pgm_read_byte(&(RxName[n])) );
 1062               	.LM109:
 1063 0086 F801      		movw r30,r16
 1064 0088 EE0F      		lsl r30
 1065 008a FF1F      		rol r31
 1066 008c E050      		subi r30,lo8(-(RxName))
 1067 008e F040      		sbci r31,hi8(-(RxName))
 1068               	/* #APP */
 1069               	 ;  465 "main.c" 1
 1070 0090 6491      		lpm r22, Z
 1071               		
 1072               	 ;  0 "" 2
 1073               	/* #NOAPP */
 1074               	.LBE27:
 1075 0092 CE01      		movw r24,r28
 1076 0094 8096      		adiw r24,32
 1077 0096 70E0      		ldi r23,lo8(0)
 1078 0098 0E94 0000 		call strcpy_P
 466:main.c        ****         RxNameLength[n] = StrLength(char_buffer);
 1080               	.LM110:
 1081 009c CE01      		movw r24,r28
 1082 009e 8096      		adiw r24,32
 1083 00a0 0E94 0000 		call StrLength
 1084 00a4 F801      		movw r30,r16
 1085 00a6 E050      		subi r30,lo8(-(RxNameLength))
 1086 00a8 F040      		sbci r31,hi8(-(RxNameLength))
 1087 00aa 8083      		st Z,r24
 1089               	.LM111:
 1090 00ac A1E1      		ldi r26,lo8(17)
 1091 00ae B0E0      		ldi r27,hi8(17)
 1092 00b0 AC0F      		add r26,r28
 1093 00b2 BD1F      		adc r27,r29
 1094 00b4 A00F      		add r26,r16
 1095 00b6 B11F      		adc r27,r17
 1096 00b8 982D      		mov r25,r8
 1097 00ba 9E19      		sub r25,r14
 1098 00bc 981B      		sub r25,r24
 1099 00be F801      		movw r30,r16
 1100 00c0 E050      		subi r30,lo8(-(SIGN.1757))
 1101 00c2 F040      		sbci r31,hi8(-(SIGN.1757))
 1102 00c4 8081      		ld r24,Z
 1103 00c6 981B      		sub r25,r24
 1104 00c8 81E0      		ldi r24,lo8(1)
 1105 00ca EC14      		cp r14,r12
 1106 00cc 01F4      		brne .L59
 1107 00ce 80E0      		ldi r24,lo8(0)
 1108               	.L59:
 1109 00d0 981B      		sub r25,r24
 1110 00d2 9C93      		st X,r25
 1111 00d4 0F5F      		subi r16,lo8(-(1))
 1112 00d6 1F4F      		sbci r17,hi8(-(1))
 460:main.c        ****     for(n=0;n<7;n++){
 1114               	.LM112:
 1115 00d8 0730      		cpi r16,7
 1116 00da 1105      		cpc r17,__zero_reg__
 1117 00dc 01F0      		breq .L60
 1118               	.L57:
 462:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1120               	.LM113:
 1121 00de D501      		movw r26,r10
 1122 00e0 ED90      		ld r14,X+
 1123 00e2 5D01      		movw r10,r26
 1124 00e4 F301      		movw r30,r6
 1125 00e6 C190      		ld r12,Z+
 1126 00e8 3F01      		movw r6,r30
 1127 00ea 8E2D      		mov r24,r14
 1128 00ec 90E0      		ldi r25,lo8(0)
 1129 00ee 8C19      		sub r24,r12
 1130 00f0 9109      		sbc r25,__zero_reg__
 1131 00f2 40E0      		ldi r20,lo8(0)
 1132 00f4 00C0      		rjmp .L61
 1133               	.L60:
 468:main.c        ****     }
 469:main.c        ****     
 470:main.c        ****     
 471:main.c        **** 	mult_factor[0] = 1;
 1135               	.LM114:
 1136 00f6 81E0      		ldi r24,lo8(1)
 1137 00f8 90E0      		ldi r25,hi8(1)
 1138 00fa 9C87      		std Y+12,r25
 1139 00fc 8B87      		std Y+11,r24
 472:main.c        **** 	mult_factor[1] = 16;
 1141               	.LM115:
 1142 00fe 80E1      		ldi r24,lo8(16)
 1143 0100 90E0      		ldi r25,hi8(16)
 1144 0102 9E87      		std Y+14,r25
 1145 0104 8D87      		std Y+13,r24
 473:main.c        **** 	mult_factor[2] = 256;
 1147               	.LM116:
 1148 0106 80E0      		ldi r24,lo8(256)
 1149 0108 91E0      		ldi r25,hi8(256)
 1150 010a 988B      		std Y+16,r25
 1151 010c 8F87      		std Y+15,r24
 474:main.c        ****     
 475:main.c        **** 
 476:main.c        ****     disp_delay_cnt = (unsigned long int)( ( DISP_WAIT*1.0 ) * ( (1.0*FOSC)/(1.0*Ndiv2) ) / 256.0 / 
 1153               	.LM117:
 1154 010e 6091 0000 		lds r22,Ndiv2
 1155 0112 7091 0000 		lds r23,Ndiv2+1
 1156 0116 80E0      		ldi r24,lo8(0)
 1157 0118 90E0      		ldi r25,hi8(0)
 1158 011a 0E94 0000 		call __floatunsisf
 1159 011e 9B01      		movw r18,r22
 1160 0120 AC01      		movw r20,r24
 1161 0122 60E0      		ldi r22,lo8(0x4b742400)
 1162 0124 74E2      		ldi r23,hi8(0x4b742400)
 1163 0126 84E7      		ldi r24,hlo8(0x4b742400)
 1164 0128 9BE4      		ldi r25,hhi8(0x4b742400)
 1165 012a 0E94 0000 		call __divsf3
 1166 012e 20E0      		ldi r18,lo8(0x437a0000)
 1167 0130 30E0      		ldi r19,hi8(0x437a0000)
 1168 0132 4AE7      		ldi r20,hlo8(0x437a0000)
 1169 0134 53E4      		ldi r21,hhi8(0x437a0000)
 1170 0136 0E94 0000 		call __mulsf3
 1171 013a 20E0      		ldi r18,lo8(0x3b800000)
 1172 013c 30E0      		ldi r19,hi8(0x3b800000)
 1173 013e 40E8      		ldi r20,hlo8(0x3b800000)
 1174 0140 5BE3      		ldi r21,hhi8(0x3b800000)
 1175 0142 0E94 0000 		call __mulsf3
 1176 0146 20E0      		ldi r18,lo8(0x447a0000)
 1177 0148 30E0      		ldi r19,hi8(0x447a0000)
 1178 014a 4AE7      		ldi r20,hlo8(0x447a0000)
 1179 014c 54E4      		ldi r21,hhi8(0x447a0000)
 1180 014e 0E94 0000 		call __divsf3
 1181 0152 0E94 0000 		call __fixunssfsi
 1182 0156 DC01      		movw r26,r24
 1183 0158 CB01      		movw r24,r22
 1184 015a 9093 0000 		sts disp_delay_cnt+1,r25
 1185 015e 8093 0000 		sts disp_delay_cnt,r24
 477:main.c        ****     
 478:main.c        ****     for(n=0;n<7;n++){
 479:main.c        ****         ADCH_array[n] = 0;
 480:main.c        ****     }
 481:main.c        ****     
 482:main.c        ****     #if USB_COM
 483:main.c        ****         // USART messeage
 484:main.c        ****         strcpy_P(char_buffer,PSTR("\n\n"));
 1187               	.LM118:
 1188 0162 CE01      		movw r24,r28
 1189 0164 8096      		adiw r24,32
 1190 0166 60E0      		ldi r22,lo8(__c.1772)
 1191 0168 70E0      		ldi r23,hi8(__c.1772)
 1192 016a 0E94 0000 		call strcpy_P
 485:main.c        ****         USART_transmit_str(char_buffer);
 1194               	.LM119:
 1195 016e CE01      		movw r24,r28
 1196 0170 8096      		adiw r24,32
 1197 0172 0E94 0000 		call USART_transmit_str
 486:main.c        ****         strcpy_P(char_buffer,PSTR("Data Logger @ Mazda RX-7 FD3S\n\n\n"));
 1199               	.LM120:
 1200 0176 CE01      		movw r24,r28
 1201 0178 8096      		adiw r24,32
 1202 017a 60E0      		ldi r22,lo8(__c.1774)
 1203 017c 70E0      		ldi r23,hi8(__c.1774)
 1204 017e 0E94 0000 		call strcpy_P
 487:main.c        ****         USART_transmit_str(char_buffer);
 1206               	.LM121:
 1207 0182 CE01      		movw r24,r28
 1208 0184 8096      		adiw r24,32
 1209 0186 0E94 0000 		call USART_transmit_str
 1210 018a 00E0      		ldi r16,lo8(0)
 1211 018c 10E0      		ldi r17,hi8(0)
 488:main.c        ****     #endif
 489:main.c        ****         
 490:main.c        ****     // opening @ LED array
 491:main.c        ****     for(n=0;n<=8;n++){
 492:main.c        ****         send_bits_595_LED(0x01 << n);
 1213               	.LM122:
 1214 018e E1E0      		ldi r30,lo8(1)
 1215 0190 EE2E      		mov r14,r30
 1216 0192 F12C      		mov r15,__zero_reg__
 1217               	.L62:
 1219               	.LM123:
 1220 0194 C701      		movw r24,r14
 1221 0196 002E      		mov r0,r16
 1222 0198 00C0      		rjmp 2f
 1223 019a 880F      	1:	lsl r24
 1224 019c 991F      		rol r25
 1225 019e 0A94      	2:	dec r0
 1226 01a0 02F4      		brpl 1b
 1227 01a2 0E94 0000 		call send_bits_595_LED
 1228               	.LBB28:
 1229               	.LBB29:
 1231               	.Ltext3:
 1233               	.LM124:
 1234 01a6 2FEF      		 ldi r18,lo8(191999)
 1235 01a8 3DEE      	    ldi r19,hi8(191999)
 1236 01aa 42E0      	    ldi r20,hlo8(191999)
 1237 01ac 2150      	    1:subi r18,1
 1238 01ae 3040      	    sbci r19,0
 1239 01b0 4040      	    sbci r20,0
 1240 01b2 01F4      	    brne 1b
 1241 01b4 00C0      		rjmp .
 1242 01b6 0000      		nop
 1243 01b8 0F5F      		subi r16,lo8(-(1))
 1244 01ba 1F4F      		sbci r17,hi8(-(1))
 1245               	.LBE29:
 1246               	.LBE28:
 1248               	.Ltext4:
 491:main.c        ****     for(n=0;n<=8;n++){
 1250               	.LM125:
 1251 01bc 0930      		cpi r16,9
 1252 01be 1105      		cpc r17,__zero_reg__
 1253 01c0 01F4      		brne .L62
 1254               	.LBB30:
 1255               	.LBB31:
 1257               	.Ltext5:
 1259               	.LM126:
 1260 01c2 8FEF      		 ldi r24,lo8(159999)
 1261 01c4 90E7      	    ldi r25,hi8(159999)
 1262 01c6 A2E0      	    ldi r26,hlo8(159999)
 1263 01c8 8150      	    1:subi r24,1
 1264 01ca 9040      	    sbci r25,0
 1265 01cc A040      	    sbci r26,0
 1266 01ce 01F4      	    brne 1b
 1267 01d0 00C0      		rjmp .
 1268 01d2 0000      		nop
 1269 01d4 00E0      		ldi r16,lo8(0)
 1270 01d6 10E0      		ldi r17,hi8(0)
 1271               	.L64:
 1272               	.LBE31:
 1273               	.LBE30:
 1275               	.Ltext6:
 493:main.c        ****         _delay_ms(60);
 494:main.c        ****     }
 495:main.c        **** 
 496:main.c        ****     // opening @ LCD
 497:main.c        **** 	_delay_ms(50);
 498:main.c        ****     for(m=0;m<2;m++){
 499:main.c        ****         lcd_locate(m,0);
 1277               	.LM127:
 1278 01d8 802F      		mov r24,r16
 1279 01da 60E0      		ldi r22,lo8(0)
 1280 01dc 0E94 0000 		call lcd_locate
 1281               	.LBB32:
 500:main.c        ****         strcpy_P( char_buffer, (char *)pgm_read_byte(&(opening_message[m])) );
 1283               	.LM128:
 1284 01e0 F801      		movw r30,r16
 1285 01e2 EE0F      		lsl r30
 1286 01e4 FF1F      		rol r31
 1287 01e6 E050      		subi r30,lo8(-(opening_message))
 1288 01e8 F040      		sbci r31,hi8(-(opening_message))
 1289               	/* #APP */
 1290               	 ;  500 "main.c" 1
 1291 01ea 6491      		lpm r22, Z
 1292               		
 1293               	 ;  0 "" 2
 1294               	/* #NOAPP */
 1295               	.LBE32:
 1296 01ec CE01      		movw r24,r28
 1297 01ee 8096      		adiw r24,32
 1298 01f0 70E0      		ldi r23,lo8(0)
 1299 01f2 0E94 0000 		call strcpy_P
 1300 01f6 90E2      		ldi r25,lo8(32)
 1301 01f8 E92E      		mov r14,r25
 1302 01fa F12C      		mov r15,__zero_reg__
 1303 01fc EC0E      		add r14,r28
 1304 01fe FD1E      		adc r15,r29
 501:main.c        ****         for(n=0;n<LCD_W;n++){
 1306               	.LM129:
 1307 0200 90E0      		ldi r25,lo8(0)
 1308               	.L63:
 502:main.c        ****             lcd_set_char(char_buffer[n]);
 1310               	.LM130:
 1311 0202 D701      		movw r26,r14
 1312 0204 8D91      		ld r24,X+
 1313 0206 7D01      		movw r14,r26
 1314 0208 2B96      		adiw r28,74-63
 1315 020a 9FAF      		std Y+63,r25
 1316 020c 2B97      		sbiw r28,74-63
 1317 020e 0E94 0000 		call lcd_set_char
 1318               	.LBB33:
 1319               	.LBB34:
 1321               	.Ltext7:
 1323               	.LM131:
 1324 0212 2FEF      		 ldi r18,lo8(63999)
 1325 0214 39EF      	    ldi r19,hi8(63999)
 1326 0216 40E0      	    ldi r20,hlo8(63999)
 1327 0218 2150      	    1:subi r18,1
 1328 021a 3040      	    sbci r19,0
 1329 021c 4040      	    sbci r20,0
 1330 021e 01F4      	    brne 1b
 1331 0220 00C0      		rjmp .
 1332 0222 0000      		nop
 1333               	.LBE34:
 1334               	.LBE33:
 1336               	.Ltext8:
 501:main.c        ****         for(n=0;n<LCD_W;n++){
 1338               	.LM132:
 1339 0224 2B96      		adiw r28,74-63
 1340 0226 9FAD      		ldd r25,Y+63
 1341 0228 2B97      		sbiw r28,74-63
 1342 022a 9F5F      		subi r25,lo8(-(1))
 1343 022c 9031      		cpi r25,lo8(16)
 1344 022e 01F4      		brne .L63
 501:main.c        ****         for(n=0;n<LCD_W;n++){
 1346               	.LM133:
 1347 0230 0F5F      		subi r16,lo8(-(1))
 1348 0232 1F4F      		sbci r17,hi8(-(1))
 498:main.c        ****     for(m=0;m<2;m++){
 1350               	.LM134:
 1351 0234 0230      		cpi r16,2
 1352 0236 1105      		cpc r17,__zero_reg__
 1353 0238 01F4      		brne .L64
 1354               	.LBB35:
 1355               	.LBB36:
 1357               	.Ltext9:
 1359               	.LM135:
 1360 023a 8FEF      		 ldi r24,lo8(1599999)
 1361 023c 99E6      	    ldi r25,hi8(1599999)
 1362 023e A8E1      	    ldi r26,hlo8(1599999)
 1363 0240 8150      	    1:subi r24,1
 1364 0242 9040      	    sbci r25,0
 1365 0244 A040      	    sbci r26,0
 1366 0246 01F4      	    brne 1b
 1367 0248 00C0      		rjmp .
 1368 024a 0000      		nop
 1370               	.Ltext10:
 503:main.c        ****             _delay_ms(20);
 504:main.c        ****         }
 505:main.c        ****     }
 506:main.c        ****     _delay_ms(500);
 507:main.c        ****     
 508:main.c        **** /*
 509:main.c        ****     // opening @ LED array
 510:main.c        ****     for(n=0;n<=8;n++){
 511:main.c        ****         send_bits_595_LED(~( 0xff << n ));
 512:main.c        ****         _delay_ms(30);
 513:main.c        ****     }
 514:main.c        ****     _delay_ms(250);
 515:main.c        ****     for(n=0;n<=8;n++){
 516:main.c        ****         send_bits_595_LED( 0xff >> n );
 517:main.c        ****         _delay_ms(30);
 518:main.c        ****     }
 519:main.c        ****     _delay_ms(50);
 520:main.c        ****     for(n=0;n<2;n++){
 521:main.c        ****         send_bits_595_LED(0xff);
 522:main.c        ****         _delay_ms(75);
 523:main.c        ****         send_bits_595_LED(0x00);
 524:main.c        ****         _delay_ms(75);
 525:main.c        ****     }
 526:main.c        **** */
 527:main.c        ****     
 528:main.c        ****     // Clear Opening
 529:main.c        **** 	for(m=0;m<4;m++){
 1372               	.LM136:
 1373 024c 00E0      		ldi r16,lo8(0)
 1374               	.L66:
 1375               	.LBE36:
 1376               	.LBE35:
 530:main.c        **** 		lcd_locate(m,0);
 1378               	.LM137:
 1379 024e 802F      		mov r24,r16
 1380 0250 60E0      		ldi r22,lo8(0)
 1381 0252 0E94 0000 		call lcd_locate
 1382 0256 10E1      		ldi r17,lo8(16)
 1383               	.L65:
 531:main.c        **** 		for(n=0;n<LCD_W;n++){
 532:main.c        **** 			lcd_set_char(0x20);
 1385               	.LM138:
 1386 0258 80E2      		ldi r24,lo8(32)
 1387 025a 0E94 0000 		call lcd_set_char
 1388               	.LBB37:
 1389               	.LBB38:
 1391               	.Ltext11:
 1393               	.LM139:
 1394 025e AFE3      		 ldi r26,lo8(-25537)
 1395 0260 BCE9      	    ldi r27,hi8(-25537)
 1396 0262 1197      	    1:sbiw r26,1
 1397 0264 01F4      	    brne 1b
 1398 0266 00C0      		rjmp .
 1399 0268 0000      		nop
 1400 026a 1150      		subi r17,lo8(-(-1))
 1401               	.LBE38:
 1402               	.LBE37:
 1404               	.Ltext12:
 531:main.c        **** 		for(n=0;n<LCD_W;n++){
 1406               	.LM140:
 1407 026c 01F4      		brne .L65
 529:main.c        **** 	for(m=0;m<4;m++){
 1409               	.LM141:
 1410 026e 0F5F      		subi r16,lo8(-(1))
 1411 0270 0430      		cpi r16,lo8(4)
 1412 0272 01F4      		brne .L66
 533:main.c        **** 			_delay_ms(10);
 534:main.c        **** 		}
 535:main.c        **** 	}
 536:main.c        ****     
 537:main.c        ****     // Initialize data display for Defi Link Tap
 538:main.c        ****     for ( index = 0; index < Ndata; index++ ){
 539:main.c        ****         data_updated[index] = 1;
 1414               	.LM142:
 1415 0274 81E0      		ldi r24,lo8(1)
 1416 0276 8093 0000 		sts data_updated,r24
 540:main.c        ****         monitor_cnt[index] = 0;
 1418               	.LM143:
 1419 027a 1886      		std Y+8,__zero_reg__
 1420 027c 1F82      		std Y+7,__zero_reg__
 539:main.c        ****         data_updated[index] = 1;
 1422               	.LM144:
 1423 027e 8093 0000 		sts data_updated+1,r24
 1425               	.LM145:
 1426 0282 1A86      		std Y+10,__zero_reg__
 1427 0284 1986      		std Y+9,__zero_reg__
 541:main.c        ****     }
 542:main.c        ****     
 543:main.c        ****     // Enable Interrupt
 544:main.c        ****     sei();
 1429               	.LM146:
 1430               	/* #APP */
 1431               	 ;  544 "main.c" 1
 1432 0286 7894      		sei
 1433               	 ;  0 "" 2
 545:main.c        **** 
 546:main.c        ****     FP_maxmode = 0;
 1435               	.LM147:
 1436               	/* #NOAPP */
 1437 0288 1092 0000 		sts FP_maxmode,__zero_reg__
 1438               	.LBB39:
 547:main.c        ****     
 548:main.c        ****     ////// Main Process start //////
 549:main.c        **** 	while(1){
 550:main.c        ****         
 551:main.c        ****         if(lcd_update){
 552:main.c        ****             DisplayItemInfo();
 553:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 554:main.c        ****             lcd_update = 0;
 555:main.c        **** 		}
 556:main.c        **** 
 557:main.c        ****         
 558:main.c        ****         ////// Dummy Defi Link Unit - debug //////
 559:main.c        ****         #if 0 // set '0' to Ignore Compile
 560:main.c        ****         for ( index = 0; index < Ndata; index++ ){
 561:main.c        ****             data_updated[index] = 1;
 562:main.c        ****             for( n = 1; n < 4; n++ ){
 563:main.c        ****                 data[index][n] = '3';
 564:main.c        ****             }
 565:main.c        ****         }
 566:main.c        ****         #endif
 567:main.c        ****         ////// Dummy Defi Link Unit - debug //////
 568:main.c        **** 
 569:main.c        ****         
 570:main.c        ****         ////// Measure Process //////
 571:main.c        ****         
 572:main.c        ****         //// Defi Link Tap ////
 573:main.c        ****         for ( index = 0; index < Ndata; index++ ){
 574:main.c        ****             
 575:main.c        ****             if( data_updated[index] == 1 ){
 576:main.c        ****                 data_updated[index] = 0;
 577:main.c        ****                 monitor_cnt[index] = 0;
 578:main.c        ****                 
 579:main.c        ****                 // Rx data read
 580:main.c        ****                 id = t_id[index];
 581:main.c        ****                 
 582:main.c        ****                 // Judge data validity
 583:main.c        ****                 for( n = 1; n < 4; n++ ){
 584:main.c        ****                     if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 585:main.c        ****                          |( (data[index][n] >= 'A') & (data[index][n] <= 'F') ) ) ){
 586:main.c        ****                         valid_packet[index] = 1;
 587:main.c        ****                     }else{
 588:main.c        ****                         valid_packet[index] = 0;
 589:main.c        ****                         break;
 590:main.c        ****                     }
 591:main.c        ****                 }
 592:main.c        ****                 // end of judge
 593:main.c        ****                 
 594:main.c        ****                 if ( valid_packet[index] == 1 ) {
 1440               	.LM148:
 1441 028c FE01      		movw r30,r28
 1442 028e 3B96      		adiw r30,11
 1443 0290 2296      		adiw r28,64-62
 1444 0292 FFAF      		std Y+63,r31
 1445 0294 EEAF      		std Y+62,r30
 1446 0296 2297      		sbiw r28,64-62
 1447               	.L98:
 551:main.c        ****         if(lcd_update){
 1449               	.LM149:
 1450 0298 8091 0000 		lds r24,lcd_update
 1451 029c 8823      		tst r24
 1452 029e 01F0      		breq .L67
 552:main.c        ****             DisplayItemInfo();
 1454               	.LM150:
 1455 02a0 0E94 0000 		call DisplayItemInfo
 553:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1457               	.LM151:
 1458 02a4 2091 0000 		lds r18,chg_index
 1459 02a8 30E0      		ldi r19,lo8(0)
 1460 02aa C901      		movw r24,r18
 1461 02ac 8370      		andi r24,lo8(3)
 1462 02ae 9070      		andi r25,hi8(3)
 1463 02b0 9595      		asr r25
 1464 02b2 8795      		ror r24
 1465 02b4 20FF      		sbrs r18,0
 1466 02b6 00C0      		rjmp .L99
 1467 02b8 68E0      		ldi r22,lo8(8)
 1468 02ba 00C0      		rjmp .L68
 1469               	.L99:
 1470 02bc 67E0      		ldi r22,lo8(7)
 1471               	.L68:
 553:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1473               	.LM152:
 1474 02be 0E94 0000 		call lcd_locate
 554:main.c        ****             lcd_update = 0;
 1476               	.LM153:
 1477 02c2 1092 0000 		sts lcd_update,__zero_reg__
 1478               	.L67:
 554:main.c        ****             lcd_update = 0;
 1480               	.LM154:
 1481 02c6 9E01      		movw r18,r28
 1482 02c8 285E      		subi r18,lo8(-(24))
 1483 02ca 3F4F      		sbci r19,hi8(-(24))
 1484 02cc 2496      		adiw r28,66-62
 1485 02ce 3FAF      		std Y+63,r19
 1486 02d0 2EAF      		std Y+62,r18
 1487 02d2 2497      		sbiw r28,66-62
 1488 02d4 AE01      		movw r20,r28
 1489 02d6 4F5F      		subi r20,lo8(-(1))
 1490 02d8 5F4F      		sbci r21,hi8(-(1))
 1491 02da 2896      		adiw r28,70-62
 1492 02dc 5FAF      		std Y+63,r21
 1493 02de 4EAF      		std Y+62,r20
 1494 02e0 2897      		sbiw r28,70-62
 1495 02e2 A7E0      		ldi r26,lo8(7)
 1496 02e4 6A2E      		mov r6,r26
 1497 02e6 712C      		mov r7,__zero_reg__
 1498 02e8 6C0E      		add r6,r28
 1499 02ea 7D1E      		adc r7,r29
 1500 02ec B0E0      		ldi r27,lo8(data)
 1501 02ee 2B2E      		mov r2,r27
 1502 02f0 B0E0      		ldi r27,hi8(data)
 1503 02f2 3B2E      		mov r3,r27
 553:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1505               	.LM155:
 1506 02f4 5A01      		movw r10,r20
 1507 02f6 2696      		adiw r28,68-62
 1508 02f8 3FAF      		std Y+63,r19
 1509 02fa 2EAF      		std Y+62,r18
 1510 02fc 2697      		sbiw r28,68-62
 1511 02fe 8824      		clr r8
 1512 0300 9924      		clr r9
 1513               	.L82:
 575:main.c        ****             if( data_updated[index] == 1 ){
 1515               	.LM156:
 1516 0302 F401      		movw r30,r8
 1517 0304 E050      		subi r30,lo8(-(data_updated))
 1518 0306 F040      		sbci r31,hi8(-(data_updated))
 1519 0308 8081      		ld r24,Z
 1520 030a 8130      		cpi r24,lo8(1)
 1521 030c 01F0      		breq .+2
 1522 030e 00C0      		rjmp .L69
 576:main.c        ****                 data_updated[index] = 0;
 1524               	.LM157:
 1525 0310 1082      		st Z,__zero_reg__
 577:main.c        ****                 monitor_cnt[index] = 0;
 1527               	.LM158:
 1528 0312 D301      		movw r26,r6
 1529 0314 1196      		adiw r26,1
 1530 0316 1C92      		st X,__zero_reg__
 1531 0318 1E92      		st -X,__zero_reg__
 320:main.c        **** int main(void)
 1533               	.LM159:
 1534 031a F401      		movw r30,r8
 1535 031c E050      		subi r30,lo8(-(t_id))
 1536 031e F040      		sbci r31,hi8(-(t_id))
 580:main.c        ****                 id = t_id[index];
 1538               	.LM160:
 1539 0320 E080      		ld r14,Z
 1540 0322 80E0      		ldi r24,lo8(0)
 1541 0324 90E0      		ldi r25,hi8(0)
 1542               	.L74:
 320:main.c        **** int main(void)
 1544               	.LM161:
 1545 0326 F101      		movw r30,r2
 1546 0328 E80F      		add r30,r24
 1547 032a F91F      		adc r31,r25
 584:main.c        ****                     if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 1549               	.LM162:
 1550 032c 2181      		ldd r18,Z+1
 585:main.c        ****                          |( (data[index][n] >= 'A') & (data[index][n] <= 'F') ) ) ){
 1552               	.LM163:
 1553 032e 322F      		mov r19,r18
 1554 0330 3154      		subi r19,lo8(-(-65))
 1555 0332 3630      		cpi r19,lo8(6)
 1556 0334 00F0      		brlo .L101
 584:main.c        ****                     if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 1558               	.LM164:
 1559 0336 2053      		subi r18,lo8(-(-48))
 1560 0338 2A30      		cpi r18,lo8(10)
 1561 033a 00F4      		brsh .L111
 1562               	.L101:
 586:main.c        ****                         valid_packet[index] = 1;
 1564               	.LM165:
 1565 033c 21E0      		ldi r18,lo8(1)
 1566 033e F501      		movw r30,r10
 1567 0340 2083      		st Z,r18
 1568 0342 0196      		adiw r24,1
 583:main.c        ****                 for( n = 1; n < 4; n++ ){
 1570               	.LM166:
 1571 0344 8330      		cpi r24,3
 1572 0346 9105      		cpc r25,__zero_reg__
 1573 0348 01F4      		brne .L74
 1574 034a 00C0      		rjmp .L75
 1575               	.L111:
 588:main.c        ****                         valid_packet[index] = 0;
 1577               	.LM167:
 1578 034c D501      		movw r26,r10
 1579 034e 1C92      		st X,__zero_reg__
 1580               	.L75:
 1582               	.LM168:
 1583 0350 F501      		movw r30,r10
 1584 0352 8081      		ld r24,Z
 1585 0354 8130      		cpi r24,lo8(1)
 1586 0356 01F0      		breq .+2
 1587 0358 00C0      		rjmp .L76
 320:main.c        **** int main(void)
 1589               	.LM169:
 1590 035a 6401      		movw r12,r8
 1591 035c CC0C      		lsl r12
 1592 035e DD1C      		rol r13
 1593 0360 CC0C      		lsl r12
 1594 0362 DD1C      		rol r13
 1595 0364 20E0      		ldi r18,lo8(data+1)
 1596 0366 30E0      		ldi r19,hi8(data+1)
 1597 0368 C20E      		add r12,r18
 1598 036a D31E      		adc r13,r19
 1600               	.LM170:
 1601 036c DE01      		movw r26,r28
 1602 036e 1496      		adiw r26,4
 1603 0370 BE01      		movw r22,r28
 1604 0372 6F5E      		subi r22,lo8(-(17))
 1605 0374 7F4F      		sbci r23,hi8(-(17))
 320:main.c        **** int main(void)
 1607               	.LM171:
 1608 0376 00E0      		ldi r16,lo8(0)
 1609 0378 10E0      		ldi r17,hi8(0)
 1610               	.L80:
 595:main.c        ****                     // Change char to angle-dec
 596:main.c        ****                     dec_ang = 0;
 597:main.c        ****                     for( n = 1; n < 4; n++){ // data[0] is neglected because of it is control data
 598:main.c        ****                         if  ( (data[index][n] & 0xf0) == 0x30 ){
 1612               	.LM172:
 1613 037a F601      		movw r30,r12
 1614 037c 8191      		ld r24,Z+
 1615 037e 6F01      		movw r12,r30
 1616 0380 282F      		mov r18,r24
 1617 0382 30E0      		ldi r19,lo8(0)
 1618 0384 207F      		andi r18,lo8(240)
 1619 0386 3070      		andi r19,hi8(240)
 1620 0388 2033      		cpi r18,48
 1621 038a 3105      		cpc r19,__zero_reg__
 1622 038c 01F4      		brne .L77
 599:main.c        ****                             low4bits[n] = (unsigned int)(data[index][n] & 0x0f);
 1624               	.LM173:
 1625 038e 8F70      		andi r24,lo8(15)
 1626 0390 00C0      		rjmp .L112
 1627               	.L77:
 600:main.c        ****                         }else if ( (data[index][n] & 0xf0) == 0x40 ){
 1629               	.LM174:
 1630 0392 2034      		cpi r18,64
 1631 0394 3105      		cpc r19,__zero_reg__
 1632 0396 01F4      		brne .L79
 601:main.c        ****                             low4bits[n] = (unsigned int)(data[index][n] & 0x0f) + 9;
 1634               	.LM175:
 1635 0398 8F70      		andi r24,lo8(15)
 1636 039a 875F      		subi r24,lo8(-(9))
 1637               	.L112:
 1638 039c 8C93      		st X,r24
 602:main.c        ****                         }else{
 603:main.c        ****                             break;
 604:main.c        ****                         }
 605:main.c        ****                         dec_ang = dec_ang + low4bits[n] * mult_factor[3-n];
 1640               	.LM176:
 1641 039e 8D91      		ld r24,X+
 1642 03a0 90E0      		ldi r25,lo8(0)
 1643 03a2 FB01      		movw r30,r22
 1644 03a4 3291      		ld r19,-Z
 1645 03a6 2291      		ld r18,-Z
 1646 03a8 BF01      		movw r22,r30
 1647 03aa 829F      		mul r24,r18
 1648 03ac A001      		movw r20,r0
 1649 03ae 839F      		mul r24,r19
 1650 03b0 500D      		add r21,r0
 1651 03b2 929F      		mul r25,r18
 1652 03b4 500D      		add r21,r0
 1653 03b6 1124      		clr r1
 1654 03b8 040F      		add r16,r20
 1655 03ba 151F      		adc r17,r21
 597:main.c        ****                     for( n = 1; n < 4; n++){ // data[0] is neglected because of it is control data
 1657               	.LM177:
 1658 03bc 2296      		adiw r28,64-62
 1659 03be 2EAD      		ldd r18,Y+62
 1660 03c0 3FAD      		ldd r19,Y+63
 1661 03c2 2297      		sbiw r28,64-62
 1662 03c4 E217      		cp r30,r18
 1663 03c6 F307      		cpc r31,r19
 1664 03c8 01F4      		brne .L80
 1665               	.L79:
 1666               	.LBB40:
 606:main.c        ****                     }
 607:main.c        ****                     // end of Change char to angle-dec
 608:main.c        ****                     
 609:main.c        ****                     // Change angle-dec to normlized-dec
 610:main.c        ****                     dec_nrm = (float)dec_ang / (float)maxv;
 611:main.c        ****                     // end of Change angle-dec to normlized-dec
 612:main.c        ****                     
 613:main.c        ****                     // Change dec to ISO
 614:main.c        ****                     value[index] = dec_nrm * (uint16_t)pgm_read_word(&(eq_grad[id])) + (int16_t)pgm
 1668               	.LM178:
 1669 03ca 8E2D      		mov r24,r14
 1670 03cc 90E0      		ldi r25,lo8(0)
 1671 03ce 880F      		lsl r24
 1672 03d0 991F      		rol r25
 1673 03d2 FC01      		movw r30,r24
 1674 03d4 E050      		subi r30,lo8(-(eq_grad.1753))
 1675 03d6 F040      		sbci r31,hi8(-(eq_grad.1753))
 1676               	/* #APP */
 1677               	 ;  614 "main.c" 1
 1678 03d8 4590      		lpm r4, Z+
 1679 03da 5490      		lpm r5, Z
 1680               		
 1681               	 ;  0 "" 2
 1682               	/* #NOAPP */
 1683               	.LBE40:
 1684               	.LBB41:
 1685 03dc FC01      		movw r30,r24
 1686 03de E050      		subi r30,lo8(-(eq_intercept.1754))
 1687 03e0 F040      		sbci r31,hi8(-(eq_intercept.1754))
 1688               	/* #APP */
 1689               	 ;  614 "main.c" 1
 1690 03e2 4591      		lpm r20, Z+
 1691 03e4 5491      		lpm r21, Z
 1692               		
 1693               	 ;  0 "" 2
 1694               	/* #NOAPP */
 1695 03e6 2A96      		adiw r28,72-62
 1696 03e8 5FAF      		std Y+63,r21
 1697 03ea 4EAF      		std Y+62,r20
 1698 03ec 2A97      		sbiw r28,72-62
 1699               	.LBE41:
 610:main.c        ****                     dec_nrm = (float)dec_ang / (float)maxv;
 1701               	.LM179:
 1702 03ee B801      		movw r22,r16
 1703 03f0 80E0      		ldi r24,lo8(0)
 1704 03f2 90E0      		ldi r25,hi8(0)
 1705 03f4 0E94 0000 		call __floatunsisf
 1706 03f8 20E0      		ldi r18,lo8(0x45130000)
 1707 03fa 30E0      		ldi r19,hi8(0x45130000)
 1708 03fc 43E1      		ldi r20,hlo8(0x45130000)
 1709 03fe 55E4      		ldi r21,hhi8(0x45130000)
 1710 0400 0E94 0000 		call __divsf3
 1711 0404 6B01      		movw r12,r22
 1712 0406 7C01      		movw r14,r24
 1714               	.LM180:
 1715 0408 B201      		movw r22,r4
 1716 040a 80E0      		ldi r24,lo8(0)
 1717 040c 90E0      		ldi r25,hi8(0)
 1718 040e 0E94 0000 		call __floatunsisf
 1719 0412 9B01      		movw r18,r22
 1720 0414 AC01      		movw r20,r24
 1721 0416 C701      		movw r24,r14
 1722 0418 B601      		movw r22,r12
 1723 041a 0E94 0000 		call __mulsf3
 1724 041e 6B01      		movw r12,r22
 1725 0420 7C01      		movw r14,r24
 1726 0422 2A96      		adiw r28,72-62
 1727 0424 AEAD      		ldd r26,Y+62
 1728 0426 BFAD      		ldd r27,Y+63
 1729 0428 2A97      		sbiw r28,72-62
 1730 042a BD01      		movw r22,r26
 1731 042c 8827      		clr r24
 1732 042e 77FD      		sbrc r23,7
 1733 0430 8095      		com r24
 1734 0432 982F      		mov r25,r24
 1735 0434 0E94 0000 		call __floatsisf
 1736 0438 9B01      		movw r18,r22
 1737 043a AC01      		movw r20,r24
 1738 043c C701      		movw r24,r14
 1739 043e B601      		movw r22,r12
 1740 0440 0E94 0000 		call __addsf3
 1741 0444 DC01      		movw r26,r24
 1742 0446 CB01      		movw r24,r22
 1743 0448 2696      		adiw r28,68-62
 1744 044a EEAD      		ldd r30,Y+62
 1745 044c FFAD      		ldd r31,Y+63
 1746 044e 2697      		sbiw r28,68-62
 1747 0450 8083      		st Z,r24
 1748 0452 9183      		std Z+1,r25
 1749 0454 A283      		std Z+2,r26
 1750 0456 B383      		std Z+3,r27
 1751 0458 00C0      		rjmp .L76
 1752               	.L69:
 615:main.c        ****                 }
 616:main.c        ****                 
 617:main.c        ****             }else{
 618:main.c        ****                 if( monitor_cnt[index] == LINKTAP_TIMEOUT ){
 1754               	.LM181:
 1755 045a D301      		movw r26,r6
 1756 045c 8D91      		ld r24,X+
 1757 045e 9C91      		ld r25,X
 1758 0460 1197      		sbiw r26,1
 1759 0462 B1E0      		ldi r27,hi8(300)
 1760 0464 8C32      		cpi r24,lo8(300)
 1761 0466 9B07      		cpc r25,r27
 1762 0468 01F4      		brne .L81
 619:main.c        ****                     valid_packet[index] = 0;
 1764               	.LM182:
 1765 046a F501      		movw r30,r10
 1766 046c 1082      		st Z,__zero_reg__
 1767               	.LBB42:
 1768               	.LBB43:
 1770               	.Ltext13:
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1772               	.LM183:
 1773 046e 87EC      		 ldi r24,lo8(199)
 1774 0470 90E0      	    ldi r25,hi8(199)
 1775 0472 0197      	    1:sbiw r24,1
 1776 0474 01F4      	    brne 1b
 1777 0476 00C0      		rjmp .
 1778 0478 0000      		nop
 1779 047a 00C0      		rjmp .L76
 1780               	.L81:
 1781               	.LBE43:
 1782               	.LBE42:
 1784               	.Ltext14:
 620:main.c        ****                     _delay_us(50); // delay adjust
 621:main.c        ****                 }else{
 622:main.c        ****                     monitor_cnt[index] = monitor_cnt[index] + 1;
 1786               	.LM184:
 1787 047c 0196      		adiw r24,1
 1788 047e D301      		movw r26,r6
 1789 0480 1196      		adiw r26,1
 1790 0482 9C93      		st X,r25
 1791 0484 8E93      		st -X,r24
 1792               	.L76:
 1793 0486 0894      		sec
 1794 0488 811C      		adc r8,__zero_reg__
 1795 048a 911C      		adc r9,__zero_reg__
 1796 048c 2696      		adiw r28,68-62
 1797 048e EEAD      		ldd r30,Y+62
 1798 0490 FFAD      		ldd r31,Y+63
 1799 0492 2697      		sbiw r28,68-62
 1800 0494 3496      		adiw r30,4
 1801 0496 2696      		adiw r28,68-62
 1802 0498 FFAF      		std Y+63,r31
 1803 049a EEAF      		std Y+62,r30
 1804 049c 2697      		sbiw r28,68-62
 1805 049e 0894      		sec
 1806 04a0 A11C      		adc r10,__zero_reg__
 1807 04a2 B11C      		adc r11,__zero_reg__
 1808 04a4 22E0      		ldi r18,lo8(2)
 1809 04a6 30E0      		ldi r19,hi8(2)
 1810 04a8 620E      		add r6,r18
 1811 04aa 731E      		adc r7,r19
 1812 04ac 44E0      		ldi r20,lo8(4)
 1813 04ae 50E0      		ldi r21,hi8(4)
 1814 04b0 240E      		add r2,r20
 1815 04b2 351E      		adc r3,r21
 573:main.c        ****         for ( index = 0; index < Ndata; index++ ){
 1817               	.LM185:
 1818 04b4 52E0      		ldi r21,lo8(2)
 1819 04b6 8516      		cp r8,r21
 1820 04b8 9104      		cpc r9,__zero_reg__
 1821 04ba 01F0      		breq .+2
 1822 04bc 00C0      		rjmp .L82
 623:main.c        ****                 }
 624:main.c        ****             }
 625:main.c        ****         }
 626:main.c        ****         
 627:main.c        ****         rpm = TachoMeter();
 1824               	.LM186:
 1825 04be 0E94 0000 		call TachoMeter
 1826 04c2 4B01      		movw r8,r22
 1827 04c4 5C01      		movw r10,r24
 1828 04c6 6093 0000 		sts rpm,r22
 1829 04ca 7093 0000 		sts rpm+1,r23
 1830 04ce 8093 0000 		sts rpm+2,r24
 1831 04d2 9093 0000 		sts rpm+3,r25
 628:main.c        ****         
 629:main.c        ****         
 630:main.c        ****         // Fuel Pump Driver
 631:main.c        ****         
 632:main.c        ****         // Measure Fuel Pump Voltage
 633:main.c        ****         FP_Volt = (uint16_t)ADCH * ( 5.0 * 3.0 / 255.0 );
 1833               	.LM187:
 1834 04d6 6091 7900 		lds r22,121
 1835 04da 70E0      		ldi r23,lo8(0)
 1836 04dc 80E0      		ldi r24,lo8(0)
 1837 04de 90E0      		ldi r25,hi8(0)
 1838 04e0 0E94 0000 		call __floatunsisf
 1839 04e4 21EF      		ldi r18,lo8(0x3d70f0f1)
 1840 04e6 30EF      		ldi r19,hi8(0x3d70f0f1)
 1841 04e8 40E7      		ldi r20,hlo8(0x3d70f0f1)
 1842 04ea 5DE3      		ldi r21,hhi8(0x3d70f0f1)
 1843 04ec 0E94 0000 		call __mulsf3
 1844 04f0 3B01      		movw r6,r22
 1845 04f2 582E      		mov r5,r24
 1846 04f4 492E      		mov r4,r25
 634:main.c        ****         // ADCH is 8-bit ADC output
 635:main.c        ****         // 5.0 is ATMEGA88 Power Supply Voltage
 636:main.c        ****         // 3.0 is ratio of input ladder resistor
 637:main.c        ****         
 638:main.c        ****         OCR0B = FuelPumpDriver(rpm, value[0],value[1],FP_maxmode);
 1848               	.LM188:
 1849 04f6 288D      		ldd r18,Y+24
 1850 04f8 398D      		ldd r19,Y+25
 1851 04fa 4A8D      		ldd r20,Y+26
 1852 04fc 5B8D      		ldd r21,Y+27
 1853 04fe EC8C      		ldd r14,Y+28
 1854 0500 FD8C      		ldd r15,Y+29
 1855 0502 0E8D      		ldd r16,Y+30
 1856 0504 1F8D      		ldd r17,Y+31
 1857 0506 C090 0000 		lds r12,FP_maxmode
 1858 050a C501      		movw r24,r10
 1859 050c B401      		movw r22,r8
 1860 050e DD24      		clr r13
 1861 0510 0E94 0000 		call FuelPumpDriver
 1862 0514 88BD      		out 72-32,r24
 639:main.c        ****         // value[2] ... Fuel Pressure
 640:main.c        ****         // value[3] ... Boost
 641:main.c        ****         
 642:main.c        ****         
 643:main.c        ****         ////// Display Process //////
 644:main.c        ****         if(  timer2_cnt > disp_delay_cnt  ){
 1864               	.LM189:
 1865 0516 8091 0000 		lds r24,timer2_cnt
 1866 051a 9091 0000 		lds r25,timer2_cnt+1
 1867 051e 2091 0000 		lds r18,disp_delay_cnt
 1868 0522 3091 0000 		lds r19,disp_delay_cnt+1
 1869 0526 2817      		cp r18,r24
 1870 0528 3907      		cpc r19,r25
 1871 052a 00F0      		brlo .+2
 1872 052c 00C0      		rjmp .L83
 645:main.c        ****             timer2_cnt = 0;
 1874               	.LM190:
 1875 052e 1092 0000 		sts timer2_cnt+1,__zero_reg__
 1876 0532 1092 0000 		sts timer2_cnt,__zero_reg__
 1877 0536 70E0      		ldi r23,lo8(t_id)
 1878 0538 272E      		mov r2,r23
 1879 053a 70E0      		ldi r23,hi8(t_id)
 1880 053c 372E      		mov r3,r23
 646:main.c        ****             
 647:main.c        ****             //// Defi Link Tap ////
 648:main.c        ****             for ( index = 0; index < Ndata; index++ ){
 1882               	.LM191:
 1883 053e 8824      		clr r8
 1884               	.L95:
 649:main.c        ****                 
 650:main.c        ****                 // Rx data read
 651:main.c        ****                 id = t_id[index];
 1886               	.LM192:
 1887 0540 D101      		movw r26,r2
 1888 0542 CD90      		ld r12,X+
 1889 0544 1D01      		movw r2,r26
 652:main.c        ****                 
 653:main.c        ****                 // clear value area of LCD
 654:main.c        ****                 lcd_locate(index,RxNameLength[id]);
 1891               	.LM193:
 1892 0546 DD24      		clr r13
 1893 0548 8601      		movw r16,r12
 1894 054a 0050      		subi r16,lo8(-(RxNameLength))
 1895 054c 1040      		sbci r17,hi8(-(RxNameLength))
 1896 054e 882D      		mov r24,r8
 1897 0550 F801      		movw r30,r16
 1898 0552 6081      		ld r22,Z
 1899 0554 0E94 0000 		call lcd_locate
 655:main.c        ****                 for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1901               	.LM194:
 1902 0558 EE24      		clr r14
 1903 055a 00C0      		rjmp .L84
 1904               	.L85:
 656:main.c        ****                     lcd_set_char(' ');
 1906               	.LM195:
 1907 055c 80E2      		ldi r24,lo8(32)
 1908 055e 0E94 0000 		call lcd_set_char
 655:main.c        ****                 for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1910               	.LM196:
 1911 0562 E394      		inc r14
 1912               	.L84:
 655:main.c        ****                 for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1914               	.LM197:
 1915 0564 D801      		movw r26,r16
 1916 0566 6C91      		ld r22,X
 1917 0568 8E2D      		mov r24,r14
 1918 056a 90E0      		ldi r25,lo8(0)
 1919 056c 26E0      		ldi r18,lo8(6)
 1920 056e 30E0      		ldi r19,hi8(6)
 1921 0570 261B      		sub r18,r22
 1922 0572 3109      		sbc r19,__zero_reg__
 1923 0574 2817      		cp r18,r24
 1924 0576 3907      		cpc r19,r25
 1925 0578 04F4      		brge .L85
 657:main.c        ****                 }
 658:main.c        ****                 // end of clear value area
 659:main.c        ****                 
 660:main.c        ****                 // pad blank area of LCD
 661:main.c        ****                 lcd_locate(index,RxNameLength[id]);
 1927               	.LM198:
 1928 057a 882D      		mov r24,r8
 1929 057c 0E94 0000 		call lcd_locate
 662:main.c        ****                 for (n=0;n<Nspace[id];n++){
 1931               	.LM199:
 1932 0580 EE24      		clr r14
 1933 0582 01E1      		ldi r16,lo8(17)
 1934 0584 10E0      		ldi r17,hi8(17)
 1935 0586 0C0F      		add r16,r28
 1936 0588 1D1F      		adc r17,r29
 1937 058a 0C0D      		add r16,r12
 1938 058c 1D1D      		adc r17,r13
 1939 058e 00C0      		rjmp .L86
 1940               	.L87:
 663:main.c        ****                     lcd_set_char(' ');
 1942               	.LM200:
 1943 0590 80E2      		ldi r24,lo8(32)
 1944 0592 0E94 0000 		call lcd_set_char
 662:main.c        ****                 for (n=0;n<Nspace[id];n++){
 1946               	.LM201:
 1947 0596 E394      		inc r14
 1948               	.L86:
 662:main.c        ****                 for (n=0;n<Nspace[id];n++){
 1950               	.LM202:
 1951 0598 F801      		movw r30,r16
 1952 059a 8081      		ld r24,Z
 1953 059c E816      		cp r14,r24
 1954 059e 00F0      		brlo .L87
 664:main.c        ****                 }
 665:main.c        ****                 // end of pad blank area of LCD
 666:main.c        ****                 
 667:main.c        ****                 // display value
 668:main.c        ****                 if ( valid_packet[index] == 1 ) {
 1956               	.LM203:
 1957 05a0 2896      		adiw r28,70-62
 1958 05a2 AEAD      		ldd r26,Y+62
 1959 05a4 BFAD      		ldd r27,Y+63
 1960 05a6 2897      		sbiw r28,70-62
 1961 05a8 8D91      		ld r24,X+
 1962 05aa 2896      		adiw r28,70-62
 1963 05ac BFAF      		std Y+63,r27
 1964 05ae AEAF      		std Y+62,r26
 1965 05b0 2897      		sbiw r28,70-62
 1966 05b2 8130      		cpi r24,lo8(1)
 1967 05b4 01F4      		brne .L88
 669:main.c        ****                     lcd_set_numeric(value[index],Nint[id],Nsig[id]-Nint[id],SIGN[id]);
 1969               	.LM204:
 1970 05b6 F601      		movw r30,r12
 1971 05b8 E050      		subi r30,lo8(-(Nint.1756))
 1972 05ba F040      		sbci r31,hi8(-(Nint.1756))
 1973 05bc 4081      		ld r20,Z
 1974 05be 2496      		adiw r28,66-62
 1975 05c0 EEAD      		ldd r30,Y+62
 1976 05c2 FFAD      		ldd r31,Y+63
 1977 05c4 2497      		sbiw r28,66-62
 1978 05c6 6081      		ld r22,Z
 1979 05c8 7181      		ldd r23,Z+1
 1980 05ca 8281      		ldd r24,Z+2
 1981 05cc 9381      		ldd r25,Z+3
 1982 05ce F601      		movw r30,r12
 1983 05d0 E050      		subi r30,lo8(-(Nsig.1755))
 1984 05d2 F040      		sbci r31,hi8(-(Nsig.1755))
 1985 05d4 2081      		ld r18,Z
 1986 05d6 30E0      		ldi r19,lo8(0)
 1987 05d8 241B      		sub r18,r20
 1988 05da 3109      		sbc r19,__zero_reg__
 1989 05dc F601      		movw r30,r12
 1990 05de E050      		subi r30,lo8(-(SIGN.1757))
 1991 05e0 F040      		sbci r31,hi8(-(SIGN.1757))
 1992 05e2 0081      		ld r16,Z
 1993 05e4 50E0      		ldi r21,lo8(0)
 1994 05e6 10E0      		ldi r17,lo8(0)
 1995 05e8 0E94 0000 		call lcd_set_numeric
 1996 05ec 00C0      		rjmp .L89
 1997               	.L88:
 670:main.c        ****                 }else if( valid_packet[index] == 0 ){
 1999               	.LM205:
 2000 05ee 8823      		tst r24
 2001 05f0 01F0      		breq .L100
 2002 05f2 00C0      		rjmp .L89
 2003               	.L91:
 671:main.c        ****                     for(n=0;n<(Nsig[id]!=Nint[id])+SIGN[id];n++){
 672:main.c        ****                         lcd_set_char(' ');
 2005               	.LM206:
 2006 05f4 80E2      		ldi r24,lo8(32)
 2007 05f6 0E94 0000 		call lcd_set_char
 671:main.c        ****                     for(n=0;n<(Nsig[id]!=Nint[id])+SIGN[id];n++){
 2009               	.LM207:
 2010 05fa 0F5F      		subi r16,lo8(-(1))
 2011 05fc 00C0      		rjmp .L90
 2012               	.L100:
 670:main.c        ****                 }else if( valid_packet[index] == 0 ){
 2014               	.LM208:
 2015 05fe 00E0      		ldi r16,lo8(0)
 671:main.c        ****                     for(n=0;n<(Nsig[id]!=Nint[id])+SIGN[id];n++){
 2017               	.LM209:
 2018 0600 F601      		movw r30,r12
 2019 0602 E050      		subi r30,lo8(-(Nsig.1755))
 2020 0604 F040      		sbci r31,hi8(-(Nsig.1755))
 2021 0606 E080      		ld r14,Z
 2022 0608 F601      		movw r30,r12
 2023 060a E050      		subi r30,lo8(-(Nint.1756))
 2024 060c F040      		sbci r31,hi8(-(Nint.1756))
 2025 060e A080      		ld r10,Z
 2026 0610 F601      		movw r30,r12
 2027 0612 E050      		subi r30,lo8(-(SIGN.1757))
 2028 0614 F040      		sbci r31,hi8(-(SIGN.1757))
 2029 0616 C080      		ld r12,Z
 2030 0618 DD24      		clr r13
 2031               	.L90:
 671:main.c        ****                     for(n=0;n<(Nsig[id]!=Nint[id])+SIGN[id];n++){
 2033               	.LM210:
 2034 061a 202F      		mov r18,r16
 2035 061c 30E0      		ldi r19,lo8(0)
 2036 061e 81E0      		ldi r24,lo8(1)
 2037 0620 90E0      		ldi r25,hi8(1)
 2038 0622 EA14      		cp r14,r10
 2039 0624 01F4      		brne .L92
 2040 0626 80E0      		ldi r24,lo8(0)
 2041 0628 90E0      		ldi r25,hi8(0)
 2042               	.L92:
 2043 062a 8C0D      		add r24,r12
 2044 062c 9D1D      		adc r25,r13
 2045 062e 2817      		cp r18,r24
 2046 0630 3907      		cpc r19,r25
 2047 0632 04F0      		brlt .L91
 671:main.c        ****                     for(n=0;n<(Nsig[id]!=Nint[id])+SIGN[id];n++){
 2049               	.LM211:
 2050 0634 00E0      		ldi r16,lo8(0)
 2051 0636 00C0      		rjmp .L93
 2052               	.L94:
 673:main.c        ****                     }
 674:main.c        ****                     for(n=0;n<Nsig[id];n++){
 675:main.c        ****                         lcd_set_char('*');
 2054               	.LM212:
 2055 0638 8AE2      		ldi r24,lo8(42)
 2056 063a 0E94 0000 		call lcd_set_char
 674:main.c        ****                     for(n=0;n<Nsig[id];n++){
 2058               	.LM213:
 2059 063e 0F5F      		subi r16,lo8(-(1))
 2060               	.L93:
 674:main.c        ****                     for(n=0;n<Nsig[id];n++){
 2062               	.LM214:
 2063 0640 0E15      		cp r16,r14
 2064 0642 01F4      		brne .L94
 2065               	.L89:
 648:main.c        ****             for ( index = 0; index < Ndata; index++ ){
 2067               	.LM215:
 2068 0644 8394      		inc r8
 2069 0646 2496      		adiw r28,66-62
 2070 0648 2EAD      		ldd r18,Y+62
 2071 064a 3FAD      		ldd r19,Y+63
 2072 064c 2497      		sbiw r28,66-62
 2073 064e 2C5F      		subi r18,lo8(-(4))
 2074 0650 3F4F      		sbci r19,hi8(-(4))
 2075 0652 2496      		adiw r28,66-62
 2076 0654 3FAF      		std Y+63,r19
 2077 0656 2EAF      		std Y+62,r18
 2078 0658 2497      		sbiw r28,66-62
 2079 065a 32E0      		ldi r19,lo8(2)
 2080 065c 8316      		cp r8,r19
 2081 065e 01F0      		breq .+2
 2082 0660 00C0      		rjmp .L95
 676:main.c        ****                     }
 677:main.c        ****                 }
 678:main.c        ****                 // end of display value
 679:main.c        ****                 
 680:main.c        ****             }
 681:main.c        ****             
 682:main.c        ****             // Display Fuel Pump Voltage
 683:main.c        ****             lcd_locate(2,12);
 2084               	.LM216:
 2085 0662 82E0      		ldi r24,lo8(2)
 2086 0664 6CE0      		ldi r22,lo8(12)
 2087 0666 0E94 0000 		call lcd_locate
 684:main.c        ****             lcd_set_str("FP ");
 2089               	.LM217:
 2090 066a 80E0      		ldi r24,lo8(.LC1)
 2091 066c 90E0      		ldi r25,hi8(.LC1)
 2092 066e 0E94 0000 		call lcd_set_str
 685:main.c        ****             lcd_set_numeric(FP_Volt,2,1,0);
 2094               	.LM218:
 2095 0672 9201      		movw r18,r4
 2096 0674 862D      		mov r24,r6
 2097 0676 972D      		mov r25,r7
 2098 0678 A32F      		mov r26,r19
 2099 067a B42D      		mov r27,r4
 2100 067c BC01      		movw r22,r24
 2101 067e CD01      		movw r24,r26
 2102 0680 42E0      		ldi r20,lo8(2)
 2103 0682 50E0      		ldi r21,hi8(2)
 2104 0684 21E0      		ldi r18,lo8(1)
 2105 0686 30E0      		ldi r19,hi8(1)
 2106 0688 00E0      		ldi r16,lo8(0)
 2107 068a 10E0      		ldi r17,hi8(0)
 2108 068c 0E94 0000 		call lcd_set_numeric
 686:main.c        ****             lcd_set_str("V");
 2110               	.LM219:
 2111 0690 80E0      		ldi r24,lo8(.LC2)
 2112 0692 90E0      		ldi r25,hi8(.LC2)
 2113 0694 0E94 0000 		call lcd_set_str
 2114               	.L83:
 687:main.c        ****             
 688:main.c        ****             /*
 689:main.c        ****              // Display Facemark
 690:main.c        ****              lcd_locate(2,13);
 691:main.c        ****              if((unsigned int)rpm < 3000){
 692:main.c        ****              shobon();
 693:main.c        ****              }else if((unsigned int)rpm < 5000){
 694:main.c        ****              shakin();
 695:main.c        ****              }else{
 696:main.c        ****              kuwa();
 697:main.c        ****              lcd_set_str("  ");
 698:main.c        ****              }
 699:main.c        ****              */
 700:main.c        ****             
 701:main.c        ****             
 702:main.c        ****         }
 703:main.c        ****         
 704:main.c        ****         //// Real-Time Update items
 705:main.c        ****         
 706:main.c        ****         // Display RPM
 707:main.c        ****         lcd_locate(0,8);
 2116               	.LM220:
 2117 0698 80E0      		ldi r24,lo8(0)
 2118 069a 68E0      		ldi r22,lo8(8)
 2119 069c 0E94 0000 		call lcd_locate
 708:main.c        ****         lcd_set_numeric((unsigned int)rpm,5,0,0);
 2121               	.LM221:
 2122 06a0 6091 0000 		lds r22,rpm
 2123 06a4 7091 0000 		lds r23,rpm+1
 2124 06a8 80E0      		ldi r24,lo8(0)
 2125 06aa 90E0      		ldi r25,hi8(0)
 2126 06ac 0E94 0000 		call __floatunsisf
 2127 06b0 45E0      		ldi r20,lo8(5)
 2128 06b2 50E0      		ldi r21,hi8(5)
 2129 06b4 20E0      		ldi r18,lo8(0)
 2130 06b6 30E0      		ldi r19,hi8(0)
 2131 06b8 00E0      		ldi r16,lo8(0)
 2132 06ba 10E0      		ldi r17,hi8(0)
 2133 06bc 0E94 0000 		call lcd_set_numeric
 709:main.c        ****         lcd_set_str("rpm");
 2135               	.LM222:
 2136 06c0 80E0      		ldi r24,lo8(.LC3)
 2137 06c2 90E0      		ldi r25,hi8(.LC3)
 2138 06c4 0E94 0000 		call lcd_set_str
 710:main.c        ****         
 711:main.c        **** 
 712:main.c        ****         // Display Fuel Pump Duty
 713:main.c        ****         lcd_locate(1,8);
 2140               	.LM223:
 2141 06c8 81E0      		ldi r24,lo8(1)
 2142 06ca 68E0      		ldi r22,lo8(8)
 2143 06cc 0E94 0000 		call lcd_locate
 714:main.c        ****         if( FP_maxmode == 0 ){
 2145               	.LM224:
 2146 06d0 8091 0000 		lds r24,FP_maxmode
 2147 06d4 8823      		tst r24
 2148 06d6 01F4      		brne .L96
 715:main.c        ****             lcd_set_str("DUTY");
 2150               	.LM225:
 2151 06d8 80E0      		ldi r24,lo8(.LC4)
 2152 06da 90E0      		ldi r25,hi8(.LC4)
 2153 06dc 0E94 0000 		call lcd_set_str
 716:main.c        ****             lcd_set_numeric(OCR0B*1.0/0xff*100,3,0,0);
 2155               	.LM226:
 2156 06e0 68B5      		in r22,72-32
 2157 06e2 70E0      		ldi r23,lo8(0)
 2158 06e4 80E0      		ldi r24,lo8(0)
 2159 06e6 90E0      		ldi r25,hi8(0)
 2160 06e8 0E94 0000 		call __floatsisf
 2161 06ec 20E0      		ldi r18,lo8(0x437f0000)
 2162 06ee 30E0      		ldi r19,hi8(0x437f0000)
 2163 06f0 4FE7      		ldi r20,hlo8(0x437f0000)
 2164 06f2 53E4      		ldi r21,hhi8(0x437f0000)
 2165 06f4 0E94 0000 		call __divsf3
 2166 06f8 20E0      		ldi r18,lo8(0x42c80000)
 2167 06fa 30E0      		ldi r19,hi8(0x42c80000)
 2168 06fc 48EC      		ldi r20,hlo8(0x42c80000)
 2169 06fe 52E4      		ldi r21,hhi8(0x42c80000)
 2170 0700 0E94 0000 		call __mulsf3
 2171 0704 43E0      		ldi r20,lo8(3)
 2172 0706 50E0      		ldi r21,hi8(3)
 2173 0708 20E0      		ldi r18,lo8(0)
 2174 070a 30E0      		ldi r19,hi8(0)
 2175 070c 0E94 0000 		call lcd_set_numeric
 717:main.c        ****             lcd_set_str("%");
 2177               	.LM227:
 2178 0710 80E0      		ldi r24,lo8(.LC5)
 2179 0712 90E0      		ldi r25,hi8(.LC5)
 2180 0714 00C0      		rjmp .L113
 2181               	.L96:
 718:main.c        ****         }else{
 719:main.c        ****             lcd_set_str("=FP MAX=");
 2183               	.LM228:
 2184 0716 80E0      		ldi r24,lo8(.LC6)
 2185 0718 90E0      		ldi r25,hi8(.LC6)
 2186               	.L113:
 2187 071a 0E94 0000 		call lcd_set_str
 720:main.c        ****         }
 721:main.c        ****         
 722:main.c        ****         // Display RPM @ Bar Meter
 723:main.c        ****         //        lcd_locate(3,12);
 724:main.c        ****         //        BarMeter_disp((unsigned int)rpm);
 725:main.c        **** 
 726:main.c        ****         #if USB_COM // Ignore Compile
 727:main.c        ****         //// USART
 728:main.c        ****         USART_transmit_numeric(rpm,5,0,0);
 2189               	.LM229:
 2190 071e 6091 0000 		lds r22,rpm
 2191 0722 7091 0000 		lds r23,rpm+1
 2192 0726 8091 0000 		lds r24,rpm+2
 2193 072a 9091 0000 		lds r25,rpm+3
 2194 072e 0E94 0000 		call __floatunsisf
 2195 0732 45E0      		ldi r20,lo8(5)
 2196 0734 50E0      		ldi r21,hi8(5)
 2197 0736 20E0      		ldi r18,lo8(0)
 2198 0738 30E0      		ldi r19,hi8(0)
 2199 073a 00E0      		ldi r16,lo8(0)
 2200 073c 10E0      		ldi r17,hi8(0)
 2201 073e 0E94 0000 		call USART_transmit_numeric
 729:main.c        ****         USART_transmit_str(",   ");
 2203               	.LM230:
 2204 0742 80E0      		ldi r24,lo8(.LC7)
 2205 0744 90E0      		ldi r25,hi8(.LC7)
 2206 0746 0E94 0000 		call USART_transmit_str
 730:main.c        ****         USART_transmit_numeric(value[3],3,2,1);         // value[3] ... Boost
 2208               	.LM231:
 2209 074a 6CA1      		ldd r22,Y+36
 2210 074c 7DA1      		ldd r23,Y+37
 2211 074e 8EA1      		ldd r24,Y+38
 2212 0750 9FA1      		ldd r25,Y+39
 2213 0752 43E0      		ldi r20,lo8(3)
 2214 0754 50E0      		ldi r21,hi8(3)
 2215 0756 22E0      		ldi r18,lo8(2)
 2216 0758 30E0      		ldi r19,hi8(2)
 2217 075a 01E0      		ldi r16,lo8(1)
 2218 075c 10E0      		ldi r17,hi8(1)
 2219 075e 0E94 0000 		call USART_transmit_numeric
 731:main.c        ****         USART_transmit_str("kg/cm2,   ");
 2221               	.LM232:
 2222 0762 80E0      		ldi r24,lo8(.LC8)
 2223 0764 90E0      		ldi r25,hi8(.LC8)
 2224 0766 0E94 0000 		call USART_transmit_str
 732:main.c        ****         USART_transmit_numeric(OCR0B*1.0/0xff*100,3,0,0);   // Fuel Pump Duty
 2226               	.LM233:
 2227 076a 68B5      		in r22,72-32
 2228 076c 70E0      		ldi r23,lo8(0)
 2229 076e 80E0      		ldi r24,lo8(0)
 2230 0770 90E0      		ldi r25,hi8(0)
 2231 0772 0E94 0000 		call __floatsisf
 2232 0776 20E0      		ldi r18,lo8(0x437f0000)
 2233 0778 30E0      		ldi r19,hi8(0x437f0000)
 2234 077a 4FE7      		ldi r20,hlo8(0x437f0000)
 2235 077c 53E4      		ldi r21,hhi8(0x437f0000)
 2236 077e 0E94 0000 		call __divsf3
 2237 0782 20E0      		ldi r18,lo8(0x42c80000)
 2238 0784 30E0      		ldi r19,hi8(0x42c80000)
 2239 0786 48EC      		ldi r20,hlo8(0x42c80000)
 2240 0788 52E4      		ldi r21,hhi8(0x42c80000)
 2241 078a 0E94 0000 		call __mulsf3
 2242 078e 43E0      		ldi r20,lo8(3)
 2243 0790 50E0      		ldi r21,hi8(3)
 2244 0792 20E0      		ldi r18,lo8(0)
 2245 0794 30E0      		ldi r19,hi8(0)
 2246 0796 00E0      		ldi r16,lo8(0)
 2247 0798 10E0      		ldi r17,hi8(0)
 2248 079a 0E94 0000 		call USART_transmit_numeric
 733:main.c        ****         USART_transmit_str("%,   ");
 2250               	.LM234:
 2251 079e 80E0      		ldi r24,lo8(.LC9)
 2252 07a0 90E0      		ldi r25,hi8(.LC9)
 2253 07a2 0E94 0000 		call USART_transmit_str
 734:main.c        ****         USART_transmit_numeric(FP_Volt,2,1,0);// Fuel Pump Voltage
 2255               	.LM235:
 2256 07a6 9201      		movw r18,r4
 2257 07a8 862D      		mov r24,r6
 2258 07aa 972D      		mov r25,r7
 2259 07ac A32F      		mov r26,r19
 2260 07ae B42D      		mov r27,r4
 2261 07b0 BC01      		movw r22,r24
 2262 07b2 CD01      		movw r24,r26
 2263 07b4 42E0      		ldi r20,lo8(2)
 2264 07b6 50E0      		ldi r21,hi8(2)
 2265 07b8 21E0      		ldi r18,lo8(1)
 2266 07ba 30E0      		ldi r19,hi8(1)
 2267 07bc 0E94 0000 		call USART_transmit_numeric
 735:main.c        ****         USART_transmit_str("V,   ");
 2269               	.LM236:
 2270 07c0 80E0      		ldi r24,lo8(.LC10)
 2271 07c2 90E0      		ldi r25,hi8(.LC10)
 2272 07c4 0E94 0000 		call USART_transmit_str
 736:main.c        ****         USART_transmit_numeric(value[2],3,2,0);         // value[2] ... Fuel Pressure
 2274               	.LM237:
 2275 07c8 68A1      		ldd r22,Y+32
 2276 07ca 79A1      		ldd r23,Y+33
 2277 07cc 8AA1      		ldd r24,Y+34
 2278 07ce 9BA1      		ldd r25,Y+35
 2279 07d0 43E0      		ldi r20,lo8(3)
 2280 07d2 50E0      		ldi r21,hi8(3)
 2281 07d4 22E0      		ldi r18,lo8(2)
 2282 07d6 30E0      		ldi r19,hi8(2)
 2283 07d8 0E94 0000 		call USART_transmit_numeric
 737:main.c        ****         USART_transmit_str("kg/cm2\n");
 2285               	.LM238:
 2286 07dc 80E0      		ldi r24,lo8(.LC11)
 2287 07de 90E0      		ldi r25,hi8(.LC11)
 2288 07e0 0E94 0000 		call USART_transmit_str
 2289               	.LBE39:
 738:main.c        ****         #endif
 739:main.c        ****         
 740:main.c        **** 	}
 2291               	.LM239:
 2292 07e4 00C0      		rjmp .L98
 2316               	.Lscope12:
 2317               	.global	FP_maxmode
 2318               	.global	FP_maxmode
 2319               		.section .bss
 2322               	FP_maxmode:
 2323 0000 00        		.skip 1,0
 2324               	.global	USART_data_index
 2325               		.data
 2328               	USART_data_index:
 2329 004b FF        		.byte	-1
 2330               		.comm USART_index,1,1
 2331               		.comm Ndiv2,2,1
 2332               		.comm Ndiv1,2,1
 2333               		.comm Ndiv0,2,1
 2334               		.comm disp_delay_cnt,2,1
 2335               	.global	disp_cnt_last
 2336               	.global	disp_cnt_last
 2337               		.section .bss
 2340               	disp_cnt_last:
 2341 0001 0000      		.skip 2,0
 2342               		.comm timer2_cnt,2,1
 2343               	.global	rpm
 2344               	.global	rpm
 2347               	rpm:
 2348 0003 0000 0000 		.skip 4,0
 2349               		.comm data_updated,2,1
 2350               		.comm data,8,1
 2351               	.global	lcd_update
 2352               		.data
 2355               	lcd_update:
 2356 004c 01        		.byte	1
 2357               		.comm RxNameLength,7,1
 2358               	.global	opening_message
 2359               		.section	.progmem.data,"a",@progbits
 2362               	opening_message:
 2363 0000 0000      		.word	opening_message_0
 2364 0002 0000      		.word	opening_message_1
 2365               	.global	opening_message_1
 2368               	opening_message_1:
 2369 0004 4669 726D 		.string	"Firmware Rev. 10"
 2369      7761 7265 
 2369      2052 6576 
 2369      2E20 3130 
 2369      00
 2370               	.global	opening_message_0
 2373               	opening_message_0:
 2374 0015 4675 656C 		.string	"Fuel Pump Driver"
 2374      2050 756D 
 2374      7020 4472 
 2374      6976 6572 
 2374      00
 2375               	.global	RxName
 2378               	RxName:
 2379 0026 0000      		.word	RxName_0
 2380 0028 0000      		.word	RxName_1
 2381 002a 0000      		.word	RxName_2
 2382 002c 0000      		.word	RxName_3
 2383 002e 0000      		.word	RxName_4
 2384 0030 0000      		.word	RxName_5
 2385 0032 0000      		.word	RxName_6
 2386               	.global	RxName_6
 2389               	RxName_6:
 2390 0034 5754 00   		.string	"WT"
 2391               	.global	RxName_5
 2394               	RxName_5:
 2395 0037 4F54 00   		.string	"OT"
 2396               	.global	RxName_4
 2399               	RxName_4:
 2400 003a 4554 00   		.string	"ET"
 2401               	.global	RxName_3
 2404               	RxName_3:
 2405 003d 4650 00   		.string	"FP"
 2406               	.global	RxName_2
 2409               	RxName_2:
 2410 0040 4F50 00   		.string	"OP"
 2411               	.global	RxName_1
 2414               	RxName_1:
 2415 0043 5443 00   		.string	"TC"
 2416               	.global	RxName_0
 2419               	RxName_0:
 2420 0046 4253 00   		.string	"BS"
 2421               		.comm t_id,2,1
 2422               	.global	RxID
 2423               		.data
 2426               	RxID:
 2427 004d 01        		.byte	1
 2428 004e 02        		.byte	2
 2429 004f 03        		.byte	3
 2430 0050 04        		.byte	4
 2431 0051 05        		.byte	5
 2432 0052 07        		.byte	7
 2433 0053 0F        		.byte	15
 2434               	.global	chg_count
 2437               	chg_count:
 2438 0054 FFFF      		.word	-1
 2439               	.global	chg_index
 2442               	chg_index:
 2443 0056 02        		.byte	2
 2446               	Nsig.1755:
 2447 0057 03        		.byte	3
 2448 0058 04        		.byte	4
 2449 0059 03        		.byte	3
 2450 005a 03        		.byte	3
 2451 005b 04        		.byte	4
 2452 005c 03        		.byte	3
 2453 005d 03        		.byte	3
 2456               	Nint.1756:
 2457 005e 01        		.byte	1
 2458 005f 04        		.byte	4
 2459 0060 02        		.byte	2
 2460 0061 01        		.byte	1
 2461 0062 04        		.byte	4
 2462 0063 03        		.byte	3
 2463 0064 03        		.byte	3
 2466               	SIGN.1757:
 2467 0065 01        		.byte	1
 2468 0066 00        		.byte	0
 2469 0067 00        		.byte	0
 2470 0068 00        		.byte	0
 2471 0069 00        		.byte	0
 2472 006a 00        		.byte	0
 2473 006b 00        		.byte	0
 2474               		.section	.progmem.data
 2477               	__c.1772:
 2478 0049 0A0A 00   		.string	"\n\n"
 2481               	__c.1774:
 2482 004c 4461 7461 		.string	"Data Logger @ Mazda RX-7 FD3S\n\n\n"
 2482      204C 6F67 
 2482      6765 7220 
 2482      4020 4D61 
 2482      7A64 6120 
 2485               	eq_grad.1753:
 2486 006d 0300      		.word	3
 2487 006f 2823      		.word	9000
 2488 0071 0A00      		.word	10
 2489 0073 0600      		.word	6
 2490 0075 8403      		.word	900
 2491 0077 6400      		.word	100
 2492 0079 6400      		.word	100
 2495               	eq_intercept.1754:
 2496 007b FFFF      		.word	-1
 2497 007d 0000      		.word	0
 2498 007f 0000      		.word	0
 2499 0081 0000      		.word	0
 2500 0083 C800      		.word	200
 2501 0085 3200      		.word	50
 2502 0087 1400      		.word	20
 2532               		.text
 2534               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:112    .text:00000000 set_initial_t_id
                            *COM*:00000002 t_id
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:140    .text:0000000c __vector_default
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:177    .text:0000002a timer0_init
                            *COM*:00000002 Ndiv0
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:271    .text:00000094 timer1_init
                            *COM*:00000002 Ndiv1
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:368    .text:00000114 timer2_init
                            *COM*:00000002 Ndiv2
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:477    .text:0000019e __vector_18
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2426   .data:0000004d RxID
                            *COM*:00000001 USART_index
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2328   .data:0000004b USART_data_index
                            *COM*:00000008 data
                            *COM*:00000002 data_updated
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:617    .text:0000025a __vector_9
                            *COM*:00000002 timer2_cnt
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2347   .bss:00000003 rpm
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:686    .text:000002c6 __vector_7
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:740    .text:00000310 StrLength
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:775    .text:00000322 __vector_2
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2322   .bss:00000000 FP_maxmode
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:843    .text:0000036c DisplayItemInfo
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2378   .progmem.data:00000026 RxName
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:965    .text.startup:00000000 main
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2446   .data:00000057 Nsig.1755
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2456   .data:0000005e Nint.1756
                            *COM*:00000007 RxNameLength
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2466   .data:00000065 SIGN.1757
                            *COM*:00000002 disp_delay_cnt
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2477   .progmem.data:00000049 __c.1772
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2481   .progmem.data:0000004c __c.1774
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2362   .progmem.data:00000000 opening_message
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2355   .data:0000004c lcd_update
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2442   .data:00000056 chg_index
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2485   .progmem.data:0000006d eq_grad.1753
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2495   .progmem.data:0000007b eq_intercept.1754
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2340   .bss:00000001 disp_cnt_last
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2373   .progmem.data:00000015 opening_message_0
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2368   .progmem.data:00000004 opening_message_1
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2419   .progmem.data:00000046 RxName_0
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2414   .progmem.data:00000043 RxName_1
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2409   .progmem.data:00000040 RxName_2
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2404   .progmem.data:0000003d RxName_3
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2399   .progmem.data:0000003a RxName_4
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2394   .progmem.data:00000037 RxName_5
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2389   .progmem.data:00000034 RxName_6
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccbnRlxX.s:2437   .data:00000054 chg_count

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
lcd_locate
lcd_set_str
USART_receive
LEDarray
send_bits_595_LED
strcpy_P
SoftSPI_Init
SoftSPI_LED_Init
lcd_init
USARTinit
ADC_init
ExtInterrupt_init
TachoMeter_init
BarMeter_init
__floatunsisf
__divsf3
__mulsf3
__fixunssfsi
USART_transmit_str
lcd_set_char
__floatsisf
__addsf3
TachoMeter
FuelPumpDriver
lcd_set_numeric
USART_transmit_numeric
