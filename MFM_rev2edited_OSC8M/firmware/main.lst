   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	set_initial_t_id
 107               	set_initial_t_id:
   1:main.c        **** //
   2:main.c        **** //             Multi Function Meter
   3:main.c        **** //                  Revision 1
   4:main.c        **** //
   5:main.c        **** //    Display data of Defi Link Unit 2 daisy chain
   6:main.c        **** //   "Measure Defi Link Unit 2 data interval freqency"
   7:main.c        **** //
   8:main.c        **** //      Display : SC2004
   9:main.c        **** //
  10:main.c        **** 
  11:main.c        **** #include <math.h>
  12:main.c        **** 
  13:main.c        **** #include <avr/io.h>
  14:main.c        **** #include <avr/interrupt.h>
  15:main.c        **** #include <util/delay.h>
  16:main.c        **** #include "lcd_595_softspi.h"
  17:main.c        **** #include "ExtInterrupt.h"
  18:main.c        **** #include "usart.h"
  19:main.c        **** 
  20:main.c        **** // MCU clock speed (for USART & Tacho)
  21:main.c        **** #define FOSC			8000000 // Clock Speed
  22:main.c        **** 
  23:main.c        **** // USART transmission speed definition
  24:main.c        **** #define BAUD			19200
  25:main.c        **** #define UBRR			FOSC/16/BAUD-1
  26:main.c        **** 
  27:main.c        **** // Number of Display data
  28:main.c        **** #define Ndata           4
  29:main.c        **** 
  30:main.c        **** // Wait time interval
  31:main.c        **** #define	WAIT			10 // unit : ms
  32:main.c        **** 
  33:main.c        **** // LCD width
  34:main.c        **** #define LCD_W           20
  35:main.c        **** 
  36:main.c        **** // Display character width of Defi Link Tap "name + data"
  37:main.c        **** #define DISP_W          11
  38:main.c        **** 
  39:main.c        **** // Median Filter for Tacho Meter
  40:main.c        **** #define Nmed            9
  41:main.c        **** 
  42:main.c        **** uint8_t     chg_index   = Ndata;
  43:main.c        **** uint16_t    chg_count   = 0xffff;
  44:main.c        **** 
  45:main.c        **** uint8_t   RxID[] = {
  46:main.c        ****         0x01,	// Turbo
  47:main.c        ****         0x02,	// Tacho
  48:main.c        ****         0x03,	// Oil pres.
  49:main.c        ****         0x04,	// Fuel pres.
  50:main.c        ****         0x05,	// Ext. Temp.
  51:main.c        ****         0x07,	// Oil Temp.
  52:main.c        ****         0x0f	// Water Temp.
  53:main.c        **** };
  54:main.c        **** 
  55:main.c        **** // Measure Tarfet ID Declarations
  56:main.c        **** uint8_t     t_id[Ndata];
  57:main.c        **** void set_initial_t_id(){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  58:main.c        ****     t_id[0] = 6;
 116               	.LM1:
 117 0000 86E0      		ldi r24,lo8(6)
 118 0002 8093 0000 		sts t_id,r24
  59:main.c        ****     t_id[1] = 5;
 120               	.LM2:
 121 0006 85E0      		ldi r24,lo8(5)
 122 0008 8093 0000 		sts t_id+1,r24
  60:main.c        ****     t_id[2] = 3;
 124               	.LM3:
 125 000c 83E0      		ldi r24,lo8(3)
 126 000e 8093 0000 		sts t_id+2,r24
  61:main.c        ****     t_id[3] = 0;
 128               	.LM4:
 129 0012 1092 0000 		sts t_id+3,__zero_reg__
 130               	/* epilogue start */
  62:main.c        **** }
 132               	.LM5:
 133 0016 0895      		ret
 135               	.Lscope1:
 137               	.global	timer1_init
 139               	timer1_init:
  63:main.c        **** 
  64:main.c        **** uint8_t*    RxName[7];
  65:main.c        **** uint8_t*    RxName_short[7];
  66:main.c        **** uint8_t*    RxName_long[7];
  67:main.c        **** 
  68:main.c        **** uint8_t     RxNameLength[7];
  69:main.c        **** 
  70:main.c        **** uint8_t     lcd_update  = 1;		// if bit is "1" then Re-draw LCD
  71:main.c        **** 
  72:main.c        **** unsigned char	data[Ndata][4];     // Recive byte data of packet for processing
  73:main.c        **** //	data[*][0] : Control
  74:main.c        **** //	data[*][1] : Angle Data (MSB)
  75:main.c        **** //	data[*][2] : Angle Data
  76:main.c        **** //	data[*][3] : Angle Data (LSB)
  77:main.c        **** 
  78:main.c        **** // Tacho Meter Variables Declaration
  79:main.c        **** unsigned long int   cnt;
  80:main.c        **** double              freq;
  81:main.c        **** unsigned long int   minv = 0xffff; // debug
  82:main.c        **** unsigned long int   maxv = 0x0000; // debug
  83:main.c        **** unsigned long int   rpm;
  84:main.c        **** unsigned long int   meas_array[Nmed];
  85:main.c        **** unsigned long int   proc_array[Nmed];
  86:main.c        **** unsigned int        tacho_n = 0;
  87:main.c        **** 
  88:main.c        **** // 16-bit Counter intialazation
  89:main.c        **** void timer1_init() {
 141               	.LM6:
 142               	.LFBB2:
 143               	/* prologue: function */
 144               	/* frame size = 0 */
 145               	/* stack size = 0 */
 146               	.L__stack_usage = 0
  90:main.c        **** 	TCCR1A  = 0b00000000;	// Timer/Counter1 Control Register A
 148               	.LM7:
 149 0018 1092 8000 		sts 128,__zero_reg__
  91:main.c        **** 	TCCR1B  = 0b00000011;
 151               	.LM8:
 152 001c 83E0      		ldi r24,lo8(3)
 153 001e 8093 8100 		sts 129,r24
  92:main.c        **** 	TCCR1C  = 0b00000000;
 155               	.LM9:
 156 0022 1092 8200 		sts 130,__zero_reg__
  93:main.c        **** 	TIMSK1  = 0b00000001;
 158               	.LM10:
 159 0026 81E0      		ldi r24,lo8(1)
 160 0028 8093 6F00 		sts 111,r24
  94:main.c        **** 	TCNT1   = 0x0000;         // Initialize 16-bit counter bit
 162               	.LM11:
 163 002c 1092 8500 		sts 132+1,__zero_reg__
 164 0030 1092 8400 		sts 132,__zero_reg__
  95:main.c        **** 	OCR1A   = 0xffff;         // 16-bit register for compare
 166               	.LM12:
 167 0034 8FEF      		ldi r24,lo8(-1)
 168 0036 9FEF      		ldi r25,hi8(-1)
 169 0038 9093 8900 		sts 136+1,r25
 170 003c 8093 8800 		sts 136,r24
 171               	/* epilogue start */
  96:main.c        **** }
 173               	.LM13:
 174 0040 0895      		ret
 176               	.Lscope2:
 178               	.global	PWM_init
 180               	PWM_init:
  97:main.c        **** 
  98:main.c        **** // 8-bit PWM timer intialazation
  99:main.c        **** void PWM_init() {
 182               	.LM14:
 183               	.LFBB3:
 184               	/* prologue: function */
 185               	/* frame size = 0 */
 186               	/* stack size = 0 */
 187               	.L__stack_usage = 0
 100:main.c        **** 	TCCR0A  = 0b10100001;	// Timer/Counter1 Control Register A
 189               	.LM15:
 190 0042 81EA      		ldi r24,lo8(-95)
 191 0044 84BD      		out 68-32,r24
 101:main.c        **** 	TCCR0B  = 0b00000010;
 193               	.LM16:
 194 0046 82E0      		ldi r24,lo8(2)
 195 0048 85BD      		out 69-32,r24
 102:main.c        **** 	TIMSK0  = 0b00000000;
 197               	.LM17:
 198 004a 1092 6E00 		sts 110,__zero_reg__
 103:main.c        **** 	TCNT0   = 0x00;         // Initialize 8-bit counter bit
 200               	.LM18:
 201 004e 16BC      		out 70-32,__zero_reg__
 104:main.c        **** 	OCR0A   = 0x80;         // 8-bit register for compare
 203               	.LM19:
 204 0050 80E8      		ldi r24,lo8(-128)
 205 0052 87BD      		out 71-32,r24
 206               	/* epilogue start */
 105:main.c        **** }
 208               	.LM20:
 209 0054 0895      		ret
 211               	.Lscope3:
 214               	.global	StrLength
 216               	StrLength:
 106:main.c        **** 
 107:main.c        **** // Count character length
 108:main.c        **** int StrLength(const char *s){
 218               	.LM21:
 219               	.LFBB4:
 220               	/* prologue: function */
 221               	/* frame size = 0 */
 222               	/* stack size = 0 */
 223               	.L__stack_usage = 0
 224 0056 FC01      		movw r30,r24
 109:main.c        ****     int n = 0;
 226               	.LM22:
 227 0058 20E0      		ldi r18,lo8(0)
 228 005a 30E0      		ldi r19,hi8(0)
 110:main.c        ****     while (*s++ != '\0')
 230               	.LM23:
 231 005c 00C0      		rjmp .L5
 232               	.L6:
 111:main.c        ****         n++;
 234               	.LM24:
 235 005e 2F5F      		subi r18,lo8(-(1))
 236 0060 3F4F      		sbci r19,hi8(-(1))
 237               	.L5:
 110:main.c        ****     while (*s++ != '\0')
 239               	.LM25:
 240 0062 8191      		ld r24,Z+
 241 0064 8823      		tst r24
 242 0066 01F4      		brne .L6
 112:main.c        ****     return (n);
 113:main.c        **** }
 244               	.LM26:
 245 0068 C901      		movw r24,r18
 246               	/* epilogue start */
 247 006a 0895      		ret
 252               	.Lscope4:
 254               	.global	BubbleSort
 256               	BubbleSort:
 114:main.c        **** 
 115:main.c        **** // Bubble Sort (min->max)
 116:main.c        **** void BubbleSort(){
 258               	.LM27:
 259               	.LFBB5:
 260 006c AF92      		push r10
 261 006e BF92      		push r11
 262 0070 CF92      		push r12
 263 0072 DF92      		push r13
 264 0074 EF92      		push r14
 265 0076 FF92      		push r15
 266 0078 0F93      		push r16
 267 007a 1F93      		push r17
 268 007c CF93      		push r28
 269 007e DF93      		push r29
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272               	/* stack size = 10 */
 273               	.L__stack_usage = 10
 117:main.c        **** 	unsigned int tmp;
 118:main.c        **** 	unsigned int min;
 119:main.c        **** 	unsigned int min_index;
 120:main.c        **** 	unsigned int n,m;
 121:main.c        **** 	
 122:main.c        **** 	for(m=0;m<Nmed;m++){
 275               	.LM28:
 276 0080 90E0      		ldi r25,lo8(proc_array)
 277 0082 E92E      		mov r14,r25
 278 0084 90E0      		ldi r25,hi8(proc_array)
 279 0086 F92E      		mov r15,r25
 280 0088 CC24      		clr r12
 281 008a DD24      		clr r13
 282 008c 00C0      		rjmp .L8
 283               	.L10:
 116:main.c        **** void BubbleSort(){
 285               	.LM29:
 286 008e F701      		movw r30,r14
 287 0090 EC0F      		add r30,r28
 288 0092 FD1F      		adc r31,r29
 123:main.c        **** 		min = 0xffffffff;
 124:main.c        **** 		for(n=m;n<Nmed;n++){
 125:main.c        **** 			if( proc_array[n] < min ){
 290               	.LM30:
 291 0094 8081      		ld r24,Z
 292 0096 9181      		ldd r25,Z+1
 293 0098 A281      		ldd r26,Z+2
 294 009a B381      		ldd r27,Z+3
 295 009c A801      		movw r20,r16
 296 009e 60E0      		ldi r22,lo8(0)
 297 00a0 70E0      		ldi r23,hi8(0)
 298 00a2 8417      		cp r24,r20
 299 00a4 9507      		cpc r25,r21
 300 00a6 A607      		cpc r26,r22
 301 00a8 B707      		cpc r27,r23
 302 00aa 00F4      		brsh .L9
 126:main.c        **** 				min = proc_array[n];
 304               	.LM31:
 305 00ac 8C01      		movw r16,r24
 306 00ae 5901      		movw r10,r18
 307               	.L9:
 124:main.c        **** 		for(n=m;n<Nmed;n++){
 309               	.LM32:
 310 00b0 2F5F      		subi r18,lo8(-(1))
 311 00b2 3F4F      		sbci r19,hi8(-(1))
 312 00b4 2496      		adiw r28,4
 313 00b6 2930      		cpi r18,9
 314 00b8 3105      		cpc r19,__zero_reg__
 315 00ba 01F4      		brne .L10
 316 00bc F501      		movw r30,r10
 127:main.c        **** 				min_index = n;
 128:main.c        **** 			}
 129:main.c        **** 		}
 130:main.c        **** 		tmp                     = proc_array[m];
 318               	.LM33:
 319 00be D701      		movw r26,r14
 320 00c0 2D91      		ld r18,X+
 321 00c2 3C91      		ld r19,X
 131:main.c        **** 		proc_array[m]           = proc_array[min_index];
 323               	.LM34:
 324 00c4 EE0F      		lsl r30
 325 00c6 FF1F      		rol r31
 326 00c8 EE0F      		lsl r30
 327 00ca FF1F      		rol r31
 328 00cc E050      		subi r30,lo8(-(proc_array))
 329 00ce F040      		sbci r31,hi8(-(proc_array))
 330 00d0 8081      		ld r24,Z
 331 00d2 9181      		ldd r25,Z+1
 332 00d4 A281      		ldd r26,Z+2
 333 00d6 B381      		ldd r27,Z+3
 334 00d8 E701      		movw r28,r14
 335 00da 8993      		st Y+,r24
 336 00dc 9993      		st Y+,r25
 337 00de A993      		st Y+,r26
 338 00e0 B993      		st Y+,r27
 339 00e2 7E01      		movw r14,r28
 132:main.c        **** 		proc_array[min_index]   = tmp;
 341               	.LM35:
 342 00e4 C901      		movw r24,r18
 343 00e6 A0E0      		ldi r26,lo8(0)
 344 00e8 B0E0      		ldi r27,hi8(0)
 345 00ea 8083      		st Z,r24
 346 00ec 9183      		std Z+1,r25
 347 00ee A283      		std Z+2,r26
 348 00f0 B383      		std Z+3,r27
 122:main.c        **** 	for(m=0;m<Nmed;m++){
 350               	.LM36:
 351 00f2 0894      		sec
 352 00f4 C11C      		adc r12,__zero_reg__
 353 00f6 D11C      		adc r13,__zero_reg__
 354 00f8 D9E0      		ldi r29,lo8(9)
 355 00fa CD16      		cp r12,r29
 356 00fc D104      		cpc r13,__zero_reg__
 357 00fe 01F0      		breq .L7
 358               	.L8:
 116:main.c        **** void BubbleSort(){
 360               	.LM37:
 361 0100 9601      		movw r18,r12
 362 0102 C0E0      		ldi r28,lo8(0)
 363 0104 D0E0      		ldi r29,hi8(0)
 364 0106 0FEF      		ldi r16,lo8(-1)
 365 0108 1FEF      		ldi r17,hi8(-1)
 366 010a 00C0      		rjmp .L10
 367               	.L7:
 368               	/* epilogue start */
 133:main.c        **** 	}
 134:main.c        **** }
 370               	.LM38:
 371 010c DF91      		pop r29
 372 010e CF91      		pop r28
 373 0110 1F91      		pop r17
 374 0112 0F91      		pop r16
 375 0114 FF90      		pop r15
 376 0116 EF90      		pop r14
 377 0118 DF90      		pop r13
 378 011a CF90      		pop r12
 379 011c BF90      		pop r11
 380 011e AF90      		pop r10
 381 0120 0895      		ret
 388               	.Lscope5:
 390               	.global	DisplayItemInfo
 392               	DisplayItemInfo:
 135:main.c        **** 
 136:main.c        **** // Display
 137:main.c        **** void DisplayItemInfo(void){
 394               	.LM39:
 395               	.LFBB6:
 396 0122 1F93      		push r17
 397 0124 CF93      		push r28
 398 0126 DF93      		push r29
 399               	/* prologue: function */
 400               	/* frame size = 0 */
 401               	/* stack size = 3 */
 402               	.L__stack_usage = 3
 404               	.LM40:
 405 0128 C0E0      		ldi r28,lo8(t_id)
 406 012a D0E0      		ldi r29,hi8(t_id)
 407 012c 10E0      		ldi r17,lo8(0)
 408               	.L14:
 138:main.c        **** 	int k=0;
 139:main.c        **** 	for(k=0;k<Ndata;k++){
 140:main.c        **** 		lcd_locate(k,0);
 410               	.LM41:
 411 012e 812F      		mov r24,r17
 412 0130 60E0      		ldi r22,lo8(0)
 413 0132 00D0      		rcall lcd_locate
 141:main.c        **** 		lcd_set_str((unsigned char*)RxName[t_id[k]]);
 415               	.LM42:
 416 0134 E991      		ld r30,Y+
 417 0136 F0E0      		ldi r31,lo8(0)
 418 0138 EE0F      		lsl r30
 419 013a FF1F      		rol r31
 420 013c E050      		subi r30,lo8(-(RxName))
 421 013e F040      		sbci r31,hi8(-(RxName))
 422 0140 8081      		ld r24,Z
 423 0142 9181      		ldd r25,Z+1
 424 0144 00D0      		rcall lcd_set_str
 425 0146 1F5F      		subi r17,lo8(-(1))
 139:main.c        **** 	for(k=0;k<Ndata;k++){
 427               	.LM43:
 428 0148 1430      		cpi r17,lo8(4)
 429 014a 01F4      		brne .L14
 430               	/* epilogue start */
 142:main.c        **** 	}
 143:main.c        **** 	
 144:main.c        **** }
 432               	.LM44:
 433 014c DF91      		pop r29
 434 014e CF91      		pop r28
 435 0150 1F91      		pop r17
 436 0152 0895      		ret
 438               	.Lscope6:
 440               	.global	__vector_18
 442               	__vector_18:
 145:main.c        **** 
 146:main.c        **** ISR(USART_RX_vect){
 444               	.LM45:
 445               	.LFBB7:
 446 0154 1F92      		push r1
 447 0156 0F92      		push r0
 448 0158 0FB6      		in r0,__SREG__
 449 015a 0F92      		push r0
 450 015c 1124      		clr __zero_reg__
 451 015e 0F93      		push r16
 452 0160 1F93      		push r17
 453 0162 2F93      		push r18
 454 0164 3F93      		push r19
 455 0166 4F93      		push r20
 456 0168 5F93      		push r21
 457 016a 6F93      		push r22
 458 016c 7F93      		push r23
 459 016e 8F93      		push r24
 460 0170 9F93      		push r25
 461 0172 AF93      		push r26
 462 0174 BF93      		push r27
 463 0176 CF93      		push r28
 464 0178 DF93      		push r29
 465 017a EF93      		push r30
 466 017c FF93      		push r31
 467               	/* prologue: Signal */
 468               	/* frame size = 0 */
 469               	/* stack size = 19 */
 470               	.L__stack_usage = 19
 147:main.c        ****     unsigned int    ID;
 148:main.c        ****     unsigned int    n, m;
 149:main.c        **** 
 150:main.c        ****     ID = USART_receive(); // Synchronize & Detect receiver ID
 472               	.LM46:
 473 017e 00D0      		rcall USART_receive
 474 0180 282F      		mov r18,r24
 475 0182 30E0      		ldi r19,lo8(0)
 476 0184 A0E0      		ldi r26,lo8(t_id)
 477 0186 B0E0      		ldi r27,hi8(t_id)
 151:main.c        ****     // Get 3-bit sngle data
 152:main.c        ****     for(n=0;n<Ndata;n++){
 479               	.LM47:
 480 0188 C0E0      		ldi r28,lo8(0)
 481 018a D0E0      		ldi r29,hi8(0)
 482               	.L20:
 153:main.c        ****         if ( ID == RxID[t_id[n]] ){
 484               	.LM48:
 485 018c ED91      		ld r30,X+
 486 018e F0E0      		ldi r31,lo8(0)
 487 0190 E050      		subi r30,lo8(-(RxID))
 488 0192 F040      		sbci r31,hi8(-(RxID))
 489 0194 8081      		ld r24,Z
 490 0196 90E0      		ldi r25,lo8(0)
 491 0198 2817      		cp r18,r24
 492 019a 3907      		cpc r19,r25
 493 019c 01F4      		brne .L17
 494 019e 00E0      		ldi r16,lo8(0)
 495 01a0 10E0      		ldi r17,hi8(0)
 146:main.c        **** ISR(USART_RX_vect){
 497               	.LM49:
 498 01a2 CC0F      		lsl r28
 499 01a4 DD1F      		rol r29
 500 01a6 CC0F      		lsl r28
 501 01a8 DD1F      		rol r29
 502 01aa C050      		subi r28,lo8(-(data))
 503 01ac D040      		sbci r29,hi8(-(data))
 504               	.L18:
 154:main.c        ****             for(m=0;m<4;m++) data[n][m] = USART_receive();
 506               	.LM50:
 507 01ae 00D0      		rcall USART_receive
 146:main.c        **** ISR(USART_RX_vect){
 509               	.LM51:
 510 01b0 FE01      		movw r30,r28
 511 01b2 E00F      		add r30,r16
 512 01b4 F11F      		adc r31,r17
 514               	.LM52:
 515 01b6 8083      		st Z,r24
 516 01b8 0F5F      		subi r16,lo8(-(1))
 517 01ba 1F4F      		sbci r17,hi8(-(1))
 518 01bc 0430      		cpi r16,4
 519 01be 1105      		cpc r17,__zero_reg__
 520 01c0 01F4      		brne .L18
 521 01c2 00C0      		rjmp .L16
 522               	.L17:
 152:main.c        ****     for(n=0;n<Ndata;n++){
 524               	.LM53:
 525 01c4 2196      		adiw r28,1
 526 01c6 C430      		cpi r28,4
 527 01c8 D105      		cpc r29,__zero_reg__
 528 01ca 01F4      		brne .L20
 529               	.L16:
 530               	/* epilogue start */
 155:main.c        ****             break;
 156:main.c        ****         }
 157:main.c        ****     }
 158:main.c        **** }
 532               	.LM54:
 533 01cc FF91      		pop r31
 534 01ce EF91      		pop r30
 535 01d0 DF91      		pop r29
 536 01d2 CF91      		pop r28
 537 01d4 BF91      		pop r27
 538 01d6 AF91      		pop r26
 539 01d8 9F91      		pop r25
 540 01da 8F91      		pop r24
 541 01dc 7F91      		pop r23
 542 01de 6F91      		pop r22
 543 01e0 5F91      		pop r21
 544 01e2 4F91      		pop r20
 545 01e4 3F91      		pop r19
 546 01e6 2F91      		pop r18
 547 01e8 1F91      		pop r17
 548 01ea 0F91      		pop r16
 549 01ec 0F90      		pop r0
 550 01ee 0FBE      		out __SREG__,r0
 551 01f0 0F90      		pop r0
 552 01f2 1F90      		pop r1
 553 01f4 1895      		reti
 560               	.Lscope7:
 562               	.global	__vector_1
 564               	__vector_1:
 159:main.c        **** 
 160:main.c        **** ISR(INT0_vect){
 566               	.LM55:
 567               	.LFBB8:
 568 01f6 1F92      		push r1
 569 01f8 0F92      		push r0
 570 01fa 0FB6      		in r0,__SREG__
 571 01fc 0F92      		push r0
 572 01fe 1124      		clr __zero_reg__
 573 0200 4F93      		push r20
 574 0202 5F93      		push r21
 575 0204 6F93      		push r22
 576 0206 7F93      		push r23
 577 0208 8F93      		push r24
 578 020a 9F93      		push r25
 579 020c EF93      		push r30
 580 020e FF93      		push r31
 581               	/* prologue: Signal */
 582               	/* frame size = 0 */
 583               	/* stack size = 11 */
 584               	.L__stack_usage = 11
 161:main.c        ****     meas_array[tacho_n] = TCNT1;
 586               	.LM56:
 587 0210 8091 0000 		lds r24,tacho_n
 588 0214 9091 0000 		lds r25,tacho_n+1
 589 0218 4091 8400 		lds r20,132
 590 021c 5091 8500 		lds r21,132+1
 591 0220 FC01      		movw r30,r24
 592 0222 EE0F      		lsl r30
 593 0224 FF1F      		rol r31
 594 0226 EE0F      		lsl r30
 595 0228 FF1F      		rol r31
 596 022a E050      		subi r30,lo8(-(meas_array))
 597 022c F040      		sbci r31,hi8(-(meas_array))
 598 022e 60E0      		ldi r22,lo8(0)
 599 0230 70E0      		ldi r23,hi8(0)
 600 0232 4083      		st Z,r20
 601 0234 5183      		std Z+1,r21
 602 0236 6283      		std Z+2,r22
 603 0238 7383      		std Z+3,r23
 162:main.c        ****     if( tacho_n == Nmed-1 ) tacho_n=0;
 605               	.LM57:
 606 023a 8830      		cpi r24,8
 607 023c 9105      		cpc r25,__zero_reg__
 608 023e 01F4      		brne .L24
 610               	.LM58:
 611 0240 1092 0000 		sts tacho_n+1,__zero_reg__
 612 0244 1092 0000 		sts tacho_n,__zero_reg__
 613 0248 00C0      		rjmp .L25
 614               	.L24:
 163:main.c        ****     else                    tacho_n++;
 616               	.LM59:
 617 024a 0196      		adiw r24,1
 618 024c 9093 0000 		sts tacho_n+1,r25
 619 0250 8093 0000 		sts tacho_n,r24
 620               	.L25:
 164:main.c        ****     TCNT1 = 0;
 622               	.LM60:
 623 0254 1092 8500 		sts 132+1,__zero_reg__
 624 0258 1092 8400 		sts 132,__zero_reg__
 625               	/* epilogue start */
 165:main.c        **** }
 627               	.LM61:
 628 025c FF91      		pop r31
 629 025e EF91      		pop r30
 630 0260 9F91      		pop r25
 631 0262 8F91      		pop r24
 632 0264 7F91      		pop r23
 633 0266 6F91      		pop r22
 634 0268 5F91      		pop r21
 635 026a 4F91      		pop r20
 636 026c 0F90      		pop r0
 637 026e 0FBE      		out __SREG__,r0
 638 0270 0F90      		pop r0
 639 0272 1F90      		pop r1
 640 0274 1895      		reti
 642               	.Lscope8:
 644               	.global	__vector_13
 646               	__vector_13:
 166:main.c        **** 
 167:main.c        **** // 16-bit Timer overflow
 168:main.c        **** ISR(TIMER1_OVF_vect){
 648               	.LM62:
 649               	.LFBB9:
 650 0276 1F92      		push r1
 651 0278 0F92      		push r0
 652 027a 0FB6      		in r0,__SREG__
 653 027c 0F92      		push r0
 654 027e 1124      		clr __zero_reg__
 655 0280 4F93      		push r20
 656 0282 5F93      		push r21
 657 0284 6F93      		push r22
 658 0286 7F93      		push r23
 659 0288 8F93      		push r24
 660 028a 9F93      		push r25
 661 028c EF93      		push r30
 662 028e FF93      		push r31
 663               	/* prologue: Signal */
 664               	/* frame size = 0 */
 665               	/* stack size = 11 */
 666               	.L__stack_usage = 11
 169:main.c        ****     meas_array[tacho_n] = 0xffffffff;
 668               	.LM63:
 669 0290 8091 0000 		lds r24,tacho_n
 670 0294 9091 0000 		lds r25,tacho_n+1
 671 0298 FC01      		movw r30,r24
 672 029a EE0F      		lsl r30
 673 029c FF1F      		rol r31
 674 029e EE0F      		lsl r30
 675 02a0 FF1F      		rol r31
 676 02a2 E050      		subi r30,lo8(-(meas_array))
 677 02a4 F040      		sbci r31,hi8(-(meas_array))
 678 02a6 4FEF      		ldi r20,lo8(-1)
 679 02a8 5FEF      		ldi r21,hi8(-1)
 680 02aa BA01      		movw r22,r20
 681 02ac 4083      		st Z,r20
 682 02ae 5183      		std Z+1,r21
 683 02b0 6283      		std Z+2,r22
 684 02b2 7383      		std Z+3,r23
 170:main.c        ****     if( tacho_n == Nmed-1 ) tacho_n=0;
 686               	.LM64:
 687 02b4 8830      		cpi r24,8
 688 02b6 9105      		cpc r25,__zero_reg__
 689 02b8 01F4      		brne .L27
 691               	.LM65:
 692 02ba 1092 0000 		sts tacho_n+1,__zero_reg__
 693 02be 1092 0000 		sts tacho_n,__zero_reg__
 694 02c2 00C0      		rjmp .L28
 695               	.L27:
 171:main.c        ****     else                    tacho_n++;
 697               	.LM66:
 698 02c4 0196      		adiw r24,1
 699 02c6 9093 0000 		sts tacho_n+1,r25
 700 02ca 8093 0000 		sts tacho_n,r24
 701               	.L28:
 172:main.c        ****     TCNT1 = 0;
 703               	.LM67:
 704 02ce 1092 8500 		sts 132+1,__zero_reg__
 705 02d2 1092 8400 		sts 132,__zero_reg__
 706               	/* epilogue start */
 173:main.c        **** }
 708               	.LM68:
 709 02d6 FF91      		pop r31
 710 02d8 EF91      		pop r30
 711 02da 9F91      		pop r25
 712 02dc 8F91      		pop r24
 713 02de 7F91      		pop r23
 714 02e0 6F91      		pop r22
 715 02e2 5F91      		pop r21
 716 02e4 4F91      		pop r20
 717 02e6 0F90      		pop r0
 718 02e8 0FBE      		out __SREG__,r0
 719 02ea 0F90      		pop r0
 720 02ec 1F90      		pop r1
 721 02ee 1895      		reti
 723               	.Lscope9:
 724               		.data
 725               	.LC4:
 726 0000 4241 4449 		.string	"BADISR ERROR"
 726      5352 2045 
 726      5252 4F52 
 726      00
 727               		.text
 729               	.global	__vector_default
 731               	__vector_default:
 174:main.c        **** 
 175:main.c        **** // Bad ISR interrput detector for debugging
 176:main.c        **** ISR(BADISR_vect){
 733               	.LM69:
 734               	.LFBB10:
 735 02f0 1F92      		push r1
 736 02f2 0F92      		push r0
 737 02f4 0FB6      		in r0,__SREG__
 738 02f6 0F92      		push r0
 739 02f8 1124      		clr __zero_reg__
 740               	/* prologue: Signal */
 741               	/* frame size = 0 */
 742               	/* stack size = 3 */
 743               	.L__stack_usage = 3
 177:main.c        ****     cli();    // これ以上割り込ませない
 745               	.LM70:
 746               	/* #APP */
 747               	 ;  177 "main.c" 1
 748 02fa F894      		cli
 749               	 ;  0 "" 2
 178:main.c        ****     lcd_locate(0,0);
 751               	.LM71:
 752               	/* #NOAPP */
 753 02fc 80E0      		ldi r24,lo8(0)
 754 02fe 60E0      		ldi r22,lo8(0)
 755 0300 00D0      		rcall lcd_locate
 179:main.c        ****     lcd_set_str("BADISR ERROR");
 757               	.LM72:
 758 0302 80E0      		ldi r24,lo8(.LC4)
 759 0304 90E0      		ldi r25,hi8(.LC4)
 760 0306 00D0      		rcall lcd_set_str
 761               	.L30:
 762 0308 00C0      		rjmp .L30
 764               	.Lscope10:
 765               		.data
 766               	.LC5:
 767 000d 2020 2020 		.string	"    w/FPD  Rev.2    "
 767      772F 4650 
 767      4420 2052 
 767      6576 2E32 
 767      2020 2020 
 768               	.LC6:
 769 0022 4D75 6C74 		.string	"Multi-Function Meter"
 769      692D 4675 
 769      6E63 7469 
 769      6F6E 204D 
 769      6574 6572 
 770               	.LC7:
 771 0037 426F 6F73 		.string	"Boost"
 771      7400 
 772               	.LC8:
 773 003d 5461 6368 		.string	"Tacho"
 773      6F00 
 774               	.LC9:
 775 0043 4F69 6C2E 		.string	"Oil.P"
 775      5000 
 776               	.LC10:
 777 0049 4675 656C 		.string	"Fuel.P"
 777      2E50 00
 778               	.LC11:
 779 0050 4578 546D 		.string	"ExTmp"
 779      7000 
 780               	.LC12:
 781 0056 4F69 6C2E 		.string	"Oil.T"
 781      5400 
 782               	.LC13:
 783 005c 5761 7465 		.string	"Water.T"
 783      722E 5400 
 784               	.LC14:
 785 0064 4253 00   		.string	"BS"
 786               	.LC15:
 787 0067 5443 00   		.string	"TC"
 788               	.LC16:
 789 006a 4F50 00   		.string	"OP"
 790               	.LC17:
 791 006d 4650 00   		.string	"FP"
 792               	.LC18:
 793 0070 4554 00   		.string	"ET"
 794               	.LC19:
 795 0073 4F54 00   		.string	"OT"
 796               	.LC20:
 797 0076 5754 00   		.string	"WT"
 798               	.LC21:
 799 0079 4F69 6C20 		.string	"Oil press"
 799      7072 6573 
 799      7300 
 800               	.LC22:
 801 0083 4675 656C 		.string	"Fuel press"
 801      2070 7265 
 801      7373 00
 802               	.LC23:
 803 008e 4578 742E 		.string	"Ext. Temp."
 803      2054 656D 
 803      702E 00
 804               	.LC24:
 805 0099 4F69 6C20 		.string	"Oil Temp."
 805      5465 6D70 
 805      2E00 
 806               	.LC25:
 807 00a3 5761 7465 		.string	"Water Temp."
 807      7220 5465 
 807      6D70 2E00 
 808               	.LC26:
 809 00af 7270 6D00 		.string	"rpm"
 810               	.LC0:
 811 00b3 0300      		.word	3
 812 00b5 2823      		.word	9000
 813 00b7 0A00      		.word	10
 814 00b9 0600      		.word	6
 815 00bb 8403      		.word	900
 816 00bd 6400      		.word	100
 817 00bf 6400      		.word	100
 818               	.LC1:
 819 00c1 FFFF      		.word	-1
 820 00c3 0000      		.word	0
 821 00c5 0000      		.word	0
 822 00c7 0000      		.word	0
 823 00c9 C800      		.word	200
 824 00cb 3200      		.word	50
 825 00cd 1400      		.word	20
 826               	.LC2:
 827 00cf 03        		.byte	3
 828 00d0 04        		.byte	4
 829 00d1 03        		.byte	3
 830 00d2 03        		.byte	3
 831 00d3 04        		.byte	4
 832 00d4 03        		.byte	3
 833 00d5 03        		.byte	3
 834               	.LC3:
 835 00d6 01        		.byte	1
 836 00d7 04        		.byte	4
 837 00d8 02        		.byte	2
 838 00d9 01        		.byte	1
 839 00da 04        		.byte	4
 840 00db 03        		.byte	3
 841 00dc 03        		.byte	3
 842               		.section	.text.startup,"ax",@progbits
 844               	.global	main
 846               	main:
 180:main.c        ****     while(1);  // ここで止めておく
 181:main.c        **** }
 182:main.c        **** 
 183:main.c        **** int main(void)
 184:main.c        **** {
 848               	.LM73:
 849               	.LFBB11:
 850 0000 CF93      		push r28
 851 0002 DF93      		push r29
 852 0004 CDB7      		in r28,__SP_L__
 853 0006 DEB7      		in r29,__SP_H__
 854 0008 EE97      		sbiw r28,62
 855 000a 0FB6      		in __tmp_reg__,__SREG__
 856 000c F894      		cli
 857 000e DEBF      		out __SP_H__,r29
 858 0010 0FBE      		out __SREG__,__tmp_reg__
 859 0012 CDBF      		out __SP_L__,r28
 860               	/* prologue: function */
 861               	/* frame size = 62 */
 862               	/* stack size = 64 */
 863               	.L__stack_usage = 64
 185:main.c        **** 
 186:main.c        ****     // for 74HC595 port setting
 187:main.c        ****     SoftSPI_Init();
 865               	.LM74:
 866 0014 00D0      		rcall SoftSPI_Init
 188:main.c        ****     
 189:main.c        ****     // Initialize LCD
 190:main.c        **** 	lcd_init();
 868               	.LM75:
 869 0016 00D0      		rcall lcd_init
 191:main.c        **** 	
 192:main.c        **** 
 193:main.c        ****     // Interval Measure
 194:main.c        ****     timer1_init();
 871               	.LM76:
 872 0018 00D0      		rcall timer1_init
 195:main.c        **** 
 196:main.c        **** 	// USART initialize
 197:main.c        **** 	USARTinit(UBRR);
 874               	.LM77:
 875 001a 89E1      		ldi r24,lo8(25)
 876 001c 90E0      		ldi r25,hi8(25)
 877 001e 00D0      		rcall USARTinit
 198:main.c        **** 	
 199:main.c        **** 	// Ext. Interupt setting
 200:main.c        **** 	ExtInterrupt_init();
 879               	.LM78:
 880 0020 00D0      		rcall ExtInterrupt_init
 201:main.c        ****     
 202:main.c        ****     // Bar-Meter Initialize
 203:main.c        ****     BarMeter_init();
 882               	.LM79:
 883 0022 00D0      		rcall BarMeter_init
 204:main.c        ****     
 205:main.c        ****     // PWM putput port definition
 206:main.c        ****     DDRD |= (1<<PD6);
 885               	.LM80:
 886 0024 569A      		sbi 42-32,6
 207:main.c        ****     
 208:main.c        ****     // PWM counter init
 209:main.c        ****     PWM_init();
 888               	.LM81:
 889 0026 00D0      		rcall PWM_init
 210:main.c        ****     
 211:main.c        ****     // Set Initial Target IDs
 212:main.c        ****     set_initial_t_id();
 891               	.LM82:
 892 0028 00D0      		rcall set_initial_t_id
 213:main.c        **** 
 214:main.c        **** 	// Declarations
 215:main.c        **** 	unsigned char*   opening_message0 = "Multi-Function Meter";
 216:main.c        ****     unsigned char*   opening_message1 = "    w/FPD  Rev.2    ";
 217:main.c        ****     
 218:main.c        **** 	uint8_t         n, m;					// 'for' loop variables
 219:main.c        ****     
 220:main.c        ****     uint8_t        FPDcomp = 0xff;
 221:main.c        ****     
 222:main.c        **** 	uint8_t         index = 0;				// LCD displaying data index
 223:main.c        **** 	
 224:main.c        **** 	uint16_t		maxv = 2352;			// maximum decimal angle data value from 'Defi Link Unit II'
 225:main.c        ****     
 226:main.c        **** 	uint8_t         id;						// ID index for processing
 227:main.c        ****     
 228:main.c        **** 	uint8_t         valid_packet;			// Validtity indicator
 229:main.c        **** 	
 230:main.c        **** 	uint8_t			low4bits[4];			// Extracted lower 4 bits from byte data
 231:main.c        **** 	uint16_t        dec_ang;				// Angle data (decimal)
 232:main.c        **** 	float           dec_nrm;				// Angle data (decimal)
 233:main.c        **** 	float			value;					// Decoded value
 234:main.c        **** 	uint8_t         value_sign;				// Sign of rounded value
 235:main.c        **** 	uint8_t         digits_int[5];			// Digits integer data
 236:main.c        **** 	unsigned char	digits_char[5];			// Digits character data for display
 237:main.c        ****     
 238:main.c        **** 	uint16_t         mult_factor[3];			// Multiplying factor for hexadecimal to decimal decoding
 239:main.c        **** 	float           div_factor;				// Dividing factor for integer
 240:main.c        **** 	uint8_t         digits_valid;			// Indicate digits in integer are valid or invalid
 241:main.c        ****     
 242:main.c        ****     // value = eq_grad * dec_nrm + eq_intercept
 243:main.c        ****     // Gradient-term of decoding equation
 244:main.c        **** 	uint16_t eq_grad[] = {
 894               	.LM83:
 895 002a DE01      		movw r26,r28
 896 002c 9E96      		adiw r26,46
 897 002e E0E0      		ldi r30,lo8(.LC0)
 898 0030 F0E0      		ldi r31,hi8(.LC0)
 899 0032 8EE0      		ldi r24,lo8(14)
 900               	.L32:
 901 0034 0190      		ld r0,Z+
 902 0036 0D92      		st X+,r0
 903 0038 8150      		subi r24,lo8(-(-1))
 904 003a 01F4      		brne .L32
 245:main.c        ****         3,	// Turbo
 246:main.c        ****         9000,	// Tacho
 247:main.c        ****         10,	// Oil pres.
 248:main.c        ****         6,	// Fuel pres.
 249:main.c        ****         900,	// Ext. Temp.
 250:main.c        ****         100,	// Oil Temp.
 251:main.c        ****         100	// Water Temp.
 252:main.c        ****     };
 253:main.c        ****     
 254:main.c        ****     // Intercept-term of decoding equation
 255:main.c        ****     int16_t eq_intercept[] = {
 906               	.LM84:
 907 003c DE01      		movw r26,r28
 908 003e 9096      		adiw r26,32
 909 0040 E0E0      		ldi r30,lo8(.LC1)
 910 0042 F0E0      		ldi r31,hi8(.LC1)
 911 0044 8EE0      		ldi r24,lo8(14)
 912               	.L33:
 913 0046 0190      		ld r0,Z+
 914 0048 0D92      		st X+,r0
 915 004a 8150      		subi r24,lo8(-(-1))
 916 004c 01F4      		brne .L33
 256:main.c        ****         -1,	// Turbo
 257:main.c        ****         0,	// Tacho
 258:main.c        ****         0,	// Oil pres.
 259:main.c        ****         0,	// Fuel pres.
 260:main.c        ****         200,	// Ext. Temp.
 261:main.c        ****         50,	// Oil Temp.
 262:main.c        ****         20	// Water Temp.
 263:main.c        ****     };
 264:main.c        ****     
 265:main.c        ****     // Definition of number of significant figure
 266:main.c        **** 	uint8_t   Nsig[] = {				// Number of significant figures
 918               	.LM85:
 919 004e DE01      		movw r26,r28
 920 0050 5996      		adiw r26,25
 921 0052 E0E0      		ldi r30,lo8(.LC2)
 922 0054 F0E0      		ldi r31,hi8(.LC2)
 923 0056 87E0      		ldi r24,lo8(7)
 924               	.L34:
 925 0058 0190      		ld r0,Z+
 926 005a 0D92      		st X+,r0
 927 005c 8150      		subi r24,lo8(-(-1))
 928 005e 01F4      		brne .L34
 267:main.c        ****         3,	// Turbo
 268:main.c        ****         4,	// Tacho
 269:main.c        ****         3,	// Oil pres.
 270:main.c        ****         3,	// Fuel pres.
 271:main.c        ****         4,	// Ext. Temp.
 272:main.c        ****         3,	// Oil Temp.
 273:main.c        ****         3	// Water Temp.
 274:main.c        ****     };
 275:main.c        ****     
 276:main.c        ****     // Deifinition of number of integer figure
 277:main.c        **** 	uint8_t	Nint[] = {				// Number of integr digits
 930               	.LM86:
 931 0060 DE01      		movw r26,r28
 932 0062 5296      		adiw r26,18
 933 0064 E0E0      		ldi r30,lo8(.LC3)
 934 0066 F0E0      		ldi r31,hi8(.LC3)
 935 0068 87E0      		ldi r24,lo8(7)
 936               	.L35:
 937 006a 0190      		ld r0,Z+
 938 006c 0D92      		st X+,r0
 939 006e 8150      		subi r24,lo8(-(-1))
 940 0070 01F4      		brne .L35
 278:main.c        ****         1,	// Turbo
 279:main.c        ****         4,	// Tacho
 280:main.c        ****         2,	// Oil pres.
 281:main.c        ****         1,	// Fuel pres.
 282:main.c        ****         4,	// Ext. Temp.
 283:main.c        ****         3,	// Oil Temp.
 284:main.c        ****         3	// Water Temp.
 285:main.c        ****     };
 286:main.c        ****     
 287:main.c        **** 	uint8_t	Nspace[7];				// Number of space between character and digits
 288:main.c        ****     float   Resolution[7];
 289:main.c        ****     
 290:main.c        **** 	RxName[0]		=   "Boost";
 942               	.LM87:
 943 0072 80E0      		ldi r24,lo8(.LC7)
 944 0074 90E0      		ldi r25,hi8(.LC7)
 945 0076 9093 0000 		sts RxName+1,r25
 946 007a 8093 0000 		sts RxName,r24
 291:main.c        **** 	RxName[1]		=   "Tacho";
 948               	.LM88:
 949 007e 20E0      		ldi r18,lo8(.LC8)
 950 0080 30E0      		ldi r19,hi8(.LC8)
 951 0082 3093 0000 		sts RxName+2+1,r19
 952 0086 2093 0000 		sts RxName+2,r18
 292:main.c        **** 	RxName[2]		=   "Oil.P";
 954               	.LM89:
 955 008a 40E0      		ldi r20,lo8(.LC9)
 956 008c 50E0      		ldi r21,hi8(.LC9)
 957 008e 5093 0000 		sts RxName+4+1,r21
 958 0092 4093 0000 		sts RxName+4,r20
 293:main.c        **** 	RxName[3]		=   "Fuel.P";
 960               	.LM90:
 961 0096 40E0      		ldi r20,lo8(.LC10)
 962 0098 50E0      		ldi r21,hi8(.LC10)
 963 009a 5093 0000 		sts RxName+6+1,r21
 964 009e 4093 0000 		sts RxName+6,r20
 294:main.c        **** 	RxName[4]		=   "ExTmp";
 966               	.LM91:
 967 00a2 40E0      		ldi r20,lo8(.LC11)
 968 00a4 50E0      		ldi r21,hi8(.LC11)
 969 00a6 5093 0000 		sts RxName+8+1,r21
 970 00aa 4093 0000 		sts RxName+8,r20
 295:main.c        **** 	RxName[5]		=   "Oil.T";
 972               	.LM92:
 973 00ae 40E0      		ldi r20,lo8(.LC12)
 974 00b0 50E0      		ldi r21,hi8(.LC12)
 975 00b2 5093 0000 		sts RxName+10+1,r21
 976 00b6 4093 0000 		sts RxName+10,r20
 296:main.c        **** 	RxName[6]		=   "Water.T";
 978               	.LM93:
 979 00ba 40E0      		ldi r20,lo8(.LC13)
 980 00bc 50E0      		ldi r21,hi8(.LC13)
 981 00be 5093 0000 		sts RxName+12+1,r21
 982 00c2 4093 0000 		sts RxName+12,r20
 297:main.c        ****     
 298:main.c        **** 	RxName_short[0]	=   "BS";
 984               	.LM94:
 985 00c6 40E0      		ldi r20,lo8(.LC14)
 986 00c8 50E0      		ldi r21,hi8(.LC14)
 987 00ca 5093 0000 		sts RxName_short+1,r21
 988 00ce 4093 0000 		sts RxName_short,r20
 299:main.c        **** 	RxName_short[1]	=   "TC";
 990               	.LM95:
 991 00d2 40E0      		ldi r20,lo8(.LC15)
 992 00d4 50E0      		ldi r21,hi8(.LC15)
 993 00d6 5093 0000 		sts RxName_short+2+1,r21
 994 00da 4093 0000 		sts RxName_short+2,r20
 300:main.c        **** 	RxName_short[2]	=   "OP";
 996               	.LM96:
 997 00de 40E0      		ldi r20,lo8(.LC16)
 998 00e0 50E0      		ldi r21,hi8(.LC16)
 999 00e2 5093 0000 		sts RxName_short+4+1,r21
 1000 00e6 4093 0000 		sts RxName_short+4,r20
 301:main.c        **** 	RxName_short[3]	=   "FP";
 1002               	.LM97:
 1003 00ea 40E0      		ldi r20,lo8(.LC17)
 1004 00ec 50E0      		ldi r21,hi8(.LC17)
 1005 00ee 5093 0000 		sts RxName_short+6+1,r21
 1006 00f2 4093 0000 		sts RxName_short+6,r20
 302:main.c        **** 	RxName_short[4]	=   "ET";
 1008               	.LM98:
 1009 00f6 40E0      		ldi r20,lo8(.LC18)
 1010 00f8 50E0      		ldi r21,hi8(.LC18)
 1011 00fa 5093 0000 		sts RxName_short+8+1,r21
 1012 00fe 4093 0000 		sts RxName_short+8,r20
 303:main.c        **** 	RxName_short[5]	=   "OT";
 1014               	.LM99:
 1015 0102 40E0      		ldi r20,lo8(.LC19)
 1016 0104 50E0      		ldi r21,hi8(.LC19)
 1017 0106 5093 0000 		sts RxName_short+10+1,r21
 1018 010a 4093 0000 		sts RxName_short+10,r20
 304:main.c        **** 	RxName_short[6]	=   "WT";
 1020               	.LM100:
 1021 010e 40E0      		ldi r20,lo8(.LC20)
 1022 0110 50E0      		ldi r21,hi8(.LC20)
 1023 0112 5093 0000 		sts RxName_short+12+1,r21
 1024 0116 4093 0000 		sts RxName_short+12,r20
 305:main.c        ****     
 306:main.c        **** 	RxName_long[0]	=   "Boost";
 1026               	.LM101:
 1027 011a 9093 0000 		sts RxName_long+1,r25
 1028 011e 8093 0000 		sts RxName_long,r24
 307:main.c        **** 	RxName_long[1]	=   "Tacho";
 1030               	.LM102:
 1031 0122 3093 0000 		sts RxName_long+2+1,r19
 1032 0126 2093 0000 		sts RxName_long+2,r18
 308:main.c        **** 	RxName_long[2]	=   "Oil press";
 1034               	.LM103:
 1035 012a 80E0      		ldi r24,lo8(.LC21)
 1036 012c 90E0      		ldi r25,hi8(.LC21)
 1037 012e 9093 0000 		sts RxName_long+4+1,r25
 1038 0132 8093 0000 		sts RxName_long+4,r24
 309:main.c        **** 	RxName_long[3]	=   "Fuel press";
 1040               	.LM104:
 1041 0136 80E0      		ldi r24,lo8(.LC22)
 1042 0138 90E0      		ldi r25,hi8(.LC22)
 1043 013a 9093 0000 		sts RxName_long+6+1,r25
 1044 013e 8093 0000 		sts RxName_long+6,r24
 310:main.c        **** 	RxName_long[4]	=   "Ext. Temp.";
 1046               	.LM105:
 1047 0142 80E0      		ldi r24,lo8(.LC23)
 1048 0144 90E0      		ldi r25,hi8(.LC23)
 1049 0146 9093 0000 		sts RxName_long+8+1,r25
 1050 014a 8093 0000 		sts RxName_long+8,r24
 311:main.c        **** 	RxName_long[5]	=   "Oil Temp.";
 1052               	.LM106:
 1053 014e 80E0      		ldi r24,lo8(.LC24)
 1054 0150 90E0      		ldi r25,hi8(.LC24)
 1055 0152 9093 0000 		sts RxName_long+10+1,r25
 1056 0156 8093 0000 		sts RxName_long+10,r24
 312:main.c        **** 	RxName_long[6]	=   "Water Temp.";
 1058               	.LM107:
 1059 015a 80E0      		ldi r24,lo8(.LC25)
 1060 015c 90E0      		ldi r25,hi8(.LC25)
 1061 015e 9093 0000 		sts RxName_long+12+1,r25
 1062 0162 8093 0000 		sts RxName_long+12,r24
 1063 0166 69E1      		ldi r22,lo8(25)
 1064 0168 A62E      		mov r10,r22
 1065 016a B12C      		mov r11,__zero_reg__
 1066 016c AC0E      		add r10,r28
 1067 016e BD1E      		adc r11,r29
 1068 0170 72E1      		ldi r23,lo8(18)
 1069 0172 872E      		mov r8,r23
 1070 0174 912C      		mov r9,__zero_reg__
 1071 0176 8C0E      		add r8,r28
 1072 0178 9D1E      		adc r9,r29
 1073 017a 00E0      		ldi r16,lo8(0)
 1074 017c 10E0      		ldi r17,hi8(0)
 313:main.c        ****     
 314:main.c        ****     // Definition of Resolution for processing and number of space for display
 315:main.c        ****     for(n=0;n<7;n++){
 316:main.c        ****         Resolution[n] = 1;
 317:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 318:main.c        ****             Resolution[n] = Resolution[n] / 10;
 319:main.c        ****         }
 320:main.c        ****         RxNameLength[n] = StrLength(RxName[n]);
 321:main.c        ****         Nspace[n]       = DISP_W - RxNameLength[n] - ( Nsig[n] + (Nsig[n]!=Nint[n]) );
 1076               	.LM108:
 1077 017e EBE0      		ldi r30,lo8(11)
 1078 0180 EE2E      		mov r14,r30
 1079 0182 00C0      		rjmp .L36
 1080               	.L37:
 317:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1082               	.LM109:
 1083 0184 4F5F      		subi r20,lo8(-(1))
 1084               	.L40:
 317:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1086               	.LM110:
 1087 0186 242F      		mov r18,r20
 1088 0188 30E0      		ldi r19,lo8(0)
 1089 018a 2817      		cp r18,r24
 1090 018c 3907      		cpc r19,r25
 1091 018e 04F0      		brlt .L37
 320:main.c        ****         RxNameLength[n] = StrLength(RxName[n]);
 1093               	.LM111:
 1094 0190 F801      		movw r30,r16
 1095 0192 EE0F      		lsl r30
 1096 0194 FF1F      		rol r31
 1097 0196 E050      		subi r30,lo8(-(RxName))
 1098 0198 F040      		sbci r31,hi8(-(RxName))
 1099 019a 8081      		ld r24,Z
 1100 019c 9181      		ldd r25,Z+1
 1101 019e 00D0      		rcall StrLength
 1102 01a0 F801      		movw r30,r16
 1103 01a2 E050      		subi r30,lo8(-(RxNameLength))
 1104 01a4 F040      		sbci r31,hi8(-(RxNameLength))
 1105 01a6 8083      		st Z,r24
 1107               	.LM112:
 1108 01a8 EBE0      		ldi r30,lo8(11)
 1109 01aa F0E0      		ldi r31,hi8(11)
 1110 01ac EC0F      		add r30,r28
 1111 01ae FD1F      		adc r31,r29
 1112 01b0 E00F      		add r30,r16
 1113 01b2 F11F      		adc r31,r17
 1114 01b4 9E2D      		mov r25,r14
 1115 01b6 9C19      		sub r25,r12
 1116 01b8 21E0      		ldi r18,lo8(1)
 1117 01ba CF14      		cp r12,r15
 1118 01bc 01F4      		brne .L38
 1119 01be 20E0      		ldi r18,lo8(0)
 1120               	.L38:
 1121 01c0 921B      		sub r25,r18
 1122 01c2 981B      		sub r25,r24
 1123 01c4 9083      		st Z,r25
 1124 01c6 0F5F      		subi r16,lo8(-(1))
 1125 01c8 1F4F      		sbci r17,hi8(-(1))
 315:main.c        ****     for(n=0;n<7;n++){
 1127               	.LM113:
 1128 01ca 0730      		cpi r16,7
 1129 01cc 1105      		cpc r17,__zero_reg__
 1130 01ce 01F0      		breq .L39
 1131               	.L36:
 317:main.c        ****         for(m=0;m<Nsig[n]-Nint[n];m++){
 1133               	.LM114:
 1134 01d0 D501      		movw r26,r10
 1135 01d2 CD90      		ld r12,X+
 1136 01d4 5D01      		movw r10,r26
 1137 01d6 F401      		movw r30,r8
 1138 01d8 F190      		ld r15,Z+
 1139 01da 4F01      		movw r8,r30
 1140 01dc 8C2D      		mov r24,r12
 1141 01de 90E0      		ldi r25,lo8(0)
 1142 01e0 8F19      		sub r24,r15
 1143 01e2 9109      		sbc r25,__zero_reg__
 1144 01e4 40E0      		ldi r20,lo8(0)
 1145 01e6 00C0      		rjmp .L40
 1146               	.L39:
 322:main.c        ****     }
 323:main.c        ****     
 324:main.c        **** 	mult_factor[0] = 1;
 1148               	.LM115:
 1149 01e8 81E0      		ldi r24,lo8(1)
 1150 01ea 90E0      		ldi r25,hi8(1)
 1151 01ec 9E83      		std Y+6,r25
 1152 01ee 8D83      		std Y+5,r24
 325:main.c        **** 	mult_factor[1] = 16;
 1154               	.LM116:
 1155 01f0 80E1      		ldi r24,lo8(16)
 1156 01f2 90E0      		ldi r25,hi8(16)
 1157 01f4 9887      		std Y+8,r25
 1158 01f6 8F83      		std Y+7,r24
 326:main.c        **** 	mult_factor[2] = 256;
 1160               	.LM117:
 1161 01f8 80E0      		ldi r24,lo8(256)
 1162 01fa 91E0      		ldi r25,hi8(256)
 1163 01fc 9A87      		std Y+10,r25
 1164 01fe 8987      		std Y+9,r24
 1165               	.LBB17:
 1166               	.LBB18:
 1168               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1170               	.LM118:
 1171 0200 8FE7      		 ldi r24,lo8(79999)
 1172 0202 98E3      	    ldi r25,hi8(79999)
 1173 0204 A1E0      	    ldi r26,hlo8(79999)
 1174 0206 8150      	    1:subi r24,1
 1175 0208 9040      	    sbci r25,0
 1176 020a A040      	    sbci r26,0
 1177 020c 01F4      	    brne 1b
 1178 020e 00C0      		rjmp .
 1179 0210 0000      		nop
 1180               	.LBE18:
 1181               	.LBE17:
 1183               	.Ltext2:
 327:main.c        ****     for(m=0;m<3;m++){
 328:main.c        ****         for(n=0;n<=m;n++){
 329:main.c        ****             
 330:main.c        ****         }
 331:main.c        ****     }
 332:main.c        **** 
 333:main.c        ****     // opening
 334:main.c        **** 	_delay_ms(50);
 335:main.c        **** 	lcd_locate(1,0);
 1185               	.LM119:
 1186 0212 81E0      		ldi r24,lo8(1)
 1187 0214 60E0      		ldi r22,lo8(0)
 1188 0216 00D0      		rcall lcd_locate
 1189 0218 00E0      		ldi r16,lo8(.LC6)
 1190 021a 10E0      		ldi r17,hi8(.LC6)
 336:main.c        **** 	for(n=0;n<LCD_W;n++){
 1192               	.LM120:
 1193 021c 90E0      		ldi r25,lo8(0)
 1194               	.L41:
 337:main.c        **** 		lcd_set_char(opening_message0[n]);
 1196               	.LM121:
 1197 021e D801      		movw r26,r16
 1198 0220 8D91      		ld r24,X+
 1199 0222 8D01      		movw r16,r26
 1200 0224 9EAF      		std Y+62,r25
 1201 0226 00D0      		rcall lcd_set_char
 1202               	.LBB19:
 1203               	.LBB20:
 1205               	.Ltext3:
 1207               	.LM122:
 1208 0228 EFE3      		 ldi r30,lo8(-25537)
 1209 022a FCE9      	    ldi r31,hi8(-25537)
 1210 022c 3197      	    1:sbiw r30,1
 1211 022e 01F4      	    brne 1b
 1212 0230 00C0      		rjmp .
 1213 0232 0000      		nop
 1214               	.LBE20:
 1215               	.LBE19:
 1217               	.Ltext4:
 336:main.c        **** 	for(n=0;n<LCD_W;n++){
 1219               	.LM123:
 1220 0234 9EAD      		ldd r25,Y+62
 1221 0236 9F5F      		subi r25,lo8(-(1))
 1222 0238 9431      		cpi r25,lo8(20)
 1223 023a 01F4      		brne .L41
 338:main.c        **** 		_delay_ms(20);
 339:main.c        **** 	}
 340:main.c        **** 	lcd_locate(2,0);
 1225               	.LM124:
 1226 023c 82E0      		ldi r24,lo8(2)
 1227 023e 60E0      		ldi r22,lo8(0)
 1228 0240 00D0      		rcall lcd_locate
 1229 0242 00E0      		ldi r16,lo8(.LC5)
 1230 0244 10E0      		ldi r17,hi8(.LC5)
 341:main.c        **** 	for(n=0;n<LCD_W;n++){
 1232               	.LM125:
 1233 0246 90E0      		ldi r25,lo8(0)
 1234               	.L42:
 342:main.c        **** 		lcd_set_char(opening_message1[n]);
 1236               	.LM126:
 1237 0248 D801      		movw r26,r16
 1238 024a 8D91      		ld r24,X+
 1239 024c 8D01      		movw r16,r26
 1240 024e 9EAF      		std Y+62,r25
 1241 0250 00D0      		rcall lcd_set_char
 1242               	.LBB21:
 1243               	.LBB22:
 1245               	.Ltext5:
 1247               	.LM127:
 1248 0252 EFE3      		 ldi r30,lo8(-25537)
 1249 0254 FCE9      	    ldi r31,hi8(-25537)
 1250 0256 3197      	    1:sbiw r30,1
 1251 0258 01F4      	    brne 1b
 1252 025a 00C0      		rjmp .
 1253 025c 0000      		nop
 1254               	.LBE22:
 1255               	.LBE21:
 1257               	.Ltext6:
 341:main.c        **** 	for(n=0;n<LCD_W;n++){
 1259               	.LM128:
 1260 025e 9EAD      		ldd r25,Y+62
 1261 0260 9F5F      		subi r25,lo8(-(1))
 1262 0262 9431      		cpi r25,lo8(20)
 1263 0264 01F4      		brne .L42
 1264               	.LBB23:
 1265               	.LBB24:
 1267               	.Ltext7:
 1269               	.LM129:
 1270 0266 8FEF      		 ldi r24,lo8(479999)
 1271 0268 92E5      	    ldi r25,hi8(479999)
 1272 026a A7E0      	    ldi r26,hlo8(479999)
 1273 026c 8150      	    1:subi r24,1
 1274 026e 9040      	    sbci r25,0
 1275 0270 A040      	    sbci r26,0
 1276 0272 01F4      	    brne 1b
 1277 0274 00C0      		rjmp .
 1278 0276 0000      		nop
 1280               	.Ltext8:
 343:main.c        **** 		_delay_ms(20);
 344:main.c        **** 	}
 345:main.c        ****     
 346:main.c        ****     // Clear Opening
 347:main.c        **** 	_delay_ms(300);
 348:main.c        **** 	for(m=0;m<4;m++){
 1282               	.LM130:
 1283 0278 00E0      		ldi r16,lo8(0)
 1284               	.L44:
 1285               	.LBE24:
 1286               	.LBE23:
 349:main.c        **** 		lcd_locate(m,0);
 1288               	.LM131:
 1289 027a 802F      		mov r24,r16
 1290 027c 60E0      		ldi r22,lo8(0)
 1291 027e 00D0      		rcall lcd_locate
 1292 0280 14E1      		ldi r17,lo8(20)
 1293               	.L43:
 350:main.c        **** 		for(n=0;n<LCD_W;n++){
 351:main.c        **** 			lcd_set_char(0x20);
 1295               	.LM132:
 1296 0282 80E2      		ldi r24,lo8(32)
 1297 0284 00D0      		rcall lcd_set_char
 1298               	.LBB25:
 1299               	.LBB26:
 1301               	.Ltext9:
 1303               	.LM133:
 1304 0286 AFE3      		 ldi r26,lo8(-25537)
 1305 0288 BCE9      	    ldi r27,hi8(-25537)
 1306 028a 1197      	    1:sbiw r26,1
 1307 028c 01F4      	    brne 1b
 1308 028e 00C0      		rjmp .
 1309 0290 0000      		nop
 1310 0292 1150      		subi r17,lo8(-(-1))
 1311               	.LBE26:
 1312               	.LBE25:
 1314               	.Ltext10:
 350:main.c        **** 		for(n=0;n<LCD_W;n++){
 1316               	.LM134:
 1317 0294 01F4      		brne .L43
 348:main.c        **** 	for(m=0;m<4;m++){
 1319               	.LM135:
 1320 0296 0F5F      		subi r16,lo8(-(1))
 1321 0298 0430      		cpi r16,lo8(4)
 1322 029a 01F4      		brne .L44
 352:main.c        **** 			_delay_ms(20);
 353:main.c        **** 		}
 354:main.c        **** 	}
 355:main.c        ****     
 356:main.c        ****     sei();
 1324               	.LM136:
 1325               	/* #APP */
 1326               	 ;  356 "main.c" 1
 1327 029c 7894      		sei
 1328               	 ;  0 "" 2
 1329               	/* #NOAPP */
 1330               	.LBB27:
 357:main.c        **** 
 358:main.c        **** 	// Main function start this
 359:main.c        **** 	while(1){
 360:main.c        **** 
 361:main.c        ****         if(lcd_update){
 362:main.c        ****             DisplayItemInfo();
 363:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 364:main.c        ****             lcd_update = 0;
 365:main.c        **** 		}
 366:main.c        **** 
 367:main.c        ****         // Defi Link Tap
 368:main.c        **** 		for ( index = 0; index < Ndata; index++ ){
 369:main.c        **** 			
 370:main.c        **** 			// Rx data read
 371:main.c        **** 			id = t_id[index];
 372:main.c        ****             
 373:main.c        **** 			// Judge data validity
 374:main.c        ****             // debug
 375:main.c        ****             lcd_locate(index,12);
 376:main.c        ****              // debug
 377:main.c        **** 			for( n = 1; n < 4; n++ ){
 378:main.c        ****                 if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 379:main.c        ****                      |( (data[index][n] >= 'A') & (data[index][n] <= 'F') ) ) ){
 380:main.c        **** 					valid_packet = 1;
 381:main.c        **** 				}else{
 382:main.c        **** 					valid_packet = 0;
 383:main.c        **** 					break;
 384:main.c        **** 				}
 385:main.c        **** 			}
 386:main.c        **** 			// end of judge
 387:main.c        ****             
 388:main.c        ****             // clear value area of LCD
 389:main.c        ****             //				lcd_locate((uint8_t)((LCD_W/2*index)/LCD_W),(LCD_W/2)*(index%2)+RxNameLength[id])
 390:main.c        ****             lcd_locate(index,RxNameLength[id]);
 391:main.c        ****             for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1332               	.LM137:
 1333 029e 8AE0      		ldi r24,lo8(10)
 1334 02a0 282E      		mov r2,r24
 1335 02a2 312C      		mov r3,__zero_reg__
 392:main.c        ****                 lcd_set_char(' ');
 393:main.c        ****             }
 394:main.c        ****             // end of clear value
 395:main.c        ****             
 396:main.c        ****             // pad blank area of LCD
 397:main.c        ****             lcd_locate(index,RxNameLength[id]);
 398:main.c        ****             for (n=0;n<Nspace[id];n++){
 399:main.c        ****                 lcd_set_char(' ');
 400:main.c        ****             }
 401:main.c        ****             // end of pad blank area of LCD
 402:main.c        **** 			if ( valid_packet == 1 ) {
 1337               	.LM138:
 1338 02a4 FE01      		movw r30,r28
 1339 02a6 3596      		adiw r30,5
 1340 02a8 FDAF      		std Y+61,r31
 1341 02aa ECAF      		std Y+60,r30
 1342               	.L69:
 361:main.c        ****         if(lcd_update){
 1344               	.LM139:
 1345 02ac 8091 0000 		lds r24,lcd_update
 1346 02b0 8823      		tst r24
 1347 02b2 01F0      		breq .L45
 362:main.c        ****             DisplayItemInfo();
 1349               	.LM140:
 1350 02b4 00D0      		rcall DisplayItemInfo
 363:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1352               	.LM141:
 1353 02b6 2091 0000 		lds r18,chg_index
 1354 02ba 30E0      		ldi r19,lo8(0)
 1355 02bc C901      		movw r24,r18
 1356 02be 8370      		andi r24,lo8(3)
 1357 02c0 9070      		andi r25,hi8(3)
 1358 02c2 9595      		asr r25
 1359 02c4 8795      		ror r24
 1360 02c6 20FF      		sbrs r18,0
 1361 02c8 00C0      		rjmp .L70
 1362 02ca 68E0      		ldi r22,lo8(8)
 1363 02cc 00C0      		rjmp .L46
 1364               	.L70:
 1365 02ce 67E0      		ldi r22,lo8(7)
 1366               	.L46:
 363:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1368               	.LM142:
 1369 02d0 00D0      		rcall lcd_locate
 364:main.c        ****             lcd_update = 0;
 1371               	.LM143:
 1372 02d2 1092 0000 		sts lcd_update,__zero_reg__
 1373               	.L45:
 364:main.c        ****             lcd_update = 0;
 1375               	.LM144:
 1376 02d6 B0E0      		ldi r27,lo8(t_id)
 1377 02d8 4B2E      		mov r4,r27
 1378 02da B0E0      		ldi r27,hi8(t_id)
 1379 02dc 5B2E      		mov r5,r27
 1380 02de 10E0      		ldi r17,lo8(data)
 1381 02e0 612E      		mov r6,r17
 1382 02e2 10E0      		ldi r17,hi8(data)
 1383 02e4 712E      		mov r7,r17
 363:main.c        ****             lcd_locate((chg_index&0x03)>>1,8-(1-chg_index%2));
 1385               	.LM145:
 1386 02e6 8824      		clr r8
 1387 02e8 9924      		clr r9
 1388               	.L65:
 364:main.c        ****             lcd_update = 0;
 1390               	.LM146:
 1391 02ea E82C      		mov r14,r8
 371:main.c        **** 			id = t_id[index];
 1393               	.LM147:
 1394 02ec D201      		movw r26,r4
 1395 02ee 0D91      		ld r16,X+
 1396 02f0 2D01      		movw r4,r26
 375:main.c        ****             lcd_locate(index,12);
 1398               	.LM148:
 1399 02f2 882D      		mov r24,r8
 1400 02f4 6CE0      		ldi r22,lo8(12)
 1401 02f6 00D0      		rcall lcd_locate
 1402 02f8 80E0      		ldi r24,lo8(0)
 1403 02fa 90E0      		ldi r25,hi8(0)
 1404               	.L51:
 183:main.c        **** int main(void)
 1406               	.LM149:
 1407 02fc F301      		movw r30,r6
 1408 02fe E80F      		add r30,r24
 1409 0300 F91F      		adc r31,r25
 378:main.c        ****                 if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 1411               	.LM150:
 1412 0302 2181      		ldd r18,Z+1
 379:main.c        ****                      |( (data[index][n] >= 'A') & (data[index][n] <= 'F') ) ) ){
 1414               	.LM151:
 1415 0304 322F      		mov r19,r18
 1416 0306 3154      		subi r19,lo8(-(-65))
 1417 0308 3630      		cpi r19,lo8(6)
 1418 030a 00F0      		brlo .L73
 378:main.c        ****                 if( ( ( (data[index][n] >= '0') & (data[index][n] <= '9') )
 1420               	.LM152:
 1421 030c 2053      		subi r18,lo8(-(-48))
 1422 030e 2A30      		cpi r18,lo8(10)
 1423 0310 00F4      		brsh .L87
 1424               	.L73:
 1425 0312 0196      		adiw r24,1
 377:main.c        **** 			for( n = 1; n < 4; n++ ){
 1427               	.LM153:
 1428 0314 8330      		cpi r24,3
 1429 0316 9105      		cpc r25,__zero_reg__
 1430 0318 01F4      		brne .L51
 380:main.c        **** 					valid_packet = 1;
 1432               	.LM154:
 1433 031a FF24      		clr r15
 1434 031c F394      		inc r15
 1435 031e 00C0      		rjmp .L47
 1436               	.L87:
 382:main.c        **** 					valid_packet = 0;
 1438               	.LM155:
 1439 0320 FF24      		clr r15
 1440               	.L47:
 390:main.c        ****             lcd_locate(index,RxNameLength[id]);
 1442               	.LM156:
 1443 0322 A02E      		mov r10,r16
 1444 0324 BB24      		clr r11
 1445 0326 8501      		movw r16,r10
 1446 0328 0050      		subi r16,lo8(-(RxNameLength))
 1447 032a 1040      		sbci r17,hi8(-(RxNameLength))
 1448 032c 8E2D      		mov r24,r14
 1449 032e F801      		movw r30,r16
 1450 0330 6081      		ld r22,Z
 1451 0332 00D0      		rcall lcd_locate
 391:main.c        ****             for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1453               	.LM157:
 1454 0334 CC24      		clr r12
 1455 0336 00C0      		rjmp .L52
 1456               	.L53:
 392:main.c        ****                 lcd_set_char(' ');
 1458               	.LM158:
 1459 0338 80E2      		ldi r24,lo8(32)
 1460 033a 00D0      		rcall lcd_set_char
 391:main.c        ****             for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1462               	.LM159:
 1463 033c C394      		inc r12
 1464               	.L52:
 391:main.c        ****             for (n=0;n<=(DISP_W-RxNameLength[id])-1;n++) {
 1466               	.LM160:
 1467 033e D801      		movw r26,r16
 1468 0340 6C91      		ld r22,X
 1469 0342 8C2D      		mov r24,r12
 1470 0344 90E0      		ldi r25,lo8(0)
 1471 0346 9101      		movw r18,r2
 1472 0348 261B      		sub r18,r22
 1473 034a 3109      		sbc r19,__zero_reg__
 1474 034c 2817      		cp r18,r24
 1475 034e 3907      		cpc r19,r25
 1476 0350 04F4      		brge .L53
 397:main.c        ****             lcd_locate(index,RxNameLength[id]);
 1478               	.LM161:
 1479 0352 8E2D      		mov r24,r14
 1480 0354 00D0      		rcall lcd_locate
 398:main.c        ****             for (n=0;n<Nspace[id];n++){
 1482               	.LM162:
 1483 0356 EE24      		clr r14
 1484 0358 0BE0      		ldi r16,lo8(11)
 1485 035a 10E0      		ldi r17,hi8(11)
 1486 035c 0C0F      		add r16,r28
 1487 035e 1D1F      		adc r17,r29
 1488 0360 0A0D      		add r16,r10
 1489 0362 1B1D      		adc r17,r11
 1490 0364 00C0      		rjmp .L54
 1491               	.L55:
 399:main.c        ****                 lcd_set_char(' ');
 1493               	.LM163:
 1494 0366 80E2      		ldi r24,lo8(32)
 1495 0368 00D0      		rcall lcd_set_char
 398:main.c        ****             for (n=0;n<Nspace[id];n++){
 1497               	.LM164:
 1498 036a E394      		inc r14
 1499               	.L54:
 398:main.c        ****             for (n=0;n<Nspace[id];n++){
 1501               	.LM165:
 1502 036c F801      		movw r30,r16
 1503 036e 8081      		ld r24,Z
 1504 0370 E816      		cp r14,r24
 1505 0372 00F0      		brlo .L55
 1507               	.LM166:
 1508 0374 F1E0      		ldi r31,lo8(1)
 1509 0376 FF16      		cp r15,r31
 1510 0378 01F0      		breq .+2
 1511 037a 00C0      		rjmp .L72
 183:main.c        **** int main(void)
 1513               	.LM167:
 1514 037c 7401      		movw r14,r8
 1515 037e EE0C      		lsl r14
 1516 0380 FF1C      		rol r15
 1517 0382 EE0C      		lsl r14
 1518 0384 FF1C      		rol r15
 1519 0386 80E0      		ldi r24,lo8(data+1)
 1520 0388 90E0      		ldi r25,hi8(data+1)
 1521 038a E80E      		add r14,r24
 1522 038c F91E      		adc r15,r25
 1524               	.LM168:
 1525 038e DE01      		movw r26,r28
 1526 0390 1296      		adiw r26,2
 1527 0392 BE01      		movw r22,r28
 1528 0394 655F      		subi r22,lo8(-(11))
 1529 0396 7F4F      		sbci r23,hi8(-(11))
 183:main.c        **** int main(void)
 1531               	.LM169:
 1532 0398 00E0      		ldi r16,lo8(0)
 1533 039a 10E0      		ldi r17,hi8(0)
 1534               	.L60:
 403:main.c        **** 				// Change char to angle-dec
 404:main.c        ****                 dec_ang = 0;
 405:main.c        **** 				for( n = 1; n < 4; n++){ // data[0] is neglected because of it is control data
 406:main.c        **** 					if  ( (data[index][n] & 0xf0) == 0x30 ){
 1536               	.LM170:
 1537 039c F701      		movw r30,r14
 1538 039e 2191      		ld r18,Z+
 1539 03a0 7F01      		movw r14,r30
 1540 03a2 822F      		mov r24,r18
 1541 03a4 90E0      		ldi r25,lo8(0)
 1542 03a6 807F      		andi r24,lo8(240)
 1543 03a8 9070      		andi r25,hi8(240)
 1544 03aa 8033      		cpi r24,48
 1545 03ac 9105      		cpc r25,__zero_reg__
 1546 03ae 01F4      		brne .L57
 407:main.c        **** 						low4bits[n] = (unsigned int)(data[index][n] & 0x0f);
 1548               	.LM171:
 1549 03b0 2F70      		andi r18,lo8(15)
 1550 03b2 00C0      		rjmp .L88
 1551               	.L57:
 408:main.c        **** 					}else if ( (data[index][n] & 0xf0) == 0x40 ){
 1553               	.LM172:
 1554 03b4 8034      		cpi r24,64
 1555 03b6 9105      		cpc r25,__zero_reg__
 1556 03b8 01F4      		brne .L59
 409:main.c        **** 						low4bits[n] = (unsigned int)(data[index][n] & 0x0f) + 9;
 1558               	.LM173:
 1559 03ba 2F70      		andi r18,lo8(15)
 1560 03bc 275F      		subi r18,lo8(-(9))
 1561               	.L88:
 1562 03be 2C93      		st X,r18
 410:main.c        **** 					}else{
 411:main.c        **** 						break;
 412:main.c        **** 					}
 413:main.c        **** 					dec_ang = dec_ang + low4bits[n] * mult_factor[3-n];
 1564               	.LM174:
 1565 03c0 8D91      		ld r24,X+
 1566 03c2 90E0      		ldi r25,lo8(0)
 1567 03c4 FB01      		movw r30,r22
 1568 03c6 3291      		ld r19,-Z
 1569 03c8 2291      		ld r18,-Z
 1570 03ca BF01      		movw r22,r30
 1571 03cc 829F      		mul r24,r18
 1572 03ce A001      		movw r20,r0
 1573 03d0 839F      		mul r24,r19
 1574 03d2 500D      		add r21,r0
 1575 03d4 929F      		mul r25,r18
 1576 03d6 500D      		add r21,r0
 1577 03d8 1124      		clr r1
 1578 03da 040F      		add r16,r20
 1579 03dc 151F      		adc r17,r21
 405:main.c        **** 				for( n = 1; n < 4; n++){ // data[0] is neglected because of it is control data
 1581               	.LM175:
 1582 03de 8CAD      		ldd r24,Y+60
 1583 03e0 9DAD      		ldd r25,Y+61
 1584 03e2 E817      		cp r30,r24
 1585 03e4 F907      		cpc r31,r25
 1586 03e6 01F4      		brne .L60
 1587               	.L59:
 414:main.c        **** 				}
 415:main.c        **** 				// end of Change char to angle-dec
 416:main.c        ****                 
 417:main.c        ****                 // Change angle-dec to normlized-dec
 418:main.c        ****                 dec_nrm = (float)dec_ang / maxv;
 1589               	.LM176:
 1590 03e8 B801      		movw r22,r16
 1591 03ea 80E0      		ldi r24,lo8(0)
 1592 03ec 90E0      		ldi r25,hi8(0)
 1593 03ee 00D0      		rcall __floatunsisf
 1594 03f0 20E0      		ldi r18,lo8(0x45130000)
 1595 03f2 30E0      		ldi r19,hi8(0x45130000)
 1596 03f4 43E1      		ldi r20,hlo8(0x45130000)
 1597 03f6 55E4      		ldi r21,hhi8(0x45130000)
 1598 03f8 00D0      		rcall __divsf3
 1599 03fa 6B01      		movw r12,r22
 1600 03fc 7C01      		movw r14,r24
 419:main.c        ****                 // end of Change angle-dec to normlized-dec
 420:main.c        ****                 
 421:main.c        **** 				// Change dec to ISO
 422:main.c        **** 				value = dec_nrm * eq_grad[id] + eq_intercept[id];
 1602               	.LM177:
 1603 03fe 8501      		movw r16,r10
 1604 0400 000F      		lsl r16
 1605 0402 111F      		rol r17
 1606 0404 A1E0      		ldi r26,lo8(1)
 1607 0406 B0E0      		ldi r27,hi8(1)
 1608 0408 AC0F      		add r26,r28
 1609 040a BD1F      		adc r27,r29
 1610 040c 0A0F      		add r16,r26
 1611 040e 1B1F      		adc r17,r27
 1612 0410 F801      		movw r30,r16
 1613 0412 65A5      		ldd r22,Z+45
 1614 0414 76A5      		ldd r23,Z+46
 1615 0416 80E0      		ldi r24,lo8(0)
 1616 0418 90E0      		ldi r25,hi8(0)
 1617 041a 00D0      		rcall __floatunsisf
 1618 041c 9B01      		movw r18,r22
 1619 041e AC01      		movw r20,r24
 1620 0420 C701      		movw r24,r14
 1621 0422 B601      		movw r22,r12
 1622 0424 00D0      		rcall __mulsf3
 1623 0426 6B01      		movw r12,r22
 1624 0428 7C01      		movw r14,r24
 1625 042a D801      		movw r26,r16
 1626 042c 5F96      		adiw r26,31
 1627 042e 6D91      		ld r22,X+
 1628 0430 7C91      		ld r23,X
 1629 0432 9097      		sbiw r26,31+1
 1630 0434 8827      		clr r24
 1631 0436 77FD      		sbrc r23,7
 1632 0438 8095      		com r24
 1633 043a 982F      		mov r25,r24
 1634 043c 00D0      		rcall __floatsisf
 1635 043e 9B01      		movw r18,r22
 1636 0440 AC01      		movw r20,r24
 1637 0442 C701      		movw r24,r14
 1638 0444 B601      		movw r22,r12
 1639 0446 00D0      		rcall __addsf3
 1640 0448 F62F      		mov r31,r22
 1641 044a E72F      		mov r30,r23
 1642 044c 382F      		mov r19,r24
 1643 044e 292F      		mov r18,r25
 1644 0450 462F      		mov r20,r22
 1645 0452 572F      		mov r21,r23
 1646 0454 682F      		mov r22,r24
 1647 0456 792F      		mov r23,r25
 1648 0458 6A01      		movw r12,r20
 1649 045a 7B01      		movw r14,r22
 423:main.c        ****                 // end of change
 424:main.c        **** 				
 425:main.c        **** 				// Detect sign
 426:main.c        ****                 if( value < 0 ){
 1651               	.LM178:
 1652 045c 8F2F      		mov r24,r31
 1653 045e 9E2F      		mov r25,r30
 1654 0460 A32F      		mov r26,r19
 1655 0462 B22F      		mov r27,r18
 1656 0464 BC01      		movw r22,r24
 1657 0466 CD01      		movw r24,r26
 1658 0468 20E0      		ldi r18,lo8(0x0)
 1659 046a 30E0      		ldi r19,hi8(0x0)
 1660 046c A901      		movw r20,r18
 1661 046e 00D0      		rcall __ltsf2
 1662 0470 87FF      		sbrs r24,7
 1663 0472 00C0      		rjmp .L61
 427:main.c        **** 					value_sign = 1;
 428:main.c        **** 					value = -value;
 1665               	.LM179:
 1666 0474 F7FA      		bst r15,7
 1667 0476 F094      		com r15
 1668 0478 F7F8      		bld r15,7
 1669 047a F094      		com r15
 1670               	.L61:
 429:main.c        **** 				}else{
 430:main.c        **** 					value_sign = 0;
 431:main.c        **** 				}
 432:main.c        **** 				// end of
 433:main.c        **** 				
 434:main.c        ****                 lcd_set_numeric(value,Nint[id],Nsig[id]-Nint[id]);
 1672               	.LM180:
 1673 047c E2E1      		ldi r30,lo8(18)
 1674 047e F0E0      		ldi r31,hi8(18)
 1675 0480 EC0F      		add r30,r28
 1676 0482 FD1F      		adc r31,r29
 1677 0484 EA0D      		add r30,r10
 1678 0486 FB1D      		adc r31,r11
 1679 0488 0081      		ld r16,Z
 1680 048a C701      		movw r24,r14
 1681 048c B601      		movw r22,r12
 1682 048e 00D0      		rcall __fixunssfsi
 1683 0490 DC01      		movw r26,r24
 1684 0492 CB01      		movw r24,r22
 1685 0494 E9E1      		ldi r30,lo8(25)
 1686 0496 F0E0      		ldi r31,hi8(25)
 1687 0498 EC0F      		add r30,r28
 1688 049a FD1F      		adc r31,r29
 1689 049c EA0D      		add r30,r10
 1690 049e FB1D      		adc r31,r11
 1691 04a0 4081      		ld r20,Z
 1692 04a2 50E0      		ldi r21,lo8(0)
 1693 04a4 401B      		sub r20,r16
 1694 04a6 5109      		sbc r21,__zero_reg__
 1695 04a8 602F      		mov r22,r16
 1696 04aa 70E0      		ldi r23,lo8(0)
 1697 04ac 00D0      		rcall lcd_set_numeric
 1698               	.LBB28:
 1699               	.LBB29:
 1701               	.Ltext11:
 1703               	.LM181:
 1704 04ae EFE1      		 ldi r30,lo8(19999)
 1705 04b0 FEE4      	    ldi r31,hi8(19999)
 1706 04b2 3197      	    1:sbiw r30,1
 1707 04b4 01F4      	    brne 1b
 1708 04b6 00C0      		rjmp .
 1709 04b8 0000      		nop
 1710 04ba 00C0      		rjmp .L63
 1711               	.L64:
 1712               	.LBE29:
 1713               	.LBE28:
 1715               	.Ltext12:
 435:main.c        **** 				
 436:main.c        **** 				_delay_ms((unsigned int)(WAIT));
 437:main.c        ****                 
 438:main.c        **** 			}else if( valid_packet == 0 ){
 439:main.c        ****                 for (n=0;n<=Nsig[id]-1;n++){
 440:main.c        ****                     lcd_set_char('-');
 1717               	.LM182:
 1718 04bc 8DE2      		ldi r24,lo8(45)
 1719 04be 00D0      		rcall lcd_set_char
 439:main.c        ****                 for (n=0;n<=Nsig[id]-1;n++){
 1721               	.LM183:
 1722 04c0 0F5F      		subi r16,lo8(-(1))
 1723 04c2 00C0      		rjmp .L56
 1724               	.L72:
 402:main.c        **** 			if ( valid_packet == 1 ) {
 1726               	.LM184:
 1727 04c4 00E0      		ldi r16,lo8(0)
 439:main.c        ****                 for (n=0;n<=Nsig[id]-1;n++){
 1729               	.LM185:
 1730 04c6 E9E1      		ldi r30,lo8(25)
 1731 04c8 EE2E      		mov r14,r30
 1732 04ca F12C      		mov r15,__zero_reg__
 1733 04cc EC0E      		add r14,r28
 1734 04ce FD1E      		adc r15,r29
 1735 04d0 EA0C      		add r14,r10
 1736 04d2 FB1C      		adc r15,r11
 1737               	.L56:
 439:main.c        ****                 for (n=0;n<=Nsig[id]-1;n++){
 1739               	.LM186:
 1740 04d4 D701      		movw r26,r14
 1741 04d6 8C91      		ld r24,X
 1742 04d8 90E0      		ldi r25,lo8(0)
 1743 04da 202F      		mov r18,r16
 1744 04dc 30E0      		ldi r19,lo8(0)
 1745 04de 2817      		cp r18,r24
 1746 04e0 3907      		cpc r19,r25
 1747 04e2 04F0      		brlt .L64
 1748               	.L63:
 439:main.c        ****                 for (n=0;n<=Nsig[id]-1;n++){
 1750               	.LM187:
 1751 04e4 0894      		sec
 1752 04e6 811C      		adc r8,__zero_reg__
 1753 04e8 911C      		adc r9,__zero_reg__
 1754 04ea E4E0      		ldi r30,lo8(4)
 1755 04ec F0E0      		ldi r31,hi8(4)
 1756 04ee 6E0E      		add r6,r30
 1757 04f0 7F1E      		adc r7,r31
 368:main.c        **** 		for ( index = 0; index < Ndata; index++ ){
 1759               	.LM188:
 1760 04f2 F4E0      		ldi r31,lo8(4)
 1761 04f4 8F16      		cp r8,r31
 1762 04f6 9104      		cpc r9,__zero_reg__
 1763 04f8 01F0      		breq .+2
 1764 04fa 00C0      		rjmp .L65
 1765 04fc 60E0      		ldi r22,lo8(meas_array)
 1766 04fe 70E0      		ldi r23,hi8(meas_array)
 1767 0500 20E0      		ldi r18,lo8(proc_array)
 1768 0502 30E0      		ldi r19,hi8(proc_array)
 1769 0504 49E0      		ldi r20,lo8(9)
 1770               	.L66:
 441:main.c        ****                 }
 442:main.c        ****             }
 443:main.c        **** 		}
 444:main.c        ****         
 445:main.c        ****         // Tacho Meter
 446:main.c        ****         for(n=0;n<Nmed;n++){
 447:main.c        ****             proc_array[n] = meas_array[n];
 1772               	.LM189:
 1773 0506 FB01      		movw r30,r22
 1774 0508 8191      		ld r24,Z+
 1775 050a 9191      		ld r25,Z+
 1776 050c A191      		ld r26,Z+
 1777 050e B191      		ld r27,Z+
 1778 0510 BF01      		movw r22,r30
 1779 0512 F901      		movw r30,r18
 1780 0514 8193      		st Z+,r24
 1781 0516 9193      		st Z+,r25
 1782 0518 A193      		st Z+,r26
 1783 051a B193      		st Z+,r27
 1784 051c 9F01      		movw r18,r30
 1785 051e 4150      		subi r20,lo8(-(-1))
 446:main.c        ****         for(n=0;n<Nmed;n++){
 1787               	.LM190:
 1788 0520 01F4      		brne .L66
 448:main.c        ****         }
 449:main.c        ****         BubbleSort();
 1790               	.LM191:
 1791 0522 00D0      		rcall BubbleSort
 450:main.c        **** 
 451:main.c        ****         if(proc_array[Nmed-1] >= 0xffff){
 1793               	.LM192:
 1794 0524 8091 0000 		lds r24,proc_array+32
 1795 0528 9091 0000 		lds r25,proc_array+32+1
 1796 052c A091 0000 		lds r26,proc_array+32+2
 1797 0530 B091 0000 		lds r27,proc_array+32+3
 1798 0534 8F3F      		cpi r24,lo8(65535)
 1799 0536 FFEF      		ldi r31,hi8(65535)
 1800 0538 9F07      		cpc r25,r31
 1801 053a F0E0      		ldi r31,hlo8(65535)
 1802 053c AF07      		cpc r26,r31
 1803 053e F0E0      		ldi r31,hhi8(65535)
 1804 0540 BF07      		cpc r27,r31
 1805 0542 00F0      		brlo .L67
 452:main.c        ****             freq = 0;
 1807               	.LM193:
 1808 0544 80E0      		ldi r24,lo8(0x0)
 1809 0546 90E0      		ldi r25,hi8(0x0)
 1810 0548 DC01      		movw r26,r24
 1811 054a 00C0      		rjmp .L89
 1812               	.L67:
 453:main.c        ****         }else{
 454:main.c        ****             cnt = proc_array[Nmed>>1];
 1814               	.LM194:
 1815 054c 6091 0000 		lds r22,proc_array+16
 1816 0550 7091 0000 		lds r23,proc_array+16+1
 1817 0554 8091 0000 		lds r24,proc_array+16+2
 1818 0558 9091 0000 		lds r25,proc_array+16+3
 1819 055c 6093 0000 		sts cnt,r22
 1820 0560 7093 0000 		sts cnt+1,r23
 1821 0564 8093 0000 		sts cnt+2,r24
 1822 0568 9093 0000 		sts cnt+3,r25
 455:main.c        ****             freq = FOSC / 64.0 / cnt;
 1824               	.LM195:
 1825 056c 00D0      		rcall __floatunsisf
 1826 056e 9B01      		movw r18,r22
 1827 0570 AC01      		movw r20,r24
 1828 0572 60E0      		ldi r22,lo8(0x47f42400)
 1829 0574 74E2      		ldi r23,hi8(0x47f42400)
 1830 0576 84EF      		ldi r24,hlo8(0x47f42400)
 1831 0578 97E4      		ldi r25,hhi8(0x47f42400)
 1832 057a 00D0      		rcall __divsf3
 1833 057c DC01      		movw r26,r24
 1834 057e CB01      		movw r24,r22
 1835               	.L89:
 1836 0580 8093 0000 		sts freq,r24
 1837 0584 9093 0000 		sts freq+1,r25
 1838 0588 A093 0000 		sts freq+2,r26
 1839 058c B093 0000 		sts freq+3,r27
 456:main.c        ****             //     ^^^^
 457:main.c        ****             //     Ndiv
 458:main.c        ****         }
 459:main.c        ****         
 460:main.c        ****         rpm = (unsigned long int)( 60.0 * freq );
 1841               	.LM196:
 1842 0590 6091 0000 		lds r22,freq
 1843 0594 7091 0000 		lds r23,freq+1
 1844 0598 8091 0000 		lds r24,freq+2
 1845 059c 9091 0000 		lds r25,freq+3
 1846 05a0 20E0      		ldi r18,lo8(0x42700000)
 1847 05a2 30E0      		ldi r19,hi8(0x42700000)
 1848 05a4 40E7      		ldi r20,hlo8(0x42700000)
 1849 05a6 52E4      		ldi r21,hhi8(0x42700000)
 1850 05a8 00D0      		rcall __mulsf3
 1851 05aa 00D0      		rcall __fixunssfsi
 1852 05ac DC01      		movw r26,r24
 1853 05ae CB01      		movw r24,r22
 1854 05b0 8093 0000 		sts rpm,r24
 1855 05b4 9093 0000 		sts rpm+1,r25
 1856 05b8 A093 0000 		sts rpm+2,r26
 1857 05bc B093 0000 		sts rpm+3,r27
 461:main.c        **** 
 462:main.c        ****         // Fuel Pump Driver
 463:main.c        **** //        if( rpm > 3200 ) FPDcomzp = 0xff;
 464:main.c        **** //        else FPDcomp = rpm / 3200.0 * 0xff + 0x48;
 465:main.c        **** //        OCR0A = FPDcomp;
 466:main.c        **** 
 467:main.c        **** /*
 468:main.c        ****         // Display Freq
 469:main.c        ****         lcd_locate(1,0); // debug
 470:main.c        ****         lcd_set_numeric((unsigned int)freq,4); // debug
 471:main.c        ****         lcd_set_str("Hz"); // debug
 472:main.c        **** */
 473:main.c        **** 
 474:main.c        ****         // Display RPM
 475:main.c        ****         lcd_locate(0,12);
 1859               	.LM197:
 1860 05c0 80E0      		ldi r24,lo8(0)
 1861 05c2 6CE0      		ldi r22,lo8(12)
 1862 05c4 00D0      		rcall lcd_locate
 476:main.c        ****         lcd_set_numeric((unsigned int)rpm,5,0);
 1864               	.LM198:
 1865 05c6 8091 0000 		lds r24,rpm
 1866 05ca 9091 0000 		lds r25,rpm+1
 1867 05ce 65E0      		ldi r22,lo8(5)
 1868 05d0 70E0      		ldi r23,hi8(5)
 1869 05d2 40E0      		ldi r20,lo8(0)
 1870 05d4 50E0      		ldi r21,hi8(0)
 1871 05d6 00D0      		rcall lcd_set_numeric
 477:main.c        ****         lcd_set_str("rpm");
 1873               	.LM199:
 1874 05d8 80E0      		ldi r24,lo8(.LC26)
 1875 05da 90E0      		ldi r25,hi8(.LC26)
 1876 05dc 00D0      		rcall lcd_set_str
 478:main.c        **** 
 479:main.c        **** /*
 480:main.c        ****         lcd_locate(0,0); // debug
 481:main.c        ****         lcd_set_numeric((unsigned int)cnt,7); // debug
 482:main.c        ****         
 483:main.c        ****         lcd_locate(2,12);
 484:main.c        ****         lcd_set_numeric((unsigned int)FPDcomp,8);
 485:main.c        ****  */
 486:main.c        ****         lcd_locate(3,12);
 1878               	.LM200:
 1879 05de 83E0      		ldi r24,lo8(3)
 1880 05e0 6CE0      		ldi r22,lo8(12)
 1881 05e2 00D0      		rcall lcd_locate
 487:main.c        ****         BarMeter_disp((unsigned int)rpm);
 1883               	.LM201:
 1884 05e4 8091 0000 		lds r24,rpm
 1885 05e8 9091 0000 		lds r25,rpm+1
 1886 05ec 00D0      		rcall BarMeter_disp
 1887               	.LBB30:
 1888               	.LBB31:
 1890               	.Ltext13:
 1892               	.LM202:
 1893 05ee 8FE1      		 ldi r24,lo8(19999)
 1894 05f0 9EE4      	    ldi r25,hi8(19999)
 1895 05f2 0197      	    1:sbiw r24,1
 1896 05f4 01F4      	    brne 1b
 1897 05f6 00C0      		rjmp .
 1898 05f8 0000      		nop
 1899 05fa 00C0      		rjmp .L69
 1900               	.LBE31:
 1901               	.LBE30:
 1902               	.LBE27:
 1918               	.Lscope11:
 1919               	.global	tacho_n
 1920               	.global	tacho_n
 1921               		.section .bss
 1924               	tacho_n:
 1925 0000 0000      		.skip 2,0
 1926               		.comm proc_array,36,1
 1927               		.comm meas_array,36,1
 1928               		.comm rpm,4,1
 1929               	.global	maxv
 1930               	.global	maxv
 1933               	maxv:
 1934 0002 0000 0000 		.skip 4,0
 1935               	.global	minv
 1936               		.data
 1939               	minv:
 1940 00dd FF        		.byte	-1
 1941 00de FF        		.byte	-1
 1942 00df 00        		.byte	0
 1943 00e0 00        		.byte	0
 1944               		.comm freq,4,1
 1945               		.comm cnt,4,1
 1946               		.comm data,16,1
 1947               	.global	lcd_update
 1950               	lcd_update:
 1951 00e1 01        		.byte	1
 1952               		.comm RxNameLength,7,1
 1953               		.comm RxName_long,14,1
 1954               		.comm RxName_short,14,1
 1955               		.comm RxName,14,1
 1956               		.comm t_id,4,1
 1957               	.global	RxID
 1960               	RxID:
 1961 00e2 01        		.byte	1
 1962 00e3 02        		.byte	2
 1963 00e4 03        		.byte	3
 1964 00e5 04        		.byte	4
 1965 00e6 05        		.byte	5
 1966 00e7 07        		.byte	7
 1967 00e8 0F        		.byte	15
 1968               	.global	chg_count
 1971               	chg_count:
 1972 00e9 FFFF      		.word	-1
 1973               	.global	chg_index
 1976               	chg_index:
 1977 00eb 04        		.byte	4
 1996               		.text
 1998               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:107    .text:00000000 set_initial_t_id
                            *COM*:00000004 t_id
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:139    .text:00000018 timer1_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:180    .text:00000042 PWM_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:216    .text:00000056 StrLength
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:256    .text:0000006c BubbleSort
                            *COM*:00000024 proc_array
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:392    .text:00000122 DisplayItemInfo
                            *COM*:0000000e RxName
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:442    .text:00000154 __vector_18
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1960   .data:000000e2 RxID
                            *COM*:00000010 data
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:564    .text:000001f6 __vector_1
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1924   .bss:00000000 tacho_n
                            *COM*:00000024 meas_array
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:646    .text:00000276 __vector_13
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:731    .text:000002f0 __vector_default
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:846    .text.startup:00000000 main
                            *COM*:0000000e RxName_short
                            *COM*:0000000e RxName_long
                            *COM*:00000007 RxNameLength
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1950   .data:000000e1 lcd_update
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1976   .data:000000eb chg_index
                            *COM*:00000004 cnt
                            *COM*:00000004 freq
                            *COM*:00000004 rpm
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1933   .bss:00000002 maxv
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1939   .data:000000dd minv
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccwqkxWj.s:1971   .data:000000e9 chg_count

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
lcd_locate
lcd_set_str
USART_receive
SoftSPI_Init
lcd_init
USARTinit
ExtInterrupt_init
BarMeter_init
lcd_set_char
__floatunsisf
__divsf3
__mulsf3
__floatsisf
__addsf3
__ltsf2
__fixunssfsi
lcd_set_numeric
BarMeter_disp
