   1               		.file	"lcd_595_softspi.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	SoftSPI_Init
 107               	SoftSPI_Init:
   1:lcd_595_softspi.c **** // LCD Control Functions
   2:lcd_595_softspi.c **** // Target : ATMEGA88 (ATMEGA168)
   3:lcd_595_softspi.c **** // Clock  : 1MHz (Fuse : CKDIV8 = 0, Fullswing crystal)
   4:lcd_595_softspi.c **** //
   5:lcd_595_softspi.c **** 
   6:lcd_595_softspi.c **** #include <avr/io.h>
   7:lcd_595_softspi.c **** #include <util/delay.h>
   8:lcd_595_softspi.c **** #include <avr/interrupt.h>
   9:lcd_595_softspi.c **** #include "lcd_595_softspi.h"
  10:lcd_595_softspi.c **** 
  11:lcd_595_softspi.c **** // SPI port Dfinition
  12:lcd_595_softspi.c **** #define DDR_SPI         DDRB
  13:lcd_595_softspi.c **** #define PORT_SPI        PORTB
  14:lcd_595_softspi.c **** #define DD_MOSI         PB3
  15:lcd_595_softspi.c **** #define DD_SCK          PB5
  16:lcd_595_softspi.c **** #define DD_RCK          PB2
  17:lcd_595_softspi.c **** 
  18:lcd_595_softspi.c **** unsigned char E;
  19:lcd_595_softspi.c **** unsigned char RS;
  20:lcd_595_softspi.c **** unsigned char DATA;
  21:lcd_595_softspi.c **** 
  22:lcd_595_softspi.c **** void SoftSPI_Init(void){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  23:lcd_595_softspi.c ****     /*MOSI,SCK=出力、他は入力に設定 */
  24:lcd_595_softspi.c ****     DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_RCK);
 116               	.LM1:
 117 0000 84B1      		in r24,36-32
 118 0002 8C62      		ori r24,lo8(44)
 119 0004 84B9      		out 36-32,r24
 120               	/* epilogue start */
  25:lcd_595_softspi.c **** }
 122               	.LM2:
 123 0006 0895      		ret
 125               	.Lscope1:
 128               	.global	SoftSPI_TX
 130               	SoftSPI_TX:
  26:lcd_595_softspi.c **** 
  27:lcd_595_softspi.c **** void SoftSPI_TX(unsigned char cData){
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 139               	.LM4:
 140 0008 27E0      		ldi r18,lo8(7)
 141 000a 30E0      		ldi r19,hi8(7)
  28:lcd_595_softspi.c ****     unsigned int n;
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
  31:lcd_595_softspi.c ****         _delay_us(1);
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
  33:lcd_595_softspi.c ****         PORT_SPI |= (0x01&(cData>>(7-n)))<<DD_MOSI; // Set Data bit
 143               	.LM5:
 144 000c 90E0      		ldi r25,lo8(0)
 145               	.L3:
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
 147               	.LM6:
 148 000e 2D98      		cbi 37-32,5
 149               	.LBB34:
 150               	.LBB35:
 152               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 154               	.LM7:
 155 0010 42E0      		 ldi r20,lo8(2)
 156 0012 4A95      	    1:dec r20
 157 0014 01F4      	    brne 1b
 158 0016 00C0      		rjmp .
 159               	.LBE35:
 160               	.LBE34:
 162               	.Ltext2:
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
 164               	.LM8:
 165 0018 2B98      		cbi 37-32,3
 167               	.LM9:
 168 001a 65B1      		in r22,37-32
 169 001c AC01      		movw r20,r24
 170 001e 022E      		mov r0,r18
 171 0020 00C0      		rjmp 2f
 172 0022 5595      	1:	asr r21
 173 0024 4795      		ror r20
 174 0026 0A94      	2:	dec r0
 175 0028 02F4      		brpl 1b
 176 002a 4170      		andi r20,lo8(1)
 177 002c 5070      		andi r21,hi8(1)
 178 002e 73E0      		ldi r23,3
 179 0030 440F      	1:	lsl r20
 180 0032 551F      		rol r21
 181 0034 7A95      		dec r23
 182 0036 01F4      		brne 1b
 183 0038 642B      		or r22,r20
 184 003a 65B9      		out 37-32,r22
 185               	.LBB36:
 186               	.LBB37:
 188               	.Ltext3:
 190               	.LM10:
 191 003c 42E0      		 ldi r20,lo8(2)
 192 003e 4A95      	    1:dec r20
 193 0040 01F4      	    brne 1b
 194 0042 00C0      		rjmp .
 195               	.LBE37:
 196               	.LBE36:
 198               	.Ltext4:
  34:lcd_595_softspi.c ****         _delay_us(1);
  35:lcd_595_softspi.c ****         PORT_SPI |= (1<<DD_SCK);                // Set SCK "H"
 200               	.LM11:
 201 0044 2D9A      		sbi 37-32,5
 202               	.LBB38:
 203               	.LBB39:
 205               	.Ltext5:
 207               	.LM12:
 208 0046 42E0      		 ldi r20,lo8(2)
 209 0048 4A95      	    1:dec r20
 210 004a 01F4      	    brne 1b
 211 004c 00C0      		rjmp .
 212 004e 2150      		subi r18,lo8(-(-1))
 213 0050 3040      		sbci r19,hi8(-(-1))
 214               	.LBE39:
 215               	.LBE38:
 217               	.Ltext6:
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
 219               	.LM13:
 220 0052 4FEF      		ldi r20,hi8(-1)
 221 0054 2F3F      		cpi r18,lo8(-1)
 222 0056 3407      		cpc r19,r20
 223 0058 01F4      		brne .L3
 224               	/* epilogue start */
  36:lcd_595_softspi.c ****         _delay_us(1);
  37:lcd_595_softspi.c ****     }
  38:lcd_595_softspi.c **** }
 226               	.LM14:
 227 005a 0895      		ret
 229               	.Lscope2:
 234               	.global	send_bits_595
 236               	send_bits_595:
  39:lcd_595_softspi.c **** 
  40:lcd_595_softspi.c **** void send_bits_595(unsigned char RS, unsigned char E, unsigned char DATA){
 238               	.LM15:
 239               	.LFBB3:
 240               	/* prologue: function */
 241               	/* frame size = 0 */
 242               	/* stack size = 0 */
 243               	.L__stack_usage = 0
  41:lcd_595_softspi.c ****     unsigned char bits;
  42:lcd_595_softspi.c ****     bits = 0x3f & ( (RS<<5)|(E<<4)|DATA );
 245               	.LM16:
 246 005c 8295      		swap r24
 247 005e 880F      		lsl r24
 248 0060 807E      		andi r24,lo8(-32)
 249 0062 842B      		or r24,r20
 250 0064 6295      		swap r22
 251 0066 607F      		andi r22,lo8(-16)
 252 0068 682B      		or r22,r24
  43:lcd_595_softspi.c ****     SoftSPI_TX(bits);
 254               	.LM17:
 255 006a 862F      		mov r24,r22
 256 006c 8F73      		andi r24,lo8(63)
 257 006e 00D0      		rcall SoftSPI_TX
 258               	.LBB40:
 259               	.LBB41:
 261               	.Ltext7:
 263               	.LM18:
 264 0070 8AE1      		 ldi r24,lo8(26)
 265 0072 8A95      	    1:dec r24
 266 0074 01F4      	    brne 1b
 267 0076 00C0      		rjmp .
 268               	.LBE41:
 269               	.LBE40:
 271               	.Ltext8:
  44:lcd_595_softspi.c ****     _delay_us(10);
  45:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 273               	.LM19:
 274 0078 2A98      		cbi 37-32,2
  46:lcd_595_softspi.c ****     PORT_SPI |=  (1<<DD_RCK);   // Set RCK "H"
 276               	.LM20:
 277 007a 2A9A      		sbi 37-32,2
  47:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 279               	.LM21:
 280 007c 2A98      		cbi 37-32,2
 281               	/* epilogue start */
  48:lcd_595_softspi.c **** }
 283               	.LM22:
 284 007e 0895      		ret
 286               	.Lscope3:
 289               	.global	lcd_set_4bit
 291               	lcd_set_4bit:
  49:lcd_595_softspi.c **** 
  50:lcd_595_softspi.c **** // fuction for sending control bitpattern
  51:lcd_595_softspi.c **** void lcd_set_4bit(unsigned char bitpattern){
 293               	.LM23:
 294               	.LFBB4:
 295               	/* prologue: function */
 296               	/* frame size = 0 */
 297               	/* stack size = 0 */
 298               	.L__stack_usage = 0
  52:lcd_595_softspi.c **** 	DATA    =   0x0f & bitpattern; // set sending data
 300               	.LM24:
 301 0080 482F      		mov r20,r24
 302 0082 4F70      		andi r20,lo8(15)
 303 0084 4093 0000 		sts DATA,r20
  53:lcd_595_softspi.c **** 	E       =   0;
 305               	.LM25:
 306 0088 1092 0000 		sts E,__zero_reg__
  54:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 308               	.LM26:
 309 008c 8091 0000 		lds r24,RS
 310 0090 60E0      		ldi r22,lo8(0)
 311 0092 00D0      		rcall send_bits_595
  55:lcd_595_softspi.c **** //	_delay_us(20);
  56:lcd_595_softspi.c **** 	E       =   1;
 313               	.LM27:
 314 0094 81E0      		ldi r24,lo8(1)
 315 0096 8093 0000 		sts E,r24
  57:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 317               	.LM28:
 318 009a 8091 0000 		lds r24,RS
 319 009e 61E0      		ldi r22,lo8(1)
 320 00a0 4091 0000 		lds r20,DATA
 321 00a4 00D0      		rcall send_bits_595
  58:lcd_595_softspi.c **** //	_delay_us(20);
  59:lcd_595_softspi.c **** 	E       =   0;
 323               	.LM29:
 324 00a6 1092 0000 		sts E,__zero_reg__
  60:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 326               	.LM30:
 327 00aa 8091 0000 		lds r24,RS
 328 00ae 60E0      		ldi r22,lo8(0)
 329 00b0 4091 0000 		lds r20,DATA
 330 00b4 00D0      		rcall send_bits_595
 331               	/* epilogue start */
  61:lcd_595_softspi.c **** //	_delay_us(20);
  62:lcd_595_softspi.c **** }
 333               	.LM31:
 334 00b6 0895      		ret
 336               	.Lscope4:
 338               	.global	lcd_init
 340               	lcd_init:
  63:lcd_595_softspi.c **** 
  64:lcd_595_softspi.c **** // Initializing LCD
  65:lcd_595_softspi.c **** void lcd_init(void){
 342               	.LM32:
 343               	.LFBB5:
 344               	/* prologue: function */
 345               	/* frame size = 0 */
 346               	/* stack size = 0 */
 347               	.L__stack_usage = 0
  66:lcd_595_softspi.c **** 
  67:lcd_595_softspi.c **** 	// set enable "0"
  68:lcd_595_softspi.c ****     E       = 0;
 349               	.LM33:
 350 00b8 1092 0000 		sts E,__zero_reg__
  69:lcd_595_softspi.c ****     // set instruction input mode
  70:lcd_595_softspi.c **** 	RS      = 0;
 352               	.LM34:
 353 00bc 1092 0000 		sts RS,__zero_reg__
  71:lcd_595_softspi.c **** 	// initialize data port
  72:lcd_595_softspi.c **** 	DATA	= 0x00;
 355               	.LM35:
 356 00c0 1092 0000 		sts DATA,__zero_reg__
  73:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 358               	.LM36:
 359 00c4 80E0      		ldi r24,lo8(0)
 360 00c6 60E0      		ldi r22,lo8(0)
 361 00c8 40E0      		ldi r20,lo8(0)
 362 00ca 00D0      		rcall send_bits_595
 363               	.LBB42:
 364               	.LBB43:
 366               	.Ltext9:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 368               	.LM37:
 369 00cc 8FE3      		 ldi r24,lo8(-25537)
 370 00ce 9CE9      	    ldi r25,hi8(-25537)
 371 00d0 0197      	    1:sbiw r24,1
 372 00d2 01F4      	    brne 1b
 373 00d4 00C0      		rjmp .
 374 00d6 0000      		nop
 375               	.LBE43:
 376               	.LBE42:
 378               	.Ltext10:
  74:lcd_595_softspi.c ****     
  75:lcd_595_softspi.c **** 	// wait more than 15ms
  76:lcd_595_softspi.c **** 	_delay_ms(20);
  77:lcd_595_softspi.c **** 
  78:lcd_595_softspi.c **** 	// set 8-bit mode
  79:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 380               	.LM38:
 381 00d8 83E0      		ldi r24,lo8(3)
 382 00da 00D0      		rcall lcd_set_4bit
 383               	.LBB44:
 384               	.LBB45:
 386               	.Ltext11:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 388               	.LM39:
 389 00dc 8FE0      		 ldi r24,lo8(9999)
 390 00de 97E2      	    ldi r25,hi8(9999)
 391 00e0 0197      	    1:sbiw r24,1
 392 00e2 01F4      	    brne 1b
 393 00e4 00C0      		rjmp .
 394 00e6 0000      		nop
 395               	.LBE45:
 396               	.LBE44:
 398               	.Ltext12:
  80:lcd_595_softspi.c **** 	_delay_ms(5);
  81:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 400               	.LM40:
 401 00e8 83E0      		ldi r24,lo8(3)
 402 00ea 00D0      		rcall lcd_set_4bit
 403               	.LBB46:
 404               	.LBB47:
 406               	.Ltext13:
 408               	.LM41:
 409 00ec 8BED      		 ldi r24,lo8(219)
 410 00ee 90E0      	    ldi r25,hi8(219)
 411 00f0 0197      	    1:sbiw r24,1
 412 00f2 01F4      	    brne 1b
 413 00f4 00C0      		rjmp .
 414 00f6 0000      		nop
 415               	.LBE47:
 416               	.LBE46:
 418               	.Ltext14:
  82:lcd_595_softspi.c **** 	_delay_us(110);
  83:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 420               	.LM42:
 421 00f8 83E0      		ldi r24,lo8(3)
 422 00fa 00D0      		rcall lcd_set_4bit
 423               	.LBB48:
 424               	.LBB49:
 426               	.Ltext15:
 428               	.LM43:
 429 00fc 95E8      		 ldi r25,lo8(-123)
 430 00fe 9A95      	    1:dec r25
 431 0100 01F4      	    brne 1b
 432 0102 0000      		nop
 433               	.LBE49:
 434               	.LBE48:
 436               	.Ltext16:
  84:lcd_595_softspi.c **** 	_delay_us(50);
  85:lcd_595_softspi.c **** 	
  86:lcd_595_softspi.c **** 	// set 4-bit mode
  87:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 438               	.LM44:
 439 0104 82E0      		ldi r24,lo8(2)
 440 0106 00D0      		rcall lcd_set_4bit
 441               	.LBB50:
 442               	.LBB51:
 444               	.Ltext17:
 446               	.LM45:
 447 0108 85E8      		 ldi r24,lo8(-123)
 448 010a 8A95      	    1:dec r24
 449 010c 01F4      	    brne 1b
 450 010e 0000      		nop
 451               	.LBE51:
 452               	.LBE50:
 454               	.Ltext18:
  88:lcd_595_softspi.c **** 	_delay_us(50);
  89:lcd_595_softspi.c **** 
  90:lcd_595_softspi.c **** 	// function setting
  91:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 456               	.LM46:
 457 0110 82E0      		ldi r24,lo8(2)
 458 0112 00D0      		rcall lcd_set_4bit
  92:lcd_595_softspi.c **** 	lcd_set_4bit(0x08);
 460               	.LM47:
 461 0114 88E0      		ldi r24,lo8(8)
 462 0116 00D0      		rcall lcd_set_4bit
 463               	.LBB52:
 464               	.LBB53:
 466               	.Ltext19:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 468               	.LM48:
 469 0118 8FEC      		 ldi r24,lo8(1999)
 470 011a 97E0      	    ldi r25,hi8(1999)
 471 011c 0197      	    1:sbiw r24,1
 472 011e 01F4      	    brne 1b
 473 0120 00C0      		rjmp .
 474 0122 0000      		nop
 475               	.LBE53:
 476               	.LBE52:
 478               	.Ltext20:
  93:lcd_595_softspi.c **** 	_delay_ms(1);
  94:lcd_595_softspi.c **** 
  95:lcd_595_softspi.c **** 	// set display off, cursol off and blink off
  96:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 480               	.LM49:
 481 0124 80E0      		ldi r24,lo8(0)
 482 0126 00D0      		rcall lcd_set_4bit
  97:lcd_595_softspi.c **** 	lcd_set_4bit(0x0c);
 484               	.LM50:
 485 0128 8CE0      		ldi r24,lo8(12)
 486 012a 00D0      		rcall lcd_set_4bit
 487               	.LBB54:
 488               	.LBB55:
 490               	.Ltext21:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 492               	.LM51:
 493 012c 8FEC      		 ldi r24,lo8(1999)
 494 012e 97E0      	    ldi r25,hi8(1999)
 495 0130 0197      	    1:sbiw r24,1
 496 0132 01F4      	    brne 1b
 497 0134 00C0      		rjmp .
 498 0136 0000      		nop
 499               	.LBE55:
 500               	.LBE54:
 502               	.Ltext22:
  98:lcd_595_softspi.c **** 	_delay_ms(1);
  99:lcd_595_softspi.c **** 
 100:lcd_595_softspi.c **** 	// set entry mode (cursol direction : right, disable shift)
 101:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 504               	.LM52:
 505 0138 80E0      		ldi r24,lo8(0)
 506 013a 00D0      		rcall lcd_set_4bit
 102:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 508               	.LM53:
 509 013c 83E0      		ldi r24,lo8(3)
 510 013e 00D0      		rcall lcd_set_4bit
 511               	.LBB56:
 512               	.LBB57:
 514               	.Ltext23:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 516               	.LM54:
 517 0140 8FEC      		 ldi r24,lo8(1999)
 518 0142 97E0      	    ldi r25,hi8(1999)
 519 0144 0197      	    1:sbiw r24,1
 520 0146 01F4      	    brne 1b
 521 0148 00C0      		rjmp .
 522 014a 0000      		nop
 523               	.LBE57:
 524               	.LBE56:
 526               	.Ltext24:
 103:lcd_595_softspi.c **** 	_delay_ms(1);
 104:lcd_595_softspi.c **** 
 105:lcd_595_softspi.c **** 	// clear display
 106:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 528               	.LM55:
 529 014c 80E0      		ldi r24,lo8(0)
 530 014e 00D0      		rcall lcd_set_4bit
 107:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 532               	.LM56:
 533 0150 81E0      		ldi r24,lo8(1)
 534 0152 00D0      		rcall lcd_set_4bit
 535               	.LBB58:
 536               	.LBB59:
 538               	.Ltext25:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 540               	.LM57:
 541 0154 8FE9      		 ldi r24,lo8(3999)
 542 0156 9FE0      	    ldi r25,hi8(3999)
 543 0158 0197      	    1:sbiw r24,1
 544 015a 01F4      	    brne 1b
 545 015c 00C0      		rjmp .
 546 015e 0000      		nop
 547               	.LBE59:
 548               	.LBE58:
 550               	.Ltext26:
 108:lcd_595_softspi.c **** 	_delay_ms(2);
 109:lcd_595_softspi.c **** 
 110:lcd_595_softspi.c **** 	// clear cursol position
 111:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 552               	.LM58:
 553 0160 80E0      		ldi r24,lo8(0)
 554 0162 00D0      		rcall lcd_set_4bit
 112:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 556               	.LM59:
 557 0164 82E0      		ldi r24,lo8(2)
 558 0166 00D0      		rcall lcd_set_4bit
 559               	.LBB60:
 560               	.LBB61:
 562               	.Ltext27:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 564               	.LM60:
 565 0168 8FE9      		 ldi r24,lo8(3999)
 566 016a 9FE0      	    ldi r25,hi8(3999)
 567 016c 0197      	    1:sbiw r24,1
 568 016e 01F4      	    brne 1b
 569 0170 00C0      		rjmp .
 570 0172 0000      		nop
 571               	.LBE61:
 572               	.LBE60:
 574               	.Ltext28:
 113:lcd_595_softspi.c **** 	_delay_ms(2);
 114:lcd_595_softspi.c **** 
 115:lcd_595_softspi.c **** 	// set data input mode
 116:lcd_595_softspi.c ****     RS      =   1;
 576               	.LM61:
 577 0174 81E0      		ldi r24,lo8(1)
 578 0176 8093 0000 		sts RS,r24
 579               	/* epilogue start */
 117:lcd_595_softspi.c **** }
 581               	.LM62:
 582 017a 0895      		ret
 584               	.Lscope5:
 587               	.global	lcd_set_char
 589               	lcd_set_char:
 118:lcd_595_softspi.c **** 
 119:lcd_595_softspi.c **** // LCD character allocation
 120:lcd_595_softspi.c **** void lcd_locate(unsigned char row, unsigned char col)
 121:lcd_595_softspi.c **** {
 122:lcd_595_softspi.c **** 	// set instruction input mode
 123:lcd_595_softspi.c ****     RS      =   0;
 124:lcd_595_softspi.c **** 	lcd_set_char(0x80 | col | (0x40 * row) );
 125:lcd_595_softspi.c **** 	// set data input mode
 126:lcd_595_softspi.c ****     RS      =   1;
 127:lcd_595_softspi.c **** }
 128:lcd_595_softspi.c **** 
 129:lcd_595_softspi.c **** // LCD character (1 byte) sending
 130:lcd_595_softspi.c **** void lcd_set_char(unsigned char c)
 131:lcd_595_softspi.c **** {
 591               	.LM63:
 592               	.LFBB6:
 593 017c CF93      		push r28
 594               	/* prologue: function */
 595               	/* frame size = 0 */
 596               	/* stack size = 1 */
 597               	.L__stack_usage = 1
 598 017e C82F      		mov r28,r24
 132:lcd_595_softspi.c **** 	lcd_set_4bit(c >> 4); // Upper Bit
 600               	.LM64:
 601 0180 8295      		swap r24
 602 0182 8F70      		andi r24,lo8(15)
 603 0184 00D0      		rcall lcd_set_4bit
 133:lcd_595_softspi.c **** 	lcd_set_4bit(0x0f & c); // Lower Bit
 605               	.LM65:
 606 0186 8C2F      		mov r24,r28
 607 0188 8F70      		andi r24,lo8(15)
 608 018a 00D0      		rcall lcd_set_4bit
 609               	.LBB62:
 610               	.LBB63:
 612               	.Ltext29:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 614               	.LM66:
 615 018c 8FEC      		 ldi r24,lo8(1999)
 616 018e 97E0      	    ldi r25,hi8(1999)
 617 0190 0197      	    1:sbiw r24,1
 618 0192 01F4      	    brne 1b
 619 0194 00C0      		rjmp .
 620 0196 0000      		nop
 621               	/* epilogue start */
 622               	.LBE63:
 623               	.LBE62:
 625               	.Ltext30:
 134:lcd_595_softspi.c **** 	_delay_ms(1);
 135:lcd_595_softspi.c **** }
 627               	.LM67:
 628 0198 CF91      		pop r28
 629 019a 0895      		ret
 631               	.Lscope6:
 635               	.global	lcd_locate
 637               	lcd_locate:
 121:lcd_595_softspi.c **** {
 639               	.LM68:
 640               	.LFBB7:
 641               	/* prologue: function */
 642               	/* frame size = 0 */
 643               	/* stack size = 0 */
 644               	.L__stack_usage = 0
 123:lcd_595_softspi.c ****     RS      =   0;
 646               	.LM69:
 647 019c 1092 0000 		sts RS,__zero_reg__
 124:lcd_595_softspi.c **** 	lcd_set_char(0x80 | col | (0x40 * row) );
 649               	.LM70:
 650 01a0 6068      		ori r22,lo8(-128)
 651 01a2 8295      		swap r24
 652 01a4 880F      		lsl r24
 653 01a6 880F      		lsl r24
 654 01a8 807C      		andi r24,lo8(-64)
 655 01aa 862B      		or r24,r22
 656 01ac 00D0      		rcall lcd_set_char
 126:lcd_595_softspi.c ****     RS      =   1;
 658               	.LM71:
 659 01ae 81E0      		ldi r24,lo8(1)
 660 01b0 8093 0000 		sts RS,r24
 661               	/* epilogue start */
 127:lcd_595_softspi.c **** }
 663               	.LM72:
 664 01b4 0895      		ret
 666               	.Lscope7:
 668               	.global	lcd_set_str
 670               	lcd_set_str:
 136:lcd_595_softspi.c **** 
 137:lcd_595_softspi.c **** // LCD String Sending
 138:lcd_595_softspi.c **** void lcd_set_str(unsigned char *s)
 139:lcd_595_softspi.c **** {
 672               	.LM73:
 673               	.LFBB8:
 674 01b6 CF93      		push r28
 675 01b8 DF93      		push r29
 676               	/* prologue: function */
 677               	/* frame size = 0 */
 678               	/* stack size = 2 */
 679               	.L__stack_usage = 2
 681               	.LM74:
 682 01ba EC01      		movw r28,r24
 140:lcd_595_softspi.c **** 	while (*s != 0) {
 684               	.LM75:
 685 01bc 00C0      		rjmp .L11
 686               	.L12:
 141:lcd_595_softspi.c **** 		lcd_set_char(*s);
 688               	.LM76:
 689 01be 00D0      		rcall lcd_set_char
 690               	.L11:
 140:lcd_595_softspi.c **** 	while (*s != 0) {
 692               	.LM77:
 693 01c0 8991      		ld r24,Y+
 694 01c2 8823      		tst r24
 695 01c4 01F4      		brne .L12
 696               	/* epilogue start */
 142:lcd_595_softspi.c **** 		s++;
 143:lcd_595_softspi.c **** 	} 
 144:lcd_595_softspi.c **** }
 698               	.LM78:
 699 01c6 DF91      		pop r29
 700 01c8 CF91      		pop r28
 701 01ca 0895      		ret
 703               	.Lscope8:
 707               	.global	lcd_set_numeric
 709               	lcd_set_numeric:
 145:lcd_595_softspi.c **** 
 146:lcd_595_softspi.c **** // Display numeric on LCD display
 147:lcd_595_softspi.c **** void lcd_set_numeric(unsigned int num, unsigned int Ndig){
 711               	.LM79:
 712               	.LFBB9:
 713 01cc 4F92      		push r4
 714 01ce 5F92      		push r5
 715 01d0 6F92      		push r6
 716 01d2 7F92      		push r7
 717 01d4 8F92      		push r8
 718 01d6 9F92      		push r9
 719 01d8 AF92      		push r10
 720 01da BF92      		push r11
 721 01dc CF92      		push r12
 722 01de DF92      		push r13
 723 01e0 EF92      		push r14
 724 01e2 FF92      		push r15
 725 01e4 0F93      		push r16
 726 01e6 1F93      		push r17
 727 01e8 CF93      		push r28
 728 01ea DF93      		push r29
 729               	/* prologue: function */
 730               	/* frame size = 0 */
 731               	/* stack size = 16 */
 732               	.L__stack_usage = 16
 733 01ec 5C01      		movw r10,r24
 734 01ee 3B01      		movw r6,r22
 148:lcd_595_softspi.c ****     unsigned long int DivFactor = 1;
 149:lcd_595_softspi.c **** 	unsigned int n, m;
 150:lcd_595_softspi.c **** 	unsigned int d[10];
 151:lcd_595_softspi.c ****     unsigned int valid = 0;
 152:lcd_595_softspi.c ****     for(n=0;n<=Ndig-1;n++){
 736               	.LM80:
 737 01f0 00E0      		ldi r16,lo8(0)
 738 01f2 10E0      		ldi r17,hi8(0)
 151:lcd_595_softspi.c ****     unsigned int valid = 0;
 740               	.LM81:
 741 01f4 8824      		clr r8
 742 01f6 9924      		clr r9
 744               	.LM82:
 745 01f8 2B01      		movw r4,r22
 746 01fa 0894      		sec
 747 01fc 4108      		sbc r4,__zero_reg__
 748 01fe 5108      		sbc r5,__zero_reg__
 749 0200 00C0      		rjmp .L14
 750               	.L15:
 153:lcd_595_softspi.c ****         
 154:lcd_595_softspi.c ****         DivFactor = 1;
 155:lcd_595_softspi.c ****         for(m=n+1;m<Ndig;m++){
 156:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 752               	.LM83:
 753 0202 C701      		movw r24,r14
 754 0204 B601      		movw r22,r12
 755 0206 2AE0      		ldi r18,lo8(10)
 756 0208 30E0      		ldi r19,hi8(10)
 757 020a 40E0      		ldi r20,hlo8(10)
 758 020c 50E0      		ldi r21,hhi8(10)
 759 020e 00D0      		rcall __mulsi3
 760 0210 6B01      		movw r12,r22
 761 0212 7C01      		movw r14,r24
 762 0214 00C0      		rjmp .L23
 763               	.L24:
 152:lcd_595_softspi.c ****     for(n=0;n<=Ndig-1;n++){
 765               	.LM84:
 766 0216 E801      		movw r28,r16
 767 0218 F1E0      		ldi r31,lo8(1)
 768 021a CF2E      		mov r12,r31
 769 021c D12C      		mov r13,__zero_reg__
 770 021e E12C      		mov r14,__zero_reg__
 771 0220 F12C      		mov r15,__zero_reg__
 772               	.L23:
 774               	.LM85:
 775 0222 2196      		adiw r28,1
 155:lcd_595_softspi.c ****         for(m=n+1;m<Ndig;m++){
 777               	.LM86:
 778 0224 C615      		cp r28,r6
 779 0226 D705      		cpc r29,r7
 780 0228 00F0      		brlo .L15
 157:lcd_595_softspi.c ****         }
 158:lcd_595_softspi.c ****         
 159:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 782               	.LM87:
 783 022a B501      		movw r22,r10
 784 022c 80E0      		ldi r24,lo8(0)
 785 022e 90E0      		ldi r25,hi8(0)
 786 0230 A701      		movw r20,r14
 787 0232 9601      		movw r18,r12
 788 0234 00D0      		rcall __udivmodsi4
 160:lcd_595_softspi.c ****         if( (valid == 0) & (d[n]!=0) ) valid = 1;
 790               	.LM88:
 791 0236 2115      		cp r18,__zero_reg__
 792 0238 3105      		cpc r19,__zero_reg__
 793 023a 01F0      		breq .L16
 794 023c 8114      		cp r8,__zero_reg__
 795 023e 9104      		cpc r9,__zero_reg__
 796 0240 01F4      		brne .L16
 797 0242 E1E0      		ldi r30,lo8(1)
 798 0244 8E2E      		mov r8,r30
 799 0246 912C      		mov r9,__zero_reg__
 800               	.L16:
 161:lcd_595_softspi.c ****         num = num - d[n]*DivFactor;
 802               	.LM89:
 803 0248 2C9D      		mul r18,r12
 804 024a C001      		movw r24,r0
 805 024c 2D9D      		mul r18,r13
 806 024e 900D      		add r25,r0
 807 0250 3C9D      		mul r19,r12
 808 0252 900D      		add r25,r0
 809 0254 1124      		clr r1
 810 0256 A81A      		sub r10,r24
 811 0258 B90A      		sbc r11,r25
 162:lcd_595_softspi.c ****         
 163:lcd_595_softspi.c ****         if( (valid == 1)|(n == Ndig-1) )    lcd_set_char(0x30 + d[n]);
 813               	.LM90:
 814 025a 8114      		cp r8,__zero_reg__
 815 025c 9104      		cpc r9,__zero_reg__
 816 025e 01F4      		brne .L25
 817 0260 0415      		cp r16,r4
 818 0262 1505      		cpc r17,r5
 819 0264 01F4      		brne .L28
 820               	.L25:
 822               	.LM91:
 823 0266 822F      		mov r24,r18
 824 0268 805D      		subi r24,lo8(-(48))
 825 026a 00C0      		rjmp .L29
 826               	.L28:
 164:lcd_595_softspi.c ****         else if( valid == 0 )               lcd_set_char(0x20);
 828               	.LM92:
 829 026c 80E2      		ldi r24,lo8(32)
 830               	.L29:
 831 026e 00D0      		rcall lcd_set_char
 832 0270 0F5F      		subi r16,lo8(-(1))
 833 0272 1F4F      		sbci r17,hi8(-(1))
 834               	.L14:
 152:lcd_595_softspi.c ****     for(n=0;n<=Ndig-1;n++){
 836               	.LM93:
 837 0274 4016      		cp r4,r16
 838 0276 5106      		cpc r5,r17
 839 0278 00F4      		brsh .L24
 840               	/* epilogue start */
 165:lcd_595_softspi.c ****         else                                lcd_set_char(0xff);
 166:lcd_595_softspi.c ****     }
 167:lcd_595_softspi.c **** }
 842               	.LM94:
 843 027a DF91      		pop r29
 844 027c CF91      		pop r28
 845 027e 1F91      		pop r17
 846 0280 0F91      		pop r16
 847 0282 FF90      		pop r15
 848 0284 EF90      		pop r14
 849 0286 DF90      		pop r13
 850 0288 CF90      		pop r12
 851 028a BF90      		pop r11
 852 028c AF90      		pop r10
 853 028e 9F90      		pop r9
 854 0290 8F90      		pop r8
 855 0292 7F90      		pop r7
 856 0294 6F90      		pop r6
 857 0296 5F90      		pop r5
 858 0298 4F90      		pop r4
 859 029a 0895      		ret
 865               	.Lscope9:
 867               	.global	lcd_clear
 869               	lcd_clear:
 168:lcd_595_softspi.c **** 
 169:lcd_595_softspi.c **** // Clear LCD
 170:lcd_595_softspi.c **** void lcd_clear(){
 871               	.LM95:
 872               	.LFBB10:
 873               	/* prologue: function */
 874               	/* frame size = 0 */
 875               	/* stack size = 0 */
 876               	.L__stack_usage = 0
 171:lcd_595_softspi.c **** 	// clear display
 172:lcd_595_softspi.c ****     RS      =   0;
 878               	.LM96:
 879 029c 1092 0000 		sts RS,__zero_reg__
 173:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 881               	.LM97:
 882 02a0 80E0      		ldi r24,lo8(0)
 883 02a2 00D0      		rcall lcd_set_4bit
 174:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 885               	.LM98:
 886 02a4 81E0      		ldi r24,lo8(1)
 887 02a6 00D0      		rcall lcd_set_4bit
 888               	.LBB64:
 889               	.LBB65:
 891               	.Ltext31:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 893               	.LM99:
 894 02a8 8FE9      		 ldi r24,lo8(3999)
 895 02aa 9FE0      	    ldi r25,hi8(3999)
 896 02ac 0197      	    1:sbiw r24,1
 897 02ae 01F4      	    brne 1b
 898 02b0 00C0      		rjmp .
 899 02b2 0000      		nop
 900               	.LBE65:
 901               	.LBE64:
 903               	.Ltext32:
 175:lcd_595_softspi.c **** 	_delay_ms(2);
 176:lcd_595_softspi.c ****     RS      =   1;
 905               	.LM100:
 906 02b4 81E0      		ldi r24,lo8(1)
 907 02b6 8093 0000 		sts RS,r24
 177:lcd_595_softspi.c **** 	lcd_locate(0,0);
 909               	.LM101:
 910 02ba 80E0      		ldi r24,lo8(0)
 911 02bc 60E0      		ldi r22,lo8(0)
 912 02be 00D0      		rcall lcd_locate
 913               	/* epilogue start */
 178:lcd_595_softspi.c **** }
 915               	.LM102:
 916 02c0 0895      		ret
 918               	.Lscope10:
 919               		.comm DATA,1,1
 920               		.comm RS,1,1
 921               		.comm E,1,1
 926               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 lcd_595_softspi.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:107    .text:00000000 SoftSPI_Init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:130    .text:00000008 SoftSPI_TX
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:236    .text:0000005c send_bits_595
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:291    .text:00000080 lcd_set_4bit
                            *COM*:00000001 DATA
                            *COM*:00000001 E
                            *COM*:00000001 RS
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:340    .text:000000b8 lcd_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:589    .text:0000017c lcd_set_char
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:637    .text:0000019c lcd_locate
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:670    .text:000001b6 lcd_set_str
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:709    .text:000001cc lcd_set_numeric
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccu7SanL.s:869    .text:0000029c lcd_clear

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsi3
__udivmodsi4
