   1               		.file	"lcd_595_softspi.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	SoftSPI_Init
 107               	SoftSPI_Init:
   1:lcd_595_softspi.c **** // LCD Control Functions
   2:lcd_595_softspi.c **** // Target : ATMEGA88 (ATMEGA168)
   3:lcd_595_softspi.c **** // Clock  : 1MHz (Fuse : CKDIV8 = 0, Fullswing crystal)
   4:lcd_595_softspi.c **** //
   5:lcd_595_softspi.c **** 
   6:lcd_595_softspi.c **** #include <avr/io.h>
   7:lcd_595_softspi.c **** #include <util/delay.h>
   8:lcd_595_softspi.c **** #include <avr/interrupt.h>
   9:lcd_595_softspi.c **** #include "lcd_595_softspi.h"
  10:lcd_595_softspi.c **** 
  11:lcd_595_softspi.c **** // SPI port Dfinition
  12:lcd_595_softspi.c **** #define DDR_SPI         DDRB
  13:lcd_595_softspi.c **** #define PORT_SPI        PORTB
  14:lcd_595_softspi.c **** #define DD_MOSI         PB0
  15:lcd_595_softspi.c **** #define DD_SCK          PB1
  16:lcd_595_softspi.c **** #define DD_RCK          PB2
  17:lcd_595_softspi.c **** 
  18:lcd_595_softspi.c **** unsigned char E;
  19:lcd_595_softspi.c **** unsigned char RS;
  20:lcd_595_softspi.c **** unsigned char DATA;
  21:lcd_595_softspi.c **** 
  22:lcd_595_softspi.c **** void SoftSPI_Init(void){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  23:lcd_595_softspi.c ****     /*MOSI,SCK=出力、他は入力に設定 */
  24:lcd_595_softspi.c ****     DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_RCK);
 116               	.LM1:
 117 0000 84B1      		in r24,36-32
 118 0002 8760      		ori r24,lo8(7)
 119 0004 84B9      		out 36-32,r24
 120               	/* epilogue start */
  25:lcd_595_softspi.c **** }
 122               	.LM2:
 123 0006 0895      		ret
 125               	.Lscope1:
 128               	.global	SoftSPI_TX
 130               	SoftSPI_TX:
  26:lcd_595_softspi.c **** 
  27:lcd_595_softspi.c **** void SoftSPI_TX(unsigned char cData){
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 139               	.LM4:
 140 0008 27E0      		ldi r18,lo8(7)
 141 000a 30E0      		ldi r19,hi8(7)
  28:lcd_595_softspi.c ****     unsigned int n;
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
  31:lcd_595_softspi.c ****         _delay_us(1);
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
  33:lcd_595_softspi.c ****         PORT_SPI |= (0x01&(cData>>(7-n)))<<DD_MOSI; // Set Data bit
 143               	.LM5:
 144 000c 90E0      		ldi r25,lo8(0)
 145               	.L3:
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
 147               	.LM6:
 148 000e 2998      		cbi 37-32,1
 149               	.LBB34:
 150               	.LBB35:
 152               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 154               	.LM7:
 155 0010 42E0      		 ldi r20,lo8(2)
 156 0012 4A95      	    1:dec r20
 157 0014 01F4      	    brne 1b
 158 0016 00C0      		rjmp .
 159               	.LBE35:
 160               	.LBE34:
 162               	.Ltext2:
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
 164               	.LM8:
 165 0018 2898      		cbi 37-32,0
 167               	.LM9:
 168 001a 65B1      		in r22,37-32
 169 001c AC01      		movw r20,r24
 170 001e 022E      		mov r0,r18
 171 0020 00C0      		rjmp 2f
 172 0022 5595      	1:	asr r21
 173 0024 4795      		ror r20
 174 0026 0A94      	2:	dec r0
 175 0028 02F4      		brpl 1b
 176 002a 4170      		andi r20,lo8(1)
 177 002c 462B      		or r20,r22
 178 002e 45B9      		out 37-32,r20
 179               	.LBB36:
 180               	.LBB37:
 182               	.Ltext3:
 184               	.LM10:
 185 0030 42E0      		 ldi r20,lo8(2)
 186 0032 4A95      	    1:dec r20
 187 0034 01F4      	    brne 1b
 188 0036 00C0      		rjmp .
 189               	.LBE37:
 190               	.LBE36:
 192               	.Ltext4:
  34:lcd_595_softspi.c ****         _delay_us(1);
  35:lcd_595_softspi.c ****         PORT_SPI |= (1<<DD_SCK);                // Set SCK "H"
 194               	.LM11:
 195 0038 299A      		sbi 37-32,1
 196               	.LBB38:
 197               	.LBB39:
 199               	.Ltext5:
 201               	.LM12:
 202 003a 42E0      		 ldi r20,lo8(2)
 203 003c 4A95      	    1:dec r20
 204 003e 01F4      	    brne 1b
 205 0040 00C0      		rjmp .
 206 0042 2150      		subi r18,lo8(-(-1))
 207 0044 3040      		sbci r19,hi8(-(-1))
 208               	.LBE39:
 209               	.LBE38:
 211               	.Ltext6:
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
 213               	.LM13:
 214 0046 4FEF      		ldi r20,hi8(-1)
 215 0048 2F3F      		cpi r18,lo8(-1)
 216 004a 3407      		cpc r19,r20
 217 004c 01F4      		brne .L3
 218               	/* epilogue start */
  36:lcd_595_softspi.c ****         _delay_us(1);
  37:lcd_595_softspi.c ****     }
  38:lcd_595_softspi.c **** }
 220               	.LM14:
 221 004e 0895      		ret
 223               	.Lscope2:
 228               	.global	send_bits_595
 230               	send_bits_595:
  39:lcd_595_softspi.c **** 
  40:lcd_595_softspi.c **** void send_bits_595(unsigned char RS, unsigned char E, unsigned char DATA){
 232               	.LM15:
 233               	.LFBB3:
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
  41:lcd_595_softspi.c ****     unsigned char bits;
  42:lcd_595_softspi.c ****     bits = 0x3f & ( (RS<<5)|(E<<4)|DATA );
 239               	.LM16:
 240 0050 8295      		swap r24
 241 0052 880F      		lsl r24
 242 0054 807E      		andi r24,lo8(-32)
 243 0056 842B      		or r24,r20
 244 0058 6295      		swap r22
 245 005a 607F      		andi r22,lo8(-16)
 246 005c 682B      		or r22,r24
  43:lcd_595_softspi.c ****     SoftSPI_TX(bits);
 248               	.LM17:
 249 005e 862F      		mov r24,r22
 250 0060 8F73      		andi r24,lo8(63)
 251 0062 00D0      		rcall SoftSPI_TX
 252               	.LBB40:
 253               	.LBB41:
 255               	.Ltext7:
 257               	.LM18:
 258 0064 8AE1      		 ldi r24,lo8(26)
 259 0066 8A95      	    1:dec r24
 260 0068 01F4      	    brne 1b
 261 006a 00C0      		rjmp .
 262               	.LBE41:
 263               	.LBE40:
 265               	.Ltext8:
  44:lcd_595_softspi.c ****     _delay_us(10);
  45:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 267               	.LM19:
 268 006c 2A98      		cbi 37-32,2
  46:lcd_595_softspi.c ****     PORT_SPI |=  (1<<DD_RCK);   // Set RCK "H"
 270               	.LM20:
 271 006e 2A9A      		sbi 37-32,2
  47:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 273               	.LM21:
 274 0070 2A98      		cbi 37-32,2
 275               	/* epilogue start */
  48:lcd_595_softspi.c **** }
 277               	.LM22:
 278 0072 0895      		ret
 280               	.Lscope3:
 283               	.global	lcd_set_4bit
 285               	lcd_set_4bit:
  49:lcd_595_softspi.c **** 
  50:lcd_595_softspi.c **** // fuction for sending control bitpattern
  51:lcd_595_softspi.c **** void lcd_set_4bit(unsigned char bitpattern){
 287               	.LM23:
 288               	.LFBB4:
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
  52:lcd_595_softspi.c **** 	DATA    =   0x0f & bitpattern; // set sending data
 294               	.LM24:
 295 0074 482F      		mov r20,r24
 296 0076 4F70      		andi r20,lo8(15)
 297 0078 4093 0000 		sts DATA,r20
  53:lcd_595_softspi.c **** 	E       =   0;
 299               	.LM25:
 300 007c 1092 0000 		sts E,__zero_reg__
  54:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 302               	.LM26:
 303 0080 8091 0000 		lds r24,RS
 304 0084 60E0      		ldi r22,lo8(0)
 305 0086 00D0      		rcall send_bits_595
  55:lcd_595_softspi.c **** //	_delay_us(20);
  56:lcd_595_softspi.c **** 	E       =   1;
 307               	.LM27:
 308 0088 81E0      		ldi r24,lo8(1)
 309 008a 8093 0000 		sts E,r24
  57:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 311               	.LM28:
 312 008e 8091 0000 		lds r24,RS
 313 0092 61E0      		ldi r22,lo8(1)
 314 0094 4091 0000 		lds r20,DATA
 315 0098 00D0      		rcall send_bits_595
  58:lcd_595_softspi.c **** //	_delay_us(20);
  59:lcd_595_softspi.c **** 	E       =   0;
 317               	.LM29:
 318 009a 1092 0000 		sts E,__zero_reg__
  60:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 320               	.LM30:
 321 009e 8091 0000 		lds r24,RS
 322 00a2 60E0      		ldi r22,lo8(0)
 323 00a4 4091 0000 		lds r20,DATA
 324 00a8 00D0      		rcall send_bits_595
 325               	/* epilogue start */
  61:lcd_595_softspi.c **** //	_delay_us(20);
  62:lcd_595_softspi.c **** }
 327               	.LM31:
 328 00aa 0895      		ret
 330               	.Lscope4:
 332               	.global	lcd_init
 334               	lcd_init:
  63:lcd_595_softspi.c **** 
  64:lcd_595_softspi.c **** // Initializing LCD
  65:lcd_595_softspi.c **** void lcd_init(void){
 336               	.LM32:
 337               	.LFBB5:
 338               	/* prologue: function */
 339               	/* frame size = 0 */
 340               	/* stack size = 0 */
 341               	.L__stack_usage = 0
  66:lcd_595_softspi.c **** 
  67:lcd_595_softspi.c **** 	// set enable "0"
  68:lcd_595_softspi.c ****     E       = 0;
 343               	.LM33:
 344 00ac 1092 0000 		sts E,__zero_reg__
  69:lcd_595_softspi.c ****     // set instruction input mode
  70:lcd_595_softspi.c **** 	RS      = 0;
 346               	.LM34:
 347 00b0 1092 0000 		sts RS,__zero_reg__
  71:lcd_595_softspi.c **** 	// initialize data port
  72:lcd_595_softspi.c **** 	DATA	= 0x00;
 349               	.LM35:
 350 00b4 1092 0000 		sts DATA,__zero_reg__
  73:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 352               	.LM36:
 353 00b8 80E0      		ldi r24,lo8(0)
 354 00ba 60E0      		ldi r22,lo8(0)
 355 00bc 40E0      		ldi r20,lo8(0)
 356 00be 00D0      		rcall send_bits_595
 357               	.LBB42:
 358               	.LBB43:
 360               	.Ltext9:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 362               	.LM37:
 363 00c0 8FE3      		 ldi r24,lo8(-25537)
 364 00c2 9CE9      	    ldi r25,hi8(-25537)
 365 00c4 0197      	    1:sbiw r24,1
 366 00c6 01F4      	    brne 1b
 367 00c8 00C0      		rjmp .
 368 00ca 0000      		nop
 369               	.LBE43:
 370               	.LBE42:
 372               	.Ltext10:
  74:lcd_595_softspi.c ****     
  75:lcd_595_softspi.c **** 	// wait more than 15ms
  76:lcd_595_softspi.c **** 	_delay_ms(20);
  77:lcd_595_softspi.c **** 
  78:lcd_595_softspi.c **** 	// set 8-bit mode
  79:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 374               	.LM38:
 375 00cc 83E0      		ldi r24,lo8(3)
 376 00ce 00D0      		rcall lcd_set_4bit
 377               	.LBB44:
 378               	.LBB45:
 380               	.Ltext11:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 382               	.LM39:
 383 00d0 8FE0      		 ldi r24,lo8(9999)
 384 00d2 97E2      	    ldi r25,hi8(9999)
 385 00d4 0197      	    1:sbiw r24,1
 386 00d6 01F4      	    brne 1b
 387 00d8 00C0      		rjmp .
 388 00da 0000      		nop
 389               	.LBE45:
 390               	.LBE44:
 392               	.Ltext12:
  80:lcd_595_softspi.c **** 	_delay_ms(5);
  81:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 394               	.LM40:
 395 00dc 83E0      		ldi r24,lo8(3)
 396 00de 00D0      		rcall lcd_set_4bit
 397               	.LBB46:
 398               	.LBB47:
 400               	.Ltext13:
 402               	.LM41:
 403 00e0 8BED      		 ldi r24,lo8(219)
 404 00e2 90E0      	    ldi r25,hi8(219)
 405 00e4 0197      	    1:sbiw r24,1
 406 00e6 01F4      	    brne 1b
 407 00e8 00C0      		rjmp .
 408 00ea 0000      		nop
 409               	.LBE47:
 410               	.LBE46:
 412               	.Ltext14:
  82:lcd_595_softspi.c **** 	_delay_us(110);
  83:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 414               	.LM42:
 415 00ec 83E0      		ldi r24,lo8(3)
 416 00ee 00D0      		rcall lcd_set_4bit
 417               	.LBB48:
 418               	.LBB49:
 420               	.Ltext15:
 422               	.LM43:
 423 00f0 95E8      		 ldi r25,lo8(-123)
 424 00f2 9A95      	    1:dec r25
 425 00f4 01F4      	    brne 1b
 426 00f6 0000      		nop
 427               	.LBE49:
 428               	.LBE48:
 430               	.Ltext16:
  84:lcd_595_softspi.c **** 	_delay_us(50);
  85:lcd_595_softspi.c **** 	
  86:lcd_595_softspi.c **** 	// set 4-bit mode
  87:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 432               	.LM44:
 433 00f8 82E0      		ldi r24,lo8(2)
 434 00fa 00D0      		rcall lcd_set_4bit
 435               	.LBB50:
 436               	.LBB51:
 438               	.Ltext17:
 440               	.LM45:
 441 00fc 85E8      		 ldi r24,lo8(-123)
 442 00fe 8A95      	    1:dec r24
 443 0100 01F4      	    brne 1b
 444 0102 0000      		nop
 445               	.LBE51:
 446               	.LBE50:
 448               	.Ltext18:
  88:lcd_595_softspi.c **** 	_delay_us(50);
  89:lcd_595_softspi.c **** 
  90:lcd_595_softspi.c **** 	// function setting
  91:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 450               	.LM46:
 451 0104 82E0      		ldi r24,lo8(2)
 452 0106 00D0      		rcall lcd_set_4bit
  92:lcd_595_softspi.c **** 	lcd_set_4bit(0x08);
 454               	.LM47:
 455 0108 88E0      		ldi r24,lo8(8)
 456 010a 00D0      		rcall lcd_set_4bit
 457               	.LBB52:
 458               	.LBB53:
 460               	.Ltext19:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 462               	.LM48:
 463 010c 8FEC      		 ldi r24,lo8(1999)
 464 010e 97E0      	    ldi r25,hi8(1999)
 465 0110 0197      	    1:sbiw r24,1
 466 0112 01F4      	    brne 1b
 467 0114 00C0      		rjmp .
 468 0116 0000      		nop
 469               	.LBE53:
 470               	.LBE52:
 472               	.Ltext20:
  93:lcd_595_softspi.c **** 	_delay_ms(1);
  94:lcd_595_softspi.c **** 
  95:lcd_595_softspi.c **** 	// set display on, cursol off and blink off
  96:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 474               	.LM49:
 475 0118 80E0      		ldi r24,lo8(0)
 476 011a 00D0      		rcall lcd_set_4bit
  97:lcd_595_softspi.c **** 	lcd_set_4bit(0x0c);
 478               	.LM50:
 479 011c 8CE0      		ldi r24,lo8(12)
 480 011e 00D0      		rcall lcd_set_4bit
 481               	.LBB54:
 482               	.LBB55:
 484               	.Ltext21:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 486               	.LM51:
 487 0120 8FEC      		 ldi r24,lo8(1999)
 488 0122 97E0      	    ldi r25,hi8(1999)
 489 0124 0197      	    1:sbiw r24,1
 490 0126 01F4      	    brne 1b
 491 0128 00C0      		rjmp .
 492 012a 0000      		nop
 493               	.LBE55:
 494               	.LBE54:
 496               	.Ltext22:
  98:lcd_595_softspi.c **** 	_delay_ms(1);
  99:lcd_595_softspi.c **** 
 100:lcd_595_softspi.c **** 	// set entry mode (cursol direction : right, disable shift)
 101:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 498               	.LM52:
 499 012c 80E0      		ldi r24,lo8(0)
 500 012e 00D0      		rcall lcd_set_4bit
 102:lcd_595_softspi.c **** 	lcd_set_4bit(0x06);
 502               	.LM53:
 503 0130 86E0      		ldi r24,lo8(6)
 504 0132 00D0      		rcall lcd_set_4bit
 505               	.LBB56:
 506               	.LBB57:
 508               	.Ltext23:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 510               	.LM54:
 511 0134 8FEC      		 ldi r24,lo8(1999)
 512 0136 97E0      	    ldi r25,hi8(1999)
 513 0138 0197      	    1:sbiw r24,1
 514 013a 01F4      	    brne 1b
 515 013c 00C0      		rjmp .
 516 013e 0000      		nop
 517               	.LBE57:
 518               	.LBE56:
 520               	.Ltext24:
 103:lcd_595_softspi.c **** 	_delay_ms(1);
 104:lcd_595_softspi.c **** 
 105:lcd_595_softspi.c **** 	// clear display
 106:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 522               	.LM55:
 523 0140 80E0      		ldi r24,lo8(0)
 524 0142 00D0      		rcall lcd_set_4bit
 107:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 526               	.LM56:
 527 0144 81E0      		ldi r24,lo8(1)
 528 0146 00D0      		rcall lcd_set_4bit
 529               	.LBB58:
 530               	.LBB59:
 532               	.Ltext25:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 534               	.LM57:
 535 0148 8FE9      		 ldi r24,lo8(3999)
 536 014a 9FE0      	    ldi r25,hi8(3999)
 537 014c 0197      	    1:sbiw r24,1
 538 014e 01F4      	    brne 1b
 539 0150 00C0      		rjmp .
 540 0152 0000      		nop
 541               	.LBE59:
 542               	.LBE58:
 544               	.Ltext26:
 108:lcd_595_softspi.c **** 	_delay_ms(2);
 109:lcd_595_softspi.c **** 
 110:lcd_595_softspi.c **** 	// clear cursol position
 111:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 546               	.LM58:
 547 0154 80E0      		ldi r24,lo8(0)
 548 0156 00D0      		rcall lcd_set_4bit
 112:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 550               	.LM59:
 551 0158 82E0      		ldi r24,lo8(2)
 552 015a 00D0      		rcall lcd_set_4bit
 553               	.LBB60:
 554               	.LBB61:
 556               	.Ltext27:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 558               	.LM60:
 559 015c 8FE9      		 ldi r24,lo8(3999)
 560 015e 9FE0      	    ldi r25,hi8(3999)
 561 0160 0197      	    1:sbiw r24,1
 562 0162 01F4      	    brne 1b
 563 0164 00C0      		rjmp .
 564 0166 0000      		nop
 565               	.LBE61:
 566               	.LBE60:
 568               	.Ltext28:
 113:lcd_595_softspi.c **** 	_delay_ms(2);
 114:lcd_595_softspi.c **** 
 115:lcd_595_softspi.c **** 	// set data input mode
 116:lcd_595_softspi.c ****     RS      =   1;
 570               	.LM61:
 571 0168 81E0      		ldi r24,lo8(1)
 572 016a 8093 0000 		sts RS,r24
 573               	/* epilogue start */
 117:lcd_595_softspi.c **** }
 575               	.LM62:
 576 016e 0895      		ret
 578               	.Lscope5:
 581               	.global	lcd_set_char
 583               	lcd_set_char:
 118:lcd_595_softspi.c **** 
 119:lcd_595_softspi.c **** // LCD character allocation
 120:lcd_595_softspi.c **** void lcd_locate(unsigned char row, unsigned char col)
 121:lcd_595_softspi.c **** {
 122:lcd_595_softspi.c **** 	// set instruction input mode
 123:lcd_595_softspi.c ****     RS      =   0;
 124:lcd_595_softspi.c **** //	lcd_set_char(0x80 | col | (0x40 * row) );
 125:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 126:lcd_595_softspi.c **** 	// set data input mode
 127:lcd_595_softspi.c ****     RS      =   1;
 128:lcd_595_softspi.c **** }
 129:lcd_595_softspi.c **** 
 130:lcd_595_softspi.c **** // LCD character (1 byte) sending
 131:lcd_595_softspi.c **** void lcd_set_char(unsigned char c)
 132:lcd_595_softspi.c **** {
 585               	.LM63:
 586               	.LFBB6:
 587 0170 CF93      		push r28
 588               	/* prologue: function */
 589               	/* frame size = 0 */
 590               	/* stack size = 1 */
 591               	.L__stack_usage = 1
 592 0172 C82F      		mov r28,r24
 133:lcd_595_softspi.c **** 	lcd_set_4bit(c >> 4); // Upper Bit
 594               	.LM64:
 595 0174 8295      		swap r24
 596 0176 8F70      		andi r24,lo8(15)
 597 0178 00D0      		rcall lcd_set_4bit
 134:lcd_595_softspi.c **** 	lcd_set_4bit(0x0f & c); // Lower Bit
 599               	.LM65:
 600 017a 8C2F      		mov r24,r28
 601 017c 8F70      		andi r24,lo8(15)
 602 017e 00D0      		rcall lcd_set_4bit
 603               	.LBB62:
 604               	.LBB63:
 606               	.Ltext29:
 608               	.LM66:
 609 0180 85E8      		 ldi r24,lo8(-123)
 610 0182 8A95      	    1:dec r24
 611 0184 01F4      	    brne 1b
 612 0186 0000      		nop
 613               	/* epilogue start */
 614               	.LBE63:
 615               	.LBE62:
 617               	.Ltext30:
 135:lcd_595_softspi.c **** 	_delay_us(50);
 136:lcd_595_softspi.c **** }
 619               	.LM67:
 620 0188 CF91      		pop r28
 621 018a 0895      		ret
 623               	.Lscope6:
 627               	.global	lcd_locate
 629               	lcd_locate:
 121:lcd_595_softspi.c **** {
 631               	.LM68:
 632               	.LFBB7:
 633               	/* prologue: function */
 634               	/* frame size = 0 */
 635               	/* stack size = 0 */
 636               	.L__stack_usage = 0
 123:lcd_595_softspi.c ****     RS      =   0;
 638               	.LM69:
 639 018c 1092 0000 		sts RS,__zero_reg__
 125:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 641               	.LM70:
 642 0190 982F      		mov r25,r24
 643 0192 9170      		andi r25,lo8(1)
 644 0194 9295      		swap r25
 645 0196 990F      		lsl r25
 646 0198 990F      		lsl r25
 647 019a 907C      		andi r25,lo8(-64)
 648 019c 9068      		ori r25,lo8(-128)
 649 019e 8695      		lsr r24
 650 01a0 24E1      		ldi r18,lo8(20)
 651 01a2 829F      		mul r24,r18
 652 01a4 802D      		mov r24,r0
 653 01a6 1124      		clr r1
 654 01a8 860F      		add r24,r22
 655 01aa 892B      		or r24,r25
 656 01ac 00D0      		rcall lcd_set_char
 127:lcd_595_softspi.c ****     RS      =   1;
 658               	.LM71:
 659 01ae 81E0      		ldi r24,lo8(1)
 660 01b0 8093 0000 		sts RS,r24
 661               	/* epilogue start */
 128:lcd_595_softspi.c **** }
 663               	.LM72:
 664 01b4 0895      		ret
 666               	.Lscope7:
 668               	.global	lcd_set_str
 670               	lcd_set_str:
 137:lcd_595_softspi.c **** 
 138:lcd_595_softspi.c **** // LCD String Sending
 139:lcd_595_softspi.c **** void lcd_set_str(unsigned char *s)
 140:lcd_595_softspi.c **** {
 672               	.LM73:
 673               	.LFBB8:
 674 01b6 CF93      		push r28
 675 01b8 DF93      		push r29
 676               	/* prologue: function */
 677               	/* frame size = 0 */
 678               	/* stack size = 2 */
 679               	.L__stack_usage = 2
 681               	.LM74:
 682 01ba EC01      		movw r28,r24
 141:lcd_595_softspi.c **** 	while (*s != 0) {
 684               	.LM75:
 685 01bc 00C0      		rjmp .L11
 686               	.L12:
 142:lcd_595_softspi.c **** 		lcd_set_char(*s);
 688               	.LM76:
 689 01be 00D0      		rcall lcd_set_char
 690               	.L11:
 141:lcd_595_softspi.c **** 	while (*s != 0) {
 692               	.LM77:
 693 01c0 8991      		ld r24,Y+
 694 01c2 8823      		tst r24
 695 01c4 01F4      		brne .L12
 696               	/* epilogue start */
 143:lcd_595_softspi.c **** 		s++;
 144:lcd_595_softspi.c **** 	} 
 145:lcd_595_softspi.c **** }
 698               	.LM78:
 699 01c6 DF91      		pop r29
 700 01c8 CF91      		pop r28
 701 01ca 0895      		ret
 703               	.Lscope8:
 708               	.global	lcd_set_numeric
 710               	lcd_set_numeric:
 146:lcd_595_softspi.c **** 
 147:lcd_595_softspi.c **** // Display numeric on LCD display
 148:lcd_595_softspi.c **** void lcd_set_numeric(unsigned int num, unsigned int Nint, unsigned int Nfrac){
 712               	.LM79:
 713               	.LFBB9:
 714 01cc 4F92      		push r4
 715 01ce 5F92      		push r5
 716 01d0 6F92      		push r6
 717 01d2 7F92      		push r7
 718 01d4 8F92      		push r8
 719 01d6 9F92      		push r9
 720 01d8 AF92      		push r10
 721 01da BF92      		push r11
 722 01dc CF92      		push r12
 723 01de DF92      		push r13
 724 01e0 EF92      		push r14
 725 01e2 FF92      		push r15
 726 01e4 0F93      		push r16
 727 01e6 1F93      		push r17
 728 01e8 CF93      		push r28
 729 01ea DF93      		push r29
 730               	/* prologue: function */
 731               	/* frame size = 0 */
 732               	/* stack size = 16 */
 733               	.L__stack_usage = 16
 734 01ec EC01      		movw r28,r24
 149:lcd_595_softspi.c ****     unsigned long int DivFactor = 1;
 150:lcd_595_softspi.c **** 	unsigned int n, m;
 151:lcd_595_softspi.c **** 	unsigned int d[10];
 152:lcd_595_softspi.c ****     unsigned int valid = 0;
 153:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 736               	.LM80:
 737 01ee 20E0      		ldi r18,lo8(0)
 738 01f0 30E0      		ldi r19,hi8(0)
 739 01f2 00C0      		rjmp .L14
 740               	.L15:
 154:lcd_595_softspi.c ****         num = num * 10;
 742               	.LM81:
 743 01f4 CE01      		movw r24,r28
 744 01f6 880F      		lsl r24
 745 01f8 991F      		rol r25
 746 01fa F3E0      		ldi r31,3
 747 01fc CC0F      	1:	lsl r28
 748 01fe DD1F      		rol r29
 749 0200 FA95      		dec r31
 750 0202 01F4      		brne 1b
 751 0204 C80F      		add r28,r24
 752 0206 D91F      		adc r29,r25
 153:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 754               	.LM82:
 755 0208 2F5F      		subi r18,lo8(-(1))
 756 020a 3F4F      		sbci r19,hi8(-(1))
 757               	.L14:
 153:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 759               	.LM83:
 760 020c 2417      		cp r18,r20
 761 020e 3507      		cpc r19,r21
 762 0210 01F4      		brne .L15
 763 0212 AA24      		clr r10
 764 0214 BB24      		clr r11
 765 0216 8824      		clr r8
 766 0218 9924      		clr r9
 155:lcd_595_softspi.c ****     }
 156:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 768               	.LM84:
 769 021a 3901      		movw r6,r18
 770 021c 660E      		add r6,r22
 771 021e 771E      		adc r7,r23
 772 0220 2301      		movw r4,r6
 773 0222 0894      		sec
 774 0224 4108      		sbc r4,__zero_reg__
 775 0226 5108      		sbc r5,__zero_reg__
 776 0228 00C0      		rjmp .L16
 777               	.L17:
 157:lcd_595_softspi.c ****         
 158:lcd_595_softspi.c ****         DivFactor = 1;
 159:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 160:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 779               	.LM85:
 780 022a C701      		movw r24,r14
 781 022c B601      		movw r22,r12
 782 022e 2AE0      		ldi r18,lo8(10)
 783 0230 30E0      		ldi r19,hi8(10)
 784 0232 40E0      		ldi r20,hlo8(10)
 785 0234 50E0      		ldi r21,hhi8(10)
 786 0236 00D0      		rcall __mulsi3
 787 0238 6B01      		movw r12,r22
 788 023a 7C01      		movw r14,r24
 789 023c 00C0      		rjmp .L25
 790               	.L26:
 156:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 792               	.LM86:
 793 023e 8501      		movw r16,r10
 794 0240 91E0      		ldi r25,lo8(1)
 795 0242 C92E      		mov r12,r25
 796 0244 D12C      		mov r13,__zero_reg__
 797 0246 E12C      		mov r14,__zero_reg__
 798 0248 F12C      		mov r15,__zero_reg__
 799               	.L25:
 801               	.LM87:
 802 024a 0F5F      		subi r16,lo8(-(1))
 803 024c 1F4F      		sbci r17,hi8(-(1))
 159:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 805               	.LM88:
 806 024e 0615      		cp r16,r6
 807 0250 1705      		cpc r17,r7
 808 0252 00F0      		brlo .L17
 161:lcd_595_softspi.c ****         }
 162:lcd_595_softspi.c ****         
 163:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 810               	.LM89:
 811 0254 BE01      		movw r22,r28
 812 0256 80E0      		ldi r24,lo8(0)
 813 0258 90E0      		ldi r25,hi8(0)
 814 025a A701      		movw r20,r14
 815 025c 9601      		movw r18,r12
 816 025e 00D0      		rcall __udivmodsi4
 164:lcd_595_softspi.c ****         if( (valid == 0) & (d[n]!=0) ) valid = 1;
 818               	.LM90:
 819 0260 2115      		cp r18,__zero_reg__
 820 0262 3105      		cpc r19,__zero_reg__
 821 0264 01F0      		breq .L18
 822 0266 8114      		cp r8,__zero_reg__
 823 0268 9104      		cpc r9,__zero_reg__
 824 026a 01F4      		brne .L18
 825 026c 81E0      		ldi r24,lo8(1)
 826 026e 882E      		mov r8,r24
 827 0270 912C      		mov r9,__zero_reg__
 828               	.L18:
 165:lcd_595_softspi.c ****         num = num - d[n]*DivFactor;
 830               	.LM91:
 831 0272 2C9D      		mul r18,r12
 832 0274 C001      		movw r24,r0
 833 0276 2D9D      		mul r18,r13
 834 0278 900D      		add r25,r0
 835 027a 3C9D      		mul r19,r12
 836 027c 900D      		add r25,r0
 837 027e 1124      		clr r1
 838 0280 C81B      		sub r28,r24
 839 0282 D90B      		sbc r29,r25
 166:lcd_595_softspi.c ****         
 167:lcd_595_softspi.c ****         if( (valid == 1)|(n == (Nint+Nfrac-1)) ) lcd_set_char(0x30 + d[n]);
 841               	.LM92:
 842 0284 8114      		cp r8,__zero_reg__
 843 0286 9104      		cpc r9,__zero_reg__
 844 0288 01F4      		brne .L27
 845 028a A414      		cp r10,r4
 846 028c B504      		cpc r11,r5
 847 028e 01F4      		brne .L30
 848               	.L27:
 850               	.LM93:
 851 0290 822F      		mov r24,r18
 852 0292 805D      		subi r24,lo8(-(48))
 853 0294 00C0      		rjmp .L31
 854               	.L30:
 168:lcd_595_softspi.c ****         else if( valid == 0 )                   lcd_set_char(0x20);
 856               	.LM94:
 857 0296 80E2      		ldi r24,lo8(32)
 858               	.L31:
 859 0298 00D0      		rcall lcd_set_char
 860 029a 0894      		sec
 861 029c A11C      		adc r10,__zero_reg__
 862 029e B11C      		adc r11,__zero_reg__
 863               	.L16:
 156:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 865               	.LM95:
 866 02a0 4A14      		cp r4,r10
 867 02a2 5B04      		cpc r5,r11
 868 02a4 00F4      		brsh .L26
 869               	/* epilogue start */
 169:lcd_595_softspi.c ****         else                                    lcd_set_char(0xff);
 170:lcd_595_softspi.c ****     }
 171:lcd_595_softspi.c **** }
 871               	.LM96:
 872 02a6 DF91      		pop r29
 873 02a8 CF91      		pop r28
 874 02aa 1F91      		pop r17
 875 02ac 0F91      		pop r16
 876 02ae FF90      		pop r15
 877 02b0 EF90      		pop r14
 878 02b2 DF90      		pop r13
 879 02b4 CF90      		pop r12
 880 02b6 BF90      		pop r11
 881 02b8 AF90      		pop r10
 882 02ba 9F90      		pop r9
 883 02bc 8F90      		pop r8
 884 02be 7F90      		pop r7
 885 02c0 6F90      		pop r6
 886 02c2 5F90      		pop r5
 887 02c4 4F90      		pop r4
 888 02c6 0895      		ret
 895               	.Lscope9:
 897               	.global	lcd_clear
 899               	lcd_clear:
 172:lcd_595_softspi.c **** 
 173:lcd_595_softspi.c **** // Clear LCD
 174:lcd_595_softspi.c **** void lcd_clear(){
 901               	.LM97:
 902               	.LFBB10:
 903               	/* prologue: function */
 904               	/* frame size = 0 */
 905               	/* stack size = 0 */
 906               	.L__stack_usage = 0
 175:lcd_595_softspi.c **** 	// clear display
 176:lcd_595_softspi.c ****     RS      =   0;
 908               	.LM98:
 909 02c8 1092 0000 		sts RS,__zero_reg__
 177:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 911               	.LM99:
 912 02cc 80E0      		ldi r24,lo8(0)
 913 02ce 00D0      		rcall lcd_set_4bit
 178:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 915               	.LM100:
 916 02d0 81E0      		ldi r24,lo8(1)
 917 02d2 00D0      		rcall lcd_set_4bit
 918               	.LBB64:
 919               	.LBB65:
 921               	.Ltext31:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 923               	.LM101:
 924 02d4 8FEC      		 ldi r24,lo8(1999)
 925 02d6 97E0      	    ldi r25,hi8(1999)
 926 02d8 0197      	    1:sbiw r24,1
 927 02da 01F4      	    brne 1b
 928 02dc 00C0      		rjmp .
 929 02de 0000      		nop
 930               	.LBE65:
 931               	.LBE64:
 933               	.Ltext32:
 179:lcd_595_softspi.c **** 	_delay_ms(1);
 180:lcd_595_softspi.c ****     RS      =   1;
 935               	.LM102:
 936 02e0 81E0      		ldi r24,lo8(1)
 937 02e2 8093 0000 		sts RS,r24
 181:lcd_595_softspi.c **** 	lcd_locate(0,0);
 939               	.LM103:
 940 02e6 80E0      		ldi r24,lo8(0)
 941 02e8 60E0      		ldi r22,lo8(0)
 942 02ea 00D0      		rcall lcd_locate
 943               	/* epilogue start */
 182:lcd_595_softspi.c **** }
 945               	.LM104:
 946 02ec 0895      		ret
 948               	.Lscope10:
 952               	.global	lcd_set_CGRAMaddr
 954               	lcd_set_CGRAMaddr:
 183:lcd_595_softspi.c **** 
 184:lcd_595_softspi.c **** // Set CGRAM address
 185:lcd_595_softspi.c **** void lcd_set_CGRAMaddr(unsigned char code,unsigned char addr)
 186:lcd_595_softspi.c **** {
 956               	.LM105:
 957               	.LFBB11:
 958               	/* prologue: function */
 959               	/* frame size = 0 */
 960               	/* stack size = 0 */
 961               	.L__stack_usage = 0
 187:lcd_595_softspi.c **** 	// set instruction input mode
 188:lcd_595_softspi.c ****     RS      =   0;
 963               	.LM106:
 964 02ee 1092 0000 		sts RS,__zero_reg__
 189:lcd_595_softspi.c ****     lcd_set_char(0x40 | code<<3 | addr );
 966               	.LM107:
 967 02f2 6064      		ori r22,lo8(64)
 968 02f4 880F      		lsl r24
 969 02f6 880F      		lsl r24
 970 02f8 880F      		lsl r24
 971 02fa 862B      		or r24,r22
 972 02fc 00D0      		rcall lcd_set_char
 190:lcd_595_softspi.c **** 	// set data input mode
 191:lcd_595_softspi.c ****     RS      =   1;
 974               	.LM108:
 975 02fe 81E0      		ldi r24,lo8(1)
 976 0300 8093 0000 		sts RS,r24
 977               	/* epilogue start */
 192:lcd_595_softspi.c **** }
 979               	.LM109:
 980 0304 0895      		ret
 982               	.Lscope11:
 983               		.comm DATA,1,1
 984               		.comm RS,1,1
 985               		.comm E,1,1
 990               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 lcd_595_softspi.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:107    .text:00000000 SoftSPI_Init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:130    .text:00000008 SoftSPI_TX
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:230    .text:00000050 send_bits_595
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:285    .text:00000074 lcd_set_4bit
                            *COM*:00000001 DATA
                            *COM*:00000001 E
                            *COM*:00000001 RS
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:334    .text:000000ac lcd_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:583    .text:00000170 lcd_set_char
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:629    .text:0000018c lcd_locate
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:670    .text:000001b6 lcd_set_str
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:710    .text:000001cc lcd_set_numeric
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:899    .text:000002c8 lcd_clear
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccFfuZbt.s:954    .text:000002ee lcd_set_CGRAMaddr

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsi3
__udivmodsi4
