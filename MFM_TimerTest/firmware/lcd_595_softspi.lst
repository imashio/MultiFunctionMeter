   1               		.file	"lcd_595_softspi.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	SoftSPI_Init
 107               	SoftSPI_Init:
   1:lcd_595_softspi.c **** // LCD Control Functions
   2:lcd_595_softspi.c **** // Target : ATMEGA88 (ATMEGA168)
   3:lcd_595_softspi.c **** // Clock  : 1MHz (Fuse : CKDIV8 = 0, Fullswing crystal)
   4:lcd_595_softspi.c **** //
   5:lcd_595_softspi.c **** 
   6:lcd_595_softspi.c **** #include <avr/io.h>
   7:lcd_595_softspi.c **** #include <util/delay.h>
   8:lcd_595_softspi.c **** #include <avr/interrupt.h>
   9:lcd_595_softspi.c **** #include "lcd_595_softspi.h"
  10:lcd_595_softspi.c **** 
  11:lcd_595_softspi.c **** // SPI port Dfinition
  12:lcd_595_softspi.c **** #define DDR_SPI         DDRB
  13:lcd_595_softspi.c **** #define PORT_SPI        PORTB
  14:lcd_595_softspi.c **** #define DD_MOSI         PB0
  15:lcd_595_softspi.c **** #define DD_SCK          PB1
  16:lcd_595_softspi.c **** #define DD_RCK          PB2
  17:lcd_595_softspi.c **** 
  18:lcd_595_softspi.c **** unsigned char E;
  19:lcd_595_softspi.c **** unsigned char RS;
  20:lcd_595_softspi.c **** unsigned char DATA;
  21:lcd_595_softspi.c **** 
  22:lcd_595_softspi.c **** void SoftSPI_Init(void){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  23:lcd_595_softspi.c ****     /*MOSI,SCK=出力、他は入力に設定 */
  24:lcd_595_softspi.c ****     DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_RCK);
 116               	.LM1:
 117 0000 84B1      		in r24,36-32
 118 0002 8760      		ori r24,lo8(7)
 119 0004 84B9      		out 36-32,r24
 120               	/* epilogue start */
  25:lcd_595_softspi.c **** }
 122               	.LM2:
 123 0006 0895      		ret
 125               	.Lscope1:
 128               	.global	SoftSPI_TX
 130               	SoftSPI_TX:
  26:lcd_595_softspi.c **** 
  27:lcd_595_softspi.c **** void SoftSPI_TX(unsigned char cData){
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 139               	.LM4:
 140 0008 27E0      		ldi r18,lo8(7)
 141 000a 30E0      		ldi r19,hi8(7)
  28:lcd_595_softspi.c ****     unsigned int n;
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
  31:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
  32:lcd_595_softspi.c ****         PORT_SPI |= (0x01&(cData>>(7-n)))<<DD_MOSI; // Set Data bit
 143               	.LM5:
 144 000c 90E0      		ldi r25,lo8(0)
 145               	.L3:
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
 147               	.LM6:
 148 000e 2998      		cbi 37-32,1
  31:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
 150               	.LM7:
 151 0010 2898      		cbi 37-32,0
 153               	.LM8:
 154 0012 65B1      		in r22,37-32
 155 0014 AC01      		movw r20,r24
 156 0016 022E      		mov r0,r18
 157 0018 00C0      		rjmp 2f
 158 001a 5595      	1:	asr r21
 159 001c 4795      		ror r20
 160 001e 0A94      	2:	dec r0
 161 0020 02F4      		brpl 1b
 162 0022 4170      		andi r20,lo8(1)
 163 0024 462B      		or r20,r22
 164 0026 45B9      		out 37-32,r20
  33:lcd_595_softspi.c ****         PORT_SPI |= (1<<DD_SCK);                // Set SCK "H"
 166               	.LM9:
 167 0028 299A      		sbi 37-32,1
 168 002a 2150      		subi r18,lo8(-(-1))
 169 002c 3040      		sbci r19,hi8(-(-1))
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
 171               	.LM10:
 172 002e 4FEF      		ldi r20,hi8(-1)
 173 0030 2F3F      		cpi r18,lo8(-1)
 174 0032 3407      		cpc r19,r20
 175 0034 01F4      		brne .L3
 176               	/* epilogue start */
  34:lcd_595_softspi.c ****     }
  35:lcd_595_softspi.c **** }
 178               	.LM11:
 179 0036 0895      		ret
 181               	.Lscope2:
 186               	.global	send_bits_595
 188               	send_bits_595:
  36:lcd_595_softspi.c **** 
  37:lcd_595_softspi.c **** void send_bits_595(unsigned char RS, unsigned char E, unsigned char DATA){
 190               	.LM12:
 191               	.LFBB3:
 192               	/* prologue: function */
 193               	/* frame size = 0 */
 194               	/* stack size = 0 */
 195               	.L__stack_usage = 0
  38:lcd_595_softspi.c ****     unsigned char bits;
  39:lcd_595_softspi.c ****     bits = 0x3f & ( (RS<<5)|(E<<4)|DATA );
 197               	.LM13:
 198 0038 8295      		swap r24
 199 003a 880F      		lsl r24
 200 003c 807E      		andi r24,lo8(-32)
 201 003e 842B      		or r24,r20
 202 0040 6295      		swap r22
 203 0042 607F      		andi r22,lo8(-16)
 204 0044 682B      		or r22,r24
  40:lcd_595_softspi.c ****     SoftSPI_TX(bits);
 206               	.LM14:
 207 0046 862F      		mov r24,r22
 208 0048 8F73      		andi r24,lo8(63)
 209 004a 00D0      		rcall SoftSPI_TX
  41:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 211               	.LM15:
 212 004c 2A98      		cbi 37-32,2
  42:lcd_595_softspi.c ****     PORT_SPI |=  (1<<DD_RCK);   // Set RCK "H"
 214               	.LM16:
 215 004e 2A9A      		sbi 37-32,2
  43:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 217               	.LM17:
 218 0050 2A98      		cbi 37-32,2
 219               	/* epilogue start */
  44:lcd_595_softspi.c **** }
 221               	.LM18:
 222 0052 0895      		ret
 224               	.Lscope3:
 227               	.global	lcd_set_4bit
 229               	lcd_set_4bit:
  45:lcd_595_softspi.c **** 
  46:lcd_595_softspi.c **** // fuction for sending control bitpattern
  47:lcd_595_softspi.c **** void lcd_set_4bit(unsigned char bitpattern){
 231               	.LM19:
 232               	.LFBB4:
 233               	/* prologue: function */
 234               	/* frame size = 0 */
 235               	/* stack size = 0 */
 236               	.L__stack_usage = 0
  48:lcd_595_softspi.c **** 	DATA    =   0x0f & bitpattern; // set sending data
 238               	.LM20:
 239 0054 482F      		mov r20,r24
 240 0056 4F70      		andi r20,lo8(15)
 241 0058 4093 0000 		sts DATA,r20
  49:lcd_595_softspi.c **** 	E       =   0;
 243               	.LM21:
 244 005c 1092 0000 		sts E,__zero_reg__
  50:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 246               	.LM22:
 247 0060 8091 0000 		lds r24,RS
 248 0064 60E0      		ldi r22,lo8(0)
 249 0066 00D0      		rcall send_bits_595
  51:lcd_595_softspi.c **** 	E       =   1;
 251               	.LM23:
 252 0068 81E0      		ldi r24,lo8(1)
 253 006a 8093 0000 		sts E,r24
  52:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 255               	.LM24:
 256 006e 8091 0000 		lds r24,RS
 257 0072 61E0      		ldi r22,lo8(1)
 258 0074 4091 0000 		lds r20,DATA
 259 0078 00D0      		rcall send_bits_595
  53:lcd_595_softspi.c **** 	E       =   0;
 261               	.LM25:
 262 007a 1092 0000 		sts E,__zero_reg__
  54:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 264               	.LM26:
 265 007e 8091 0000 		lds r24,RS
 266 0082 60E0      		ldi r22,lo8(0)
 267 0084 4091 0000 		lds r20,DATA
 268 0088 00D0      		rcall send_bits_595
 269               	/* epilogue start */
  55:lcd_595_softspi.c **** }
 271               	.LM27:
 272 008a 0895      		ret
 274               	.Lscope4:
 276               	.global	lcd_init
 278               	lcd_init:
  56:lcd_595_softspi.c **** 
  57:lcd_595_softspi.c **** // Initializing LCD
  58:lcd_595_softspi.c **** void lcd_init(void){
 280               	.LM28:
 281               	.LFBB5:
 282               	/* prologue: function */
 283               	/* frame size = 0 */
 284               	/* stack size = 0 */
 285               	.L__stack_usage = 0
  59:lcd_595_softspi.c **** 
  60:lcd_595_softspi.c **** 	// set enable "0"
  61:lcd_595_softspi.c ****     E       = 0;
 287               	.LM29:
 288 008c 1092 0000 		sts E,__zero_reg__
  62:lcd_595_softspi.c ****     // set instruction input mode
  63:lcd_595_softspi.c **** 	RS      = 0;
 290               	.LM30:
 291 0090 1092 0000 		sts RS,__zero_reg__
  64:lcd_595_softspi.c **** 	// initialize data port
  65:lcd_595_softspi.c **** 	DATA	= 0x00;
 293               	.LM31:
 294 0094 1092 0000 		sts DATA,__zero_reg__
  66:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 296               	.LM32:
 297 0098 80E0      		ldi r24,lo8(0)
 298 009a 60E0      		ldi r22,lo8(0)
 299 009c 40E0      		ldi r20,lo8(0)
 300 009e 00D0      		rcall send_bits_595
 301               	.LBB26:
 302               	.LBB27:
 304               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 306               	.LM33:
 307 00a0 8FEF      		 ldi r24,lo8(63999)
 308 00a2 99EF      	    ldi r25,hi8(63999)
 309 00a4 A0E0      	    ldi r26,hlo8(63999)
 310 00a6 8150      	    1:subi r24,1
 311 00a8 9040      	    sbci r25,0
 312 00aa A040      	    sbci r26,0
 313 00ac 01F4      	    brne 1b
 314 00ae 00C0      		rjmp .
 315 00b0 0000      		nop
 316               	.LBE27:
 317               	.LBE26:
 319               	.Ltext2:
  67:lcd_595_softspi.c ****     
  68:lcd_595_softspi.c **** 	// wait more than 15ms
  69:lcd_595_softspi.c **** 	_delay_ms(20);
  70:lcd_595_softspi.c **** 
  71:lcd_595_softspi.c **** 	// set 8-bit mode
  72:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 321               	.LM34:
 322 00b2 83E0      		ldi r24,lo8(3)
 323 00b4 00D0      		rcall lcd_set_4bit
 324               	.LBB28:
 325               	.LBB29:
 327               	.Ltext3:
 329               	.LM35:
 330 00b6 AFE1      		 ldi r26,lo8(19999)
 331 00b8 BEE4      	    ldi r27,hi8(19999)
 332 00ba 1197      	    1:sbiw r26,1
 333 00bc 01F4      	    brne 1b
 334 00be 00C0      		rjmp .
 335 00c0 0000      		nop
 336               	.LBE29:
 337               	.LBE28:
 339               	.Ltext4:
  73:lcd_595_softspi.c **** 	_delay_ms(5);
  74:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 341               	.LM36:
 342 00c2 83E0      		ldi r24,lo8(3)
 343 00c4 00D0      		rcall lcd_set_4bit
 344               	.LBB30:
 345               	.LBB31:
 347               	.Ltext5:
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 349               	.LM37:
 350 00c6 87EB      		 ldi r24,lo8(439)
 351 00c8 91E0      	    ldi r25,hi8(439)
 352 00ca 0197      	    1:sbiw r24,1
 353 00cc 01F4      	    brne 1b
 354 00ce 00C0      		rjmp .
 355 00d0 0000      		nop
 356               	.LBE31:
 357               	.LBE30:
 359               	.Ltext6:
  75:lcd_595_softspi.c **** 	_delay_us(110);
  76:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 361               	.LM38:
 362 00d2 83E0      		ldi r24,lo8(3)
 363 00d4 00D0      		rcall lcd_set_4bit
 364               	.LBB32:
 365               	.LBB33:
 367               	.Ltext7:
 369               	.LM39:
 370 00d6 A7EC      		 ldi r26,lo8(199)
 371 00d8 B0E0      	    ldi r27,hi8(199)
 372 00da 1197      	    1:sbiw r26,1
 373 00dc 01F4      	    brne 1b
 374 00de 00C0      		rjmp .
 375 00e0 0000      		nop
 376               	.LBE33:
 377               	.LBE32:
 379               	.Ltext8:
  77:lcd_595_softspi.c **** 	_delay_us(50);
  78:lcd_595_softspi.c **** 	
  79:lcd_595_softspi.c **** 	// set 4-bit mode
  80:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 381               	.LM40:
 382 00e2 82E0      		ldi r24,lo8(2)
 383 00e4 00D0      		rcall lcd_set_4bit
 384               	.LBB34:
 385               	.LBB35:
 387               	.Ltext9:
 389               	.LM41:
 390 00e6 87EC      		 ldi r24,lo8(199)
 391 00e8 90E0      	    ldi r25,hi8(199)
 392 00ea 0197      	    1:sbiw r24,1
 393 00ec 01F4      	    brne 1b
 394 00ee 00C0      		rjmp .
 395 00f0 0000      		nop
 396               	.LBE35:
 397               	.LBE34:
 399               	.Ltext10:
  81:lcd_595_softspi.c **** 	_delay_us(50);
  82:lcd_595_softspi.c **** 
  83:lcd_595_softspi.c **** 	// function setting
  84:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 401               	.LM42:
 402 00f2 82E0      		ldi r24,lo8(2)
 403 00f4 00D0      		rcall lcd_set_4bit
  85:lcd_595_softspi.c **** 	lcd_set_4bit(0x08);
 405               	.LM43:
 406 00f6 88E0      		ldi r24,lo8(8)
 407 00f8 00D0      		rcall lcd_set_4bit
 408               	.LBB36:
 409               	.LBB37:
 411               	.Ltext11:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 413               	.LM44:
 414 00fa AFE9      		 ldi r26,lo8(3999)
 415 00fc BFE0      	    ldi r27,hi8(3999)
 416 00fe 1197      	    1:sbiw r26,1
 417 0100 01F4      	    brne 1b
 418 0102 00C0      		rjmp .
 419 0104 0000      		nop
 420               	.LBE37:
 421               	.LBE36:
 423               	.Ltext12:
  86:lcd_595_softspi.c **** 	_delay_ms(1);
  87:lcd_595_softspi.c **** 
  88:lcd_595_softspi.c **** 	// set display on, cursol off and blink off
  89:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 425               	.LM45:
 426 0106 80E0      		ldi r24,lo8(0)
 427 0108 00D0      		rcall lcd_set_4bit
  90:lcd_595_softspi.c **** 	lcd_set_4bit(0x0c);
 429               	.LM46:
 430 010a 8CE0      		ldi r24,lo8(12)
 431 010c 00D0      		rcall lcd_set_4bit
 432               	.LBB38:
 433               	.LBB39:
 435               	.Ltext13:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 437               	.LM47:
 438 010e 8FE9      		 ldi r24,lo8(3999)
 439 0110 9FE0      	    ldi r25,hi8(3999)
 440 0112 0197      	    1:sbiw r24,1
 441 0114 01F4      	    brne 1b
 442 0116 00C0      		rjmp .
 443 0118 0000      		nop
 444               	.LBE39:
 445               	.LBE38:
 447               	.Ltext14:
  91:lcd_595_softspi.c **** 	_delay_ms(1);
  92:lcd_595_softspi.c **** 
  93:lcd_595_softspi.c **** 	// set entry mode (cursol direction : right, disable shift)
  94:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 449               	.LM48:
 450 011a 80E0      		ldi r24,lo8(0)
 451 011c 00D0      		rcall lcd_set_4bit
  95:lcd_595_softspi.c **** 	lcd_set_4bit(0x06);
 453               	.LM49:
 454 011e 86E0      		ldi r24,lo8(6)
 455 0120 00D0      		rcall lcd_set_4bit
 456               	.LBB40:
 457               	.LBB41:
 459               	.Ltext15:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 461               	.LM50:
 462 0122 AFE9      		 ldi r26,lo8(3999)
 463 0124 BFE0      	    ldi r27,hi8(3999)
 464 0126 1197      	    1:sbiw r26,1
 465 0128 01F4      	    brne 1b
 466 012a 00C0      		rjmp .
 467 012c 0000      		nop
 468               	.LBE41:
 469               	.LBE40:
 471               	.Ltext16:
  96:lcd_595_softspi.c **** 	_delay_ms(1);
  97:lcd_595_softspi.c **** 
  98:lcd_595_softspi.c **** 	// clear display
  99:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 473               	.LM51:
 474 012e 80E0      		ldi r24,lo8(0)
 475 0130 00D0      		rcall lcd_set_4bit
 100:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 477               	.LM52:
 478 0132 81E0      		ldi r24,lo8(1)
 479 0134 00D0      		rcall lcd_set_4bit
 480               	.LBB42:
 481               	.LBB43:
 483               	.Ltext17:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 485               	.LM53:
 486 0136 8FE3      		 ldi r24,lo8(7999)
 487 0138 9FE1      	    ldi r25,hi8(7999)
 488 013a 0197      	    1:sbiw r24,1
 489 013c 01F4      	    brne 1b
 490 013e 00C0      		rjmp .
 491 0140 0000      		nop
 492               	.LBE43:
 493               	.LBE42:
 495               	.Ltext18:
 101:lcd_595_softspi.c **** 	_delay_ms(2);
 102:lcd_595_softspi.c **** 
 103:lcd_595_softspi.c **** 	// clear cursol position
 104:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 497               	.LM54:
 498 0142 80E0      		ldi r24,lo8(0)
 499 0144 00D0      		rcall lcd_set_4bit
 105:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 501               	.LM55:
 502 0146 82E0      		ldi r24,lo8(2)
 503 0148 00D0      		rcall lcd_set_4bit
 504               	.LBB44:
 505               	.LBB45:
 507               	.Ltext19:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 509               	.LM56:
 510 014a AFE3      		 ldi r26,lo8(7999)
 511 014c BFE1      	    ldi r27,hi8(7999)
 512 014e 1197      	    1:sbiw r26,1
 513 0150 01F4      	    brne 1b
 514 0152 00C0      		rjmp .
 515 0154 0000      		nop
 516               	.LBE45:
 517               	.LBE44:
 519               	.Ltext20:
 106:lcd_595_softspi.c **** 	_delay_ms(2);
 107:lcd_595_softspi.c **** 
 108:lcd_595_softspi.c **** 	// set data input mode
 109:lcd_595_softspi.c ****     RS      =   1;
 521               	.LM57:
 522 0156 81E0      		ldi r24,lo8(1)
 523 0158 8093 0000 		sts RS,r24
 524               	/* epilogue start */
 110:lcd_595_softspi.c **** }
 526               	.LM58:
 527 015c 0895      		ret
 529               	.Lscope5:
 532               	.global	lcd_set_char
 534               	lcd_set_char:
 111:lcd_595_softspi.c **** 
 112:lcd_595_softspi.c **** // LCD character allocation
 113:lcd_595_softspi.c **** void lcd_locate(unsigned char row, unsigned char col)
 114:lcd_595_softspi.c **** {
 115:lcd_595_softspi.c **** 	// set instruction input mode
 116:lcd_595_softspi.c ****     RS      =   0;
 117:lcd_595_softspi.c **** //	lcd_set_char(0x80 | col | (0x40 * row) );
 118:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 119:lcd_595_softspi.c **** 	// set data input mode
 120:lcd_595_softspi.c ****     RS      =   1;
 121:lcd_595_softspi.c **** }
 122:lcd_595_softspi.c **** 
 123:lcd_595_softspi.c **** // LCD character (1 byte) sending
 124:lcd_595_softspi.c **** void lcd_set_char(unsigned char c)
 125:lcd_595_softspi.c **** {
 536               	.LM59:
 537               	.LFBB6:
 538 015e CF93      		push r28
 539               	/* prologue: function */
 540               	/* frame size = 0 */
 541               	/* stack size = 1 */
 542               	.L__stack_usage = 1
 543 0160 C82F      		mov r28,r24
 126:lcd_595_softspi.c **** 	lcd_set_4bit(c >> 4); // Upper Bit
 545               	.LM60:
 546 0162 8295      		swap r24
 547 0164 8F70      		andi r24,lo8(15)
 548 0166 00D0      		rcall lcd_set_4bit
 127:lcd_595_softspi.c **** 	lcd_set_4bit(0x0f & c); // Lower Bit
 550               	.LM61:
 551 0168 8C2F      		mov r24,r28
 552 016a 8F70      		andi r24,lo8(15)
 553 016c 00D0      		rcall lcd_set_4bit
 554               	.LBB46:
 555               	.LBB47:
 557               	.Ltext21:
 559               	.LM62:
 560 016e 87EC      		 ldi r24,lo8(199)
 561 0170 90E0      	    ldi r25,hi8(199)
 562 0172 0197      	    1:sbiw r24,1
 563 0174 01F4      	    brne 1b
 564 0176 00C0      		rjmp .
 565 0178 0000      		nop
 566               	/* epilogue start */
 567               	.LBE47:
 568               	.LBE46:
 570               	.Ltext22:
 128:lcd_595_softspi.c **** 	_delay_us(50);
 129:lcd_595_softspi.c **** }
 572               	.LM63:
 573 017a CF91      		pop r28
 574 017c 0895      		ret
 576               	.Lscope6:
 580               	.global	lcd_locate
 582               	lcd_locate:
 114:lcd_595_softspi.c **** {
 584               	.LM64:
 585               	.LFBB7:
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 116:lcd_595_softspi.c ****     RS      =   0;
 591               	.LM65:
 592 017e 1092 0000 		sts RS,__zero_reg__
 118:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 594               	.LM66:
 595 0182 982F      		mov r25,r24
 596 0184 9170      		andi r25,lo8(1)
 597 0186 9295      		swap r25
 598 0188 990F      		lsl r25
 599 018a 990F      		lsl r25
 600 018c 907C      		andi r25,lo8(-64)
 601 018e 9068      		ori r25,lo8(-128)
 602 0190 8695      		lsr r24
 603 0192 24E1      		ldi r18,lo8(20)
 604 0194 829F      		mul r24,r18
 605 0196 802D      		mov r24,r0
 606 0198 1124      		clr r1
 607 019a 860F      		add r24,r22
 608 019c 892B      		or r24,r25
 609 019e 00D0      		rcall lcd_set_char
 120:lcd_595_softspi.c ****     RS      =   1;
 611               	.LM67:
 612 01a0 81E0      		ldi r24,lo8(1)
 613 01a2 8093 0000 		sts RS,r24
 614               	/* epilogue start */
 121:lcd_595_softspi.c **** }
 616               	.LM68:
 617 01a6 0895      		ret
 619               	.Lscope7:
 621               	.global	lcd_set_str
 623               	lcd_set_str:
 130:lcd_595_softspi.c **** 
 131:lcd_595_softspi.c **** // LCD String Sending
 132:lcd_595_softspi.c **** void lcd_set_str(unsigned char *s)
 133:lcd_595_softspi.c **** {
 625               	.LM69:
 626               	.LFBB8:
 627 01a8 CF93      		push r28
 628 01aa DF93      		push r29
 629               	/* prologue: function */
 630               	/* frame size = 0 */
 631               	/* stack size = 2 */
 632               	.L__stack_usage = 2
 634               	.LM70:
 635 01ac EC01      		movw r28,r24
 134:lcd_595_softspi.c **** 	while (*s != 0) {
 637               	.LM71:
 638 01ae 00C0      		rjmp .L11
 639               	.L12:
 135:lcd_595_softspi.c **** 		lcd_set_char(*s);
 641               	.LM72:
 642 01b0 00D0      		rcall lcd_set_char
 643               	.L11:
 134:lcd_595_softspi.c **** 	while (*s != 0) {
 645               	.LM73:
 646 01b2 8991      		ld r24,Y+
 647 01b4 8823      		tst r24
 648 01b6 01F4      		brne .L12
 649               	/* epilogue start */
 136:lcd_595_softspi.c **** 		s++;
 137:lcd_595_softspi.c **** 	} 
 138:lcd_595_softspi.c **** }
 651               	.LM74:
 652 01b8 DF91      		pop r29
 653 01ba CF91      		pop r28
 654 01bc 0895      		ret
 656               	.Lscope8:
 662               	.global	lcd_set_numeric
 664               	lcd_set_numeric:
 139:lcd_595_softspi.c **** 
 140:lcd_595_softspi.c **** // Display numeric on LCD display
 141:lcd_595_softspi.c **** void lcd_set_numeric(float num, unsigned int Nint, unsigned int Nfrac, unsigned int sign){
 666               	.LM75:
 667               	.LFBB9:
 668 01be 2F92      		push r2
 669 01c0 3F92      		push r3
 670 01c2 4F92      		push r4
 671 01c4 5F92      		push r5
 672 01c6 6F92      		push r6
 673 01c8 7F92      		push r7
 674 01ca 8F92      		push r8
 675 01cc 9F92      		push r9
 676 01ce AF92      		push r10
 677 01d0 BF92      		push r11
 678 01d2 CF92      		push r12
 679 01d4 DF92      		push r13
 680 01d6 EF92      		push r14
 681 01d8 FF92      		push r15
 682 01da 0F93      		push r16
 683 01dc 1F93      		push r17
 684 01de CF93      		push r28
 685 01e0 DF93      		push r29
 686 01e2 CDB7      		in r28,__SP_L__
 687 01e4 DEB7      		in r29,__SP_H__
 688 01e6 2897      		sbiw r28,8
 689 01e8 0FB6      		in __tmp_reg__,__SREG__
 690 01ea F894      		cli
 691 01ec DEBF      		out __SP_H__,r29
 692 01ee 0FBE      		out __SREG__,__tmp_reg__
 693 01f0 CDBF      		out __SP_L__,r28
 694               	/* prologue: function */
 695               	/* frame size = 8 */
 696               	/* stack size = 26 */
 697               	.L__stack_usage = 26
 698 01f2 6B01      		movw r12,r22
 699 01f4 7C01      		movw r14,r24
 700 01f6 1A01      		movw r2,r20
 701 01f8 2901      		movw r4,r18
 142:lcd_595_softspi.c ****     unsigned long int DivFactor = 1;
 143:lcd_595_softspi.c **** 	unsigned int n, m;
 144:lcd_595_softspi.c **** 	unsigned int d[10];
 145:lcd_595_softspi.c ****     unsigned int valid = 0;
 146:lcd_595_softspi.c ****     
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 703               	.LM76:
 704 01fa 80E0      		ldi r24,lo8(0)
 705 01fc 90E0      		ldi r25,hi8(0)
 706 01fe 4C01      		movw r8,r24
 707 0200 00C0      		rjmp .L14
 708               	.L15:
 148:lcd_595_softspi.c ****         num = num * 10;
 710               	.LM77:
 711 0202 C701      		movw r24,r14
 712 0204 B601      		movw r22,r12
 713 0206 20E0      		ldi r18,lo8(0x41200000)
 714 0208 30E0      		ldi r19,hi8(0x41200000)
 715 020a 40E2      		ldi r20,hlo8(0x41200000)
 716 020c 51E4      		ldi r21,hhi8(0x41200000)
 717 020e 00D0      		rcall __mulsf3
 718 0210 C62E      		mov r12,r22
 719 0212 D72E      		mov r13,r23
 720 0214 E82E      		mov r14,r24
 721 0216 F92E      		mov r15,r25
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 723               	.LM78:
 724 0218 0894      		sec
 725 021a 811C      		adc r8,__zero_reg__
 726 021c 911C      		adc r9,__zero_reg__
 727               	.L14:
 147:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 729               	.LM79:
 730 021e 8414      		cp r8,r4
 731 0220 9504      		cpc r9,r5
 732 0222 01F4      		brne .L15
 149:lcd_595_softspi.c ****     }
 150:lcd_595_softspi.c ****     
 151:lcd_595_softspi.c ****     // Detect sign
 152:lcd_595_softspi.c ****     if( sign == 1){
 734               	.LM80:
 735 0224 0130      		cpi r16,1
 736 0226 1105      		cpc r17,__zero_reg__
 737 0228 01F4      		brne .L16
 153:lcd_595_softspi.c ****         if( num < 0 ){
 739               	.LM81:
 740 022a C701      		movw r24,r14
 741 022c B601      		movw r22,r12
 742 022e 20E0      		ldi r18,lo8(0x0)
 743 0230 30E0      		ldi r19,hi8(0x0)
 744 0232 A901      		movw r20,r18
 745 0234 00D0      		rcall __ltsf2
 746 0236 87FF      		sbrs r24,7
 747 0238 00C0      		rjmp .L34
 154:lcd_595_softspi.c ****             lcd_set_char('-');
 749               	.LM82:
 750 023a 8DE2      		ldi r24,lo8(45)
 751 023c 00D0      		rcall lcd_set_char
 155:lcd_595_softspi.c ****             num = -num;
 753               	.LM83:
 754 023e F7FA      		bst r15,7
 755 0240 F094      		com r15
 756 0242 F7F8      		bld r15,7
 757 0244 F094      		com r15
 758               	.L16:
 156:lcd_595_softspi.c ****         }else{
 157:lcd_595_softspi.c ****             lcd_set_char('+');
 158:lcd_595_softspi.c ****         }
 159:lcd_595_softspi.c ****     }
 160:lcd_595_softspi.c ****     // end of
 161:lcd_595_softspi.c **** 				
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 163:lcd_595_softspi.c ****         
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 165:lcd_595_softspi.c ****             lcd_set_char('.');
 166:lcd_595_softspi.c ****         }
 167:lcd_595_softspi.c ****         
 168:lcd_595_softspi.c ****         DivFactor = 1;
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 171:lcd_595_softspi.c ****         }
 172:lcd_595_softspi.c ****         
 173:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 174:lcd_595_softspi.c ****         if( (valid == 0) && ( d[n]!=0 || n==Nint-1) ) valid = 1;
 760               	.LM84:
 761 0246 00E0      		ldi r16,lo8(0)
 762 0248 10E0      		ldi r17,hi8(0)
 763 024a 6624      		clr r6
 764 024c 7724      		clr r7
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 766               	.LM85:
 767 024e 9201      		movw r18,r4
 768 0250 220D      		add r18,r2
 769 0252 331D      		adc r19,r3
 770 0254 3A83      		std Y+2,r19
 771 0256 2983      		std Y+1,r18
 772 0258 2150      		subi r18,lo8(-(-1))
 773 025a 3040      		sbci r19,hi8(-(-1))
 774 025c 3C83      		std Y+4,r19
 775 025e 2B83      		std Y+3,r18
 777               	.LM86:
 778 0260 C101      		movw r24,r2
 779 0262 0197      		sbiw r24,1
 780 0264 9E83      		std Y+6,r25
 781 0266 8D83      		std Y+5,r24
 782 0268 7886      		std Y+8,r7
 783 026a 6F82      		std Y+7,r6
 784 026c 00C0      		rjmp .L19
 785               	.L34:
 157:lcd_595_softspi.c ****             lcd_set_char('+');
 787               	.LM87:
 788 026e 8BE2      		ldi r24,lo8(43)
 789 0270 00D0      		rcall lcd_set_char
 790 0272 00C0      		rjmp .L16
 791               	.L29:
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 793               	.LM88:
 794 0274 0215      		cp r16,r2
 795 0276 1305      		cpc r17,r3
 796 0278 01F4      		brne .L20
 164:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 798               	.LM89:
 799 027a 4114      		cp r4,__zero_reg__
 800 027c 5104      		cpc r5,__zero_reg__
 801 027e 01F0      		breq .L20
 165:lcd_595_softspi.c ****             lcd_set_char('.');
 803               	.LM90:
 804 0280 8EE2      		ldi r24,lo8(46)
 805 0282 00D0      		rcall lcd_set_char
 806               	.L20:
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 808               	.LM91:
 809 0284 3801      		movw r6,r16
 168:lcd_595_softspi.c ****         DivFactor = 1;
 811               	.LM92:
 812 0286 81E0      		ldi r24,lo8(1)
 813 0288 882E      		mov r8,r24
 814 028a 912C      		mov r9,__zero_reg__
 815 028c A12C      		mov r10,__zero_reg__
 816 028e B12C      		mov r11,__zero_reg__
 817 0290 C501      		movw r24,r10
 818 0292 B401      		movw r22,r8
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 820               	.LM93:
 821 0294 00C0      		rjmp .L21
 822               	.L22:
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 824               	.LM94:
 825 0296 2AE0      		ldi r18,lo8(10)
 826 0298 30E0      		ldi r19,hi8(10)
 827 029a 40E0      		ldi r20,hlo8(10)
 828 029c 50E0      		ldi r21,hhi8(10)
 829 029e 00D0      		rcall __mulsi3
 830               	.L21:
 170:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 832               	.LM95:
 833 02a0 0894      		sec
 834 02a2 611C      		adc r6,__zero_reg__
 835 02a4 711C      		adc r7,__zero_reg__
 169:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 837               	.LM96:
 838 02a6 E981      		ldd r30,Y+1
 839 02a8 FA81      		ldd r31,Y+2
 840 02aa 6E16      		cp r6,r30
 841 02ac 7F06      		cpc r7,r31
 842 02ae 00F0      		brlo .L22
 843 02b0 4B01      		movw r8,r22
 844 02b2 5C01      		movw r10,r24
 173:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 846               	.LM97:
 847 02b4 00D0      		rcall __floatunsisf
 848 02b6 9B01      		movw r18,r22
 849 02b8 AC01      		movw r20,r24
 850 02ba C701      		movw r24,r14
 851 02bc B601      		movw r22,r12
 852 02be 00D0      		rcall __divsf3
 853 02c0 00D0      		rcall __fixunssfsi
 854 02c2 DC01      		movw r26,r24
 855 02c4 CB01      		movw r24,r22
 856 02c6 3C01      		movw r6,r24
 858               	.LM98:
 859 02c8 2F81      		ldd r18,Y+7
 860 02ca 3885      		ldd r19,Y+8
 861 02cc 2115      		cp r18,__zero_reg__
 862 02ce 3105      		cpc r19,__zero_reg__
 863 02d0 01F4      		brne .L30
 865               	.LM99:
 866 02d2 81E0      		ldi r24,lo8(1)
 867 02d4 90E0      		ldi r25,hi8(1)
 868 02d6 9887      		std Y+8,r25
 869 02d8 8F83      		std Y+7,r24
 870 02da 6114      		cp r6,__zero_reg__
 871 02dc 7104      		cpc r7,__zero_reg__
 872 02de 01F4      		brne .L23
 874               	.LM100:
 875 02e0 ED81      		ldd r30,Y+5
 876 02e2 FE81      		ldd r31,Y+6
 877 02e4 0E17      		cp r16,r30
 878 02e6 1F07      		cpc r17,r31
 879 02e8 01F0      		breq .L23
 880 02ea 1886      		std Y+8,__zero_reg__
 881 02ec 1F82      		std Y+7,__zero_reg__
 882 02ee 00C0      		rjmp .L23
 883               	.L30:
 885               	.LM101:
 886 02f0 21E0      		ldi r18,lo8(1)
 887 02f2 30E0      		ldi r19,hi8(1)
 888 02f4 3887      		std Y+8,r19
 889 02f6 2F83      		std Y+7,r18
 890               	.L23:
 175:lcd_595_softspi.c ****         num = num - d[n]*DivFactor;
 892               	.LM102:
 893 02f8 B301      		movw r22,r6
 894 02fa 80E0      		ldi r24,lo8(0)
 895 02fc 90E0      		ldi r25,hi8(0)
 896 02fe A501      		movw r20,r10
 897 0300 9401      		movw r18,r8
 898 0302 00D0      		rcall __mulsi3
 899 0304 00D0      		rcall __floatunsisf
 900 0306 9B01      		movw r18,r22
 901 0308 AC01      		movw r20,r24
 902 030a C701      		movw r24,r14
 903 030c B601      		movw r22,r12
 904 030e 00D0      		rcall __subsf3
 905 0310 6B01      		movw r12,r22
 906 0312 E82E      		mov r14,r24
 907 0314 F92E      		mov r15,r25
 176:lcd_595_softspi.c ****         
 177:lcd_595_softspi.c ****         if( (valid == 1)|(n == (Nint+Nfrac-1)) ) lcd_set_char(0x30 + d[n]);
 909               	.LM103:
 910 0316 EF81      		ldd r30,Y+7
 911 0318 F885      		ldd r31,Y+8
 912 031a 3097      		sbiw r30,0
 913 031c 01F4      		brne .L33
 914 031e 2B81      		ldd r18,Y+3
 915 0320 3C81      		ldd r19,Y+4
 916 0322 0217      		cp r16,r18
 917 0324 1307      		cpc r17,r19
 918 0326 01F4      		brne .L35
 919               	.L33:
 921               	.LM104:
 922 0328 862D      		mov r24,r6
 923 032a 805D      		subi r24,lo8(-(48))
 924 032c 00C0      		rjmp .L36
 925               	.L35:
 178:lcd_595_softspi.c ****         else if( valid == 0 )                   lcd_set_char(0x20);
 927               	.LM105:
 928 032e 80E2      		ldi r24,lo8(32)
 929               	.L36:
 930 0330 00D0      		rcall lcd_set_char
 931 0332 0F5F      		subi r16,lo8(-(1))
 932 0334 1F4F      		sbci r17,hi8(-(1))
 933               	.L19:
 162:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 935               	.LM106:
 936 0336 8B81      		ldd r24,Y+3
 937 0338 9C81      		ldd r25,Y+4
 938 033a 8017      		cp r24,r16
 939 033c 9107      		cpc r25,r17
 940 033e 00F0      		brlo .+2
 941 0340 00C0      		rjmp .L29
 942               	/* epilogue start */
 179:lcd_595_softspi.c ****         else                                    lcd_set_char(0xff);
 180:lcd_595_softspi.c ****     }
 181:lcd_595_softspi.c **** }
 944               	.LM107:
 945 0342 2896      		adiw r28,8
 946 0344 0FB6      		in __tmp_reg__,__SREG__
 947 0346 F894      		cli
 948 0348 DEBF      		out __SP_H__,r29
 949 034a 0FBE      		out __SREG__,__tmp_reg__
 950 034c CDBF      		out __SP_L__,r28
 951 034e DF91      		pop r29
 952 0350 CF91      		pop r28
 953 0352 1F91      		pop r17
 954 0354 0F91      		pop r16
 955 0356 FF90      		pop r15
 956 0358 EF90      		pop r14
 957 035a DF90      		pop r13
 958 035c CF90      		pop r12
 959 035e BF90      		pop r11
 960 0360 AF90      		pop r10
 961 0362 9F90      		pop r9
 962 0364 8F90      		pop r8
 963 0366 7F90      		pop r7
 964 0368 6F90      		pop r6
 965 036a 5F90      		pop r5
 966 036c 4F90      		pop r4
 967 036e 3F90      		pop r3
 968 0370 2F90      		pop r2
 969 0372 0895      		ret
 976               	.Lscope9:
 978               	.global	lcd_clear
 980               	lcd_clear:
 182:lcd_595_softspi.c **** 
 183:lcd_595_softspi.c **** // Clear LCD
 184:lcd_595_softspi.c **** void lcd_clear(void){
 982               	.LM108:
 983               	.LFBB10:
 984               	/* prologue: function */
 985               	/* frame size = 0 */
 986               	/* stack size = 0 */
 987               	.L__stack_usage = 0
 185:lcd_595_softspi.c **** 	// clear display
 186:lcd_595_softspi.c ****     RS      =   0;
 989               	.LM109:
 990 0374 1092 0000 		sts RS,__zero_reg__
 187:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 992               	.LM110:
 993 0378 80E0      		ldi r24,lo8(0)
 994 037a 00D0      		rcall lcd_set_4bit
 188:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 996               	.LM111:
 997 037c 81E0      		ldi r24,lo8(1)
 998 037e 00D0      		rcall lcd_set_4bit
 999               	.LBB48:
 1000               	.LBB49:
 1002               	.Ltext23:
 1004               	.LM112:
 1005 0380 85E3      		 ldi r24,lo8(53)
 1006 0382 8A95      	    1:dec r24
 1007 0384 01F4      	    brne 1b
 1008 0386 0000      		nop
 1009               	.LBE49:
 1010               	.LBE48:
 1012               	.Ltext24:
 189:lcd_595_softspi.c ****     _delay_us(10);
 190:lcd_595_softspi.c **** //    _delay_ms(1);
 191:lcd_595_softspi.c ****     RS      =   1;
 1014               	.LM113:
 1015 0388 81E0      		ldi r24,lo8(1)
 1016 038a 8093 0000 		sts RS,r24
 192:lcd_595_softspi.c **** 	lcd_locate(0,0);
 1018               	.LM114:
 1019 038e 80E0      		ldi r24,lo8(0)
 1020 0390 60E0      		ldi r22,lo8(0)
 1021 0392 00D0      		rcall lcd_locate
 1022               	/* epilogue start */
 193:lcd_595_softspi.c **** }
 1024               	.LM115:
 1025 0394 0895      		ret
 1027               	.Lscope10:
 1031               	.global	lcd_set_CGRAMaddr
 1033               	lcd_set_CGRAMaddr:
 194:lcd_595_softspi.c **** 
 195:lcd_595_softspi.c **** // Set CGRAM address
 196:lcd_595_softspi.c **** void lcd_set_CGRAMaddr(unsigned char code,unsigned char addr)
 197:lcd_595_softspi.c **** {
 1035               	.LM116:
 1036               	.LFBB11:
 1037               	/* prologue: function */
 1038               	/* frame size = 0 */
 1039               	/* stack size = 0 */
 1040               	.L__stack_usage = 0
 198:lcd_595_softspi.c **** 	// set instruction input mode
 199:lcd_595_softspi.c ****     RS      =   0;
 1042               	.LM117:
 1043 0396 1092 0000 		sts RS,__zero_reg__
 200:lcd_595_softspi.c ****     lcd_set_char(0x40 | code<<3 | addr );
 1045               	.LM118:
 1046 039a 6064      		ori r22,lo8(64)
 1047 039c 880F      		lsl r24
 1048 039e 880F      		lsl r24
 1049 03a0 880F      		lsl r24
 1050 03a2 862B      		or r24,r22
 1051 03a4 00D0      		rcall lcd_set_char
 201:lcd_595_softspi.c **** 	// set data input mode
 202:lcd_595_softspi.c ****     RS      =   1;
 1053               	.LM119:
 1054 03a6 81E0      		ldi r24,lo8(1)
 1055 03a8 8093 0000 		sts RS,r24
 1056               	/* epilogue start */
 203:lcd_595_softspi.c **** }
 1058               	.LM120:
 1059 03ac 0895      		ret
 1061               	.Lscope11:
 1062               		.comm DATA,1,1
 1063               		.comm RS,1,1
 1064               		.comm E,1,1
 1069               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 lcd_595_softspi.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:107    .text:00000000 SoftSPI_Init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:130    .text:00000008 SoftSPI_TX
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:188    .text:00000038 send_bits_595
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:229    .text:00000054 lcd_set_4bit
                            *COM*:00000001 DATA
                            *COM*:00000001 E
                            *COM*:00000001 RS
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:278    .text:0000008c lcd_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:534    .text:0000015e lcd_set_char
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:582    .text:0000017e lcd_locate
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:623    .text:000001a8 lcd_set_str
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:664    .text:000001be lcd_set_numeric
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:980    .text:00000374 lcd_clear
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//cc3XBp4g.s:1033   .text:00000396 lcd_set_CGRAMaddr

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsf3
__ltsf2
__mulsi3
__floatunsisf
__divsf3
__fixunssfsi
__subsf3
