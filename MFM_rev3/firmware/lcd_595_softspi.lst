   1               		.file	"lcd_595_softspi.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  11               		.text
  12               	.Ltext0:
 105               	.global	SoftSPI_Init
 107               	SoftSPI_Init:
   1:lcd_595_softspi.c **** // LCD Control Functions
   2:lcd_595_softspi.c **** // Target : ATMEGA88 (ATMEGA168)
   3:lcd_595_softspi.c **** // Clock  : 1MHz (Fuse : CKDIV8 = 0, Fullswing crystal)
   4:lcd_595_softspi.c **** //
   5:lcd_595_softspi.c **** 
   6:lcd_595_softspi.c **** #include <avr/io.h>
   7:lcd_595_softspi.c **** #include <util/delay.h>
   8:lcd_595_softspi.c **** #include <avr/interrupt.h>
   9:lcd_595_softspi.c **** #include "lcd_595_softspi.h"
  10:lcd_595_softspi.c **** 
  11:lcd_595_softspi.c **** // SPI port Dfinition
  12:lcd_595_softspi.c **** #define DDR_SPI         DDRB
  13:lcd_595_softspi.c **** #define PORT_SPI        PORTB
  14:lcd_595_softspi.c **** #define DD_MOSI         PB0
  15:lcd_595_softspi.c **** #define DD_SCK          PB1
  16:lcd_595_softspi.c **** #define DD_RCK          PB2
  17:lcd_595_softspi.c **** 
  18:lcd_595_softspi.c **** unsigned char E;
  19:lcd_595_softspi.c **** unsigned char RS;
  20:lcd_595_softspi.c **** unsigned char DATA;
  21:lcd_595_softspi.c **** 
  22:lcd_595_softspi.c **** void SoftSPI_Init(void){
 109               	.LM0:
 110               	.LFBB1:
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 0 */
 114               	.L__stack_usage = 0
  23:lcd_595_softspi.c ****     /*MOSI,SCK=出力、他は入力に設定 */
  24:lcd_595_softspi.c ****     DDR_SPI |= (1<<DD_MOSI)|(1<<DD_SCK)|(1<<DD_RCK);
 116               	.LM1:
 117 0000 84B1      		in r24,36-32
 118 0002 8760      		ori r24,lo8(7)
 119 0004 84B9      		out 36-32,r24
 120               	/* epilogue start */
  25:lcd_595_softspi.c **** }
 122               	.LM2:
 123 0006 0895      		ret
 125               	.Lscope1:
 128               	.global	SoftSPI_TX
 130               	SoftSPI_TX:
  26:lcd_595_softspi.c **** 
  27:lcd_595_softspi.c **** void SoftSPI_TX(unsigned char cData){
 132               	.LM3:
 133               	.LFBB2:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
 139               	.LM4:
 140 0008 27E0      		ldi r18,lo8(7)
 141 000a 30E0      		ldi r19,hi8(7)
  28:lcd_595_softspi.c ****     unsigned int n;
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
  31:lcd_595_softspi.c ****         _delay_us(1);
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
  33:lcd_595_softspi.c ****         PORT_SPI |= (0x01&(cData>>(7-n)))<<DD_MOSI; // Set Data bit
 143               	.LM5:
 144 000c 90E0      		ldi r25,lo8(0)
 145               	.L3:
  30:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_SCK);               // Set SCK "L"
 147               	.LM6:
 148 000e 2998      		cbi 37-32,1
 149               	.LBB34:
 150               	.LBB35:
 152               	.Ltext1:
   1:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   6:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
   9:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  12:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      distribution.
  16:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  17:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  21:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  33:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  35:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  38:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  41:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  42:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  46:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \file */
  47:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \code
  49:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \endcode
  53:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  54:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     used.
  58:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  59:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  68:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  77:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  81:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** */
  82:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  83:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  87:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  88:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  93:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  94:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
  97:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
  98:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #  include <math.h>
 102:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 103:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 104:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 105:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 107:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 109:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 112:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 114:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 120:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 125:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 129:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 132:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 140:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 141:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 142:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 144:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 153:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 156:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 159:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 160:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 161:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 163:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 166:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #else
 167:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	{
 172:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		{
 176:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 			__ticks --;
 179:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		}
 180:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		return;
 181:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	}
 182:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	else
 183:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #endif
 186:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** }
 187:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 188:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** /**
 189:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 191:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 193:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 196:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 198:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 202:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   
 207:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 211:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  
 214:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 222:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****  */
 223:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** void
 224:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** {
 226:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 235:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 238:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 241:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#else
 242:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		//round up by default
 243:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	#endif
 245:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 
 246:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 154               	.LM7:
 155 0010 45E0      		 ldi r20,lo8(5)
 156 0012 4A95      	    1:dec r20
 157 0014 01F4      	    brne 1b
 158 0016 0000      		nop
 159               	.LBE35:
 160               	.LBE34:
 162               	.Ltext2:
  32:lcd_595_softspi.c ****         PORT_SPI &= ~(1<<DD_MOSI);              // Initialize Data Port
 164               	.LM8:
 165 0018 2898      		cbi 37-32,0
 167               	.LM9:
 168 001a 65B1      		in r22,37-32
 169 001c AC01      		movw r20,r24
 170 001e 022E      		mov r0,r18
 171 0020 00C0      		rjmp 2f
 172 0022 5595      	1:	asr r21
 173 0024 4795      		ror r20
 174 0026 0A94      	2:	dec r0
 175 0028 02F4      		brpl 1b
 176 002a 4170      		andi r20,lo8(1)
 177 002c 462B      		or r20,r22
 178 002e 45B9      		out 37-32,r20
 179               	.LBB36:
 180               	.LBB37:
 182               	.Ltext3:
 184               	.LM10:
 185 0030 45E0      		 ldi r20,lo8(5)
 186 0032 4A95      	    1:dec r20
 187 0034 01F4      	    brne 1b
 188 0036 0000      		nop
 189               	.LBE37:
 190               	.LBE36:
 192               	.Ltext4:
  34:lcd_595_softspi.c ****         _delay_us(1);
  35:lcd_595_softspi.c ****         PORT_SPI |= (1<<DD_SCK);                // Set SCK "H"
 194               	.LM11:
 195 0038 299A      		sbi 37-32,1
 196               	.LBB38:
 197               	.LBB39:
 199               	.Ltext5:
 201               	.LM12:
 202 003a 45E0      		 ldi r20,lo8(5)
 203 003c 4A95      	    1:dec r20
 204 003e 01F4      	    brne 1b
 205 0040 0000      		nop
 206 0042 2150      		subi r18,lo8(-(-1))
 207 0044 3040      		sbci r19,hi8(-(-1))
 208               	.LBE39:
 209               	.LBE38:
 211               	.Ltext6:
  29:lcd_595_softspi.c ****     for(n=0;n<8;n++){
 213               	.LM13:
 214 0046 4FEF      		ldi r20,hi8(-1)
 215 0048 2F3F      		cpi r18,lo8(-1)
 216 004a 3407      		cpc r19,r20
 217 004c 01F4      		brne .L3
 218               	/* epilogue start */
  36:lcd_595_softspi.c ****         _delay_us(1);
  37:lcd_595_softspi.c ****     }
  38:lcd_595_softspi.c **** }
 220               	.LM14:
 221 004e 0895      		ret
 223               	.Lscope2:
 228               	.global	send_bits_595
 230               	send_bits_595:
  39:lcd_595_softspi.c **** 
  40:lcd_595_softspi.c **** void send_bits_595(unsigned char RS, unsigned char E, unsigned char DATA){
 232               	.LM15:
 233               	.LFBB3:
 234               	/* prologue: function */
 235               	/* frame size = 0 */
 236               	/* stack size = 0 */
 237               	.L__stack_usage = 0
  41:lcd_595_softspi.c ****     unsigned char bits;
  42:lcd_595_softspi.c ****     bits = 0x3f & ( (RS<<5)|(E<<4)|DATA );
 239               	.LM16:
 240 0050 8295      		swap r24
 241 0052 880F      		lsl r24
 242 0054 807E      		andi r24,lo8(-32)
 243 0056 842B      		or r24,r20
 244 0058 6295      		swap r22
 245 005a 607F      		andi r22,lo8(-16)
 246 005c 682B      		or r22,r24
  43:lcd_595_softspi.c ****     SoftSPI_TX(bits);
 248               	.LM17:
 249 005e 862F      		mov r24,r22
 250 0060 8F73      		andi r24,lo8(63)
 251 0062 00D0      		rcall SoftSPI_TX
 252               	.LBB40:
 253               	.LBB41:
 255               	.Ltext7:
 257               	.LM18:
 258 0064 85E3      		 ldi r24,lo8(53)
 259 0066 8A95      	    1:dec r24
 260 0068 01F4      	    brne 1b
 261 006a 0000      		nop
 262               	.LBE41:
 263               	.LBE40:
 265               	.Ltext8:
  44:lcd_595_softspi.c ****     _delay_us(10);
  45:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 267               	.LM19:
 268 006c 2A98      		cbi 37-32,2
  46:lcd_595_softspi.c ****     PORT_SPI |=  (1<<DD_RCK);   // Set RCK "H"
 270               	.LM20:
 271 006e 2A9A      		sbi 37-32,2
  47:lcd_595_softspi.c ****     PORT_SPI &= ~(1<<DD_RCK);   // Set RCK "L"
 273               	.LM21:
 274 0070 2A98      		cbi 37-32,2
 275               	/* epilogue start */
  48:lcd_595_softspi.c **** }
 277               	.LM22:
 278 0072 0895      		ret
 280               	.Lscope3:
 283               	.global	lcd_set_4bit
 285               	lcd_set_4bit:
  49:lcd_595_softspi.c **** 
  50:lcd_595_softspi.c **** // fuction for sending control bitpattern
  51:lcd_595_softspi.c **** void lcd_set_4bit(unsigned char bitpattern){
 287               	.LM23:
 288               	.LFBB4:
 289               	/* prologue: function */
 290               	/* frame size = 0 */
 291               	/* stack size = 0 */
 292               	.L__stack_usage = 0
  52:lcd_595_softspi.c **** 	DATA    =   0x0f & bitpattern; // set sending data
 294               	.LM24:
 295 0074 482F      		mov r20,r24
 296 0076 4F70      		andi r20,lo8(15)
 297 0078 4093 0000 		sts DATA,r20
  53:lcd_595_softspi.c **** 	E       =   0;
 299               	.LM25:
 300 007c 1092 0000 		sts E,__zero_reg__
  54:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 302               	.LM26:
 303 0080 8091 0000 		lds r24,RS
 304 0084 60E0      		ldi r22,lo8(0)
 305 0086 00D0      		rcall send_bits_595
  55:lcd_595_softspi.c **** //	_delay_us(20);
  56:lcd_595_softspi.c **** 	E       =   1;
 307               	.LM27:
 308 0088 81E0      		ldi r24,lo8(1)
 309 008a 8093 0000 		sts E,r24
  57:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 311               	.LM28:
 312 008e 8091 0000 		lds r24,RS
 313 0092 61E0      		ldi r22,lo8(1)
 314 0094 4091 0000 		lds r20,DATA
 315 0098 00D0      		rcall send_bits_595
  58:lcd_595_softspi.c **** //	_delay_us(20);
  59:lcd_595_softspi.c **** 	E       =   0;
 317               	.LM29:
 318 009a 1092 0000 		sts E,__zero_reg__
  60:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 320               	.LM30:
 321 009e 8091 0000 		lds r24,RS
 322 00a2 60E0      		ldi r22,lo8(0)
 323 00a4 4091 0000 		lds r20,DATA
 324 00a8 00D0      		rcall send_bits_595
 325               	/* epilogue start */
  61:lcd_595_softspi.c **** //	_delay_us(20);
  62:lcd_595_softspi.c **** }
 327               	.LM31:
 328 00aa 0895      		ret
 330               	.Lscope4:
 332               	.global	lcd_init
 334               	lcd_init:
  63:lcd_595_softspi.c **** 
  64:lcd_595_softspi.c **** // Initializing LCD
  65:lcd_595_softspi.c **** void lcd_init(void){
 336               	.LM32:
 337               	.LFBB5:
 338               	/* prologue: function */
 339               	/* frame size = 0 */
 340               	/* stack size = 0 */
 341               	.L__stack_usage = 0
  66:lcd_595_softspi.c **** 
  67:lcd_595_softspi.c **** 	// set enable "0"
  68:lcd_595_softspi.c ****     E       = 0;
 343               	.LM33:
 344 00ac 1092 0000 		sts E,__zero_reg__
  69:lcd_595_softspi.c ****     // set instruction input mode
  70:lcd_595_softspi.c **** 	RS      = 0;
 346               	.LM34:
 347 00b0 1092 0000 		sts RS,__zero_reg__
  71:lcd_595_softspi.c **** 	// initialize data port
  72:lcd_595_softspi.c **** 	DATA	= 0x00;
 349               	.LM35:
 350 00b4 1092 0000 		sts DATA,__zero_reg__
  73:lcd_595_softspi.c ****     send_bits_595(RS,E,DATA);
 352               	.LM36:
 353 00b8 80E0      		ldi r24,lo8(0)
 354 00ba 60E0      		ldi r22,lo8(0)
 355 00bc 40E0      		ldi r20,lo8(0)
 356 00be 00D0      		rcall send_bits_595
 357               	.LBB42:
 358               	.LBB43:
 360               	.Ltext9:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 362               	.LM37:
 363 00c0 8FEF      		 ldi r24,lo8(63999)
 364 00c2 99EF      	    ldi r25,hi8(63999)
 365 00c4 A0E0      	    ldi r26,hlo8(63999)
 366 00c6 8150      	    1:subi r24,1
 367 00c8 9040      	    sbci r25,0
 368 00ca A040      	    sbci r26,0
 369 00cc 01F4      	    brne 1b
 370 00ce 00C0      		rjmp .
 371 00d0 0000      		nop
 372               	.LBE43:
 373               	.LBE42:
 375               	.Ltext10:
  74:lcd_595_softspi.c ****     
  75:lcd_595_softspi.c **** 	// wait more than 15ms
  76:lcd_595_softspi.c **** 	_delay_ms(20);
  77:lcd_595_softspi.c **** 
  78:lcd_595_softspi.c **** 	// set 8-bit mode
  79:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 377               	.LM38:
 378 00d2 83E0      		ldi r24,lo8(3)
 379 00d4 00D0      		rcall lcd_set_4bit
 380               	.LBB44:
 381               	.LBB45:
 383               	.Ltext11:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 385               	.LM39:
 386 00d6 AFE1      		 ldi r26,lo8(19999)
 387 00d8 BEE4      	    ldi r27,hi8(19999)
 388 00da 1197      	    1:sbiw r26,1
 389 00dc 01F4      	    brne 1b
 390 00de 00C0      		rjmp .
 391 00e0 0000      		nop
 392               	.LBE45:
 393               	.LBE44:
 395               	.Ltext12:
  80:lcd_595_softspi.c **** 	_delay_ms(5);
  81:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 397               	.LM40:
 398 00e2 83E0      		ldi r24,lo8(3)
 399 00e4 00D0      		rcall lcd_set_4bit
 400               	.LBB46:
 401               	.LBB47:
 403               	.Ltext13:
 405               	.LM41:
 406 00e6 87EB      		 ldi r24,lo8(439)
 407 00e8 91E0      	    ldi r25,hi8(439)
 408 00ea 0197      	    1:sbiw r24,1
 409 00ec 01F4      	    brne 1b
 410 00ee 00C0      		rjmp .
 411 00f0 0000      		nop
 412               	.LBE47:
 413               	.LBE46:
 415               	.Ltext14:
  82:lcd_595_softspi.c **** 	_delay_us(110);
  83:lcd_595_softspi.c **** 	lcd_set_4bit(0x03);
 417               	.LM42:
 418 00f2 83E0      		ldi r24,lo8(3)
 419 00f4 00D0      		rcall lcd_set_4bit
 420               	.LBB48:
 421               	.LBB49:
 423               	.Ltext15:
 425               	.LM43:
 426 00f6 A7EC      		 ldi r26,lo8(199)
 427 00f8 B0E0      	    ldi r27,hi8(199)
 428 00fa 1197      	    1:sbiw r26,1
 429 00fc 01F4      	    brne 1b
 430 00fe 00C0      		rjmp .
 431 0100 0000      		nop
 432               	.LBE49:
 433               	.LBE48:
 435               	.Ltext16:
  84:lcd_595_softspi.c **** 	_delay_us(50);
  85:lcd_595_softspi.c **** 	
  86:lcd_595_softspi.c **** 	// set 4-bit mode
  87:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 437               	.LM44:
 438 0102 82E0      		ldi r24,lo8(2)
 439 0104 00D0      		rcall lcd_set_4bit
 440               	.LBB50:
 441               	.LBB51:
 443               	.Ltext17:
 445               	.LM45:
 446 0106 87EC      		 ldi r24,lo8(199)
 447 0108 90E0      	    ldi r25,hi8(199)
 448 010a 0197      	    1:sbiw r24,1
 449 010c 01F4      	    brne 1b
 450 010e 00C0      		rjmp .
 451 0110 0000      		nop
 452               	.LBE51:
 453               	.LBE50:
 455               	.Ltext18:
  88:lcd_595_softspi.c **** 	_delay_us(50);
  89:lcd_595_softspi.c **** 
  90:lcd_595_softspi.c **** 	// function setting
  91:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 457               	.LM46:
 458 0112 82E0      		ldi r24,lo8(2)
 459 0114 00D0      		rcall lcd_set_4bit
  92:lcd_595_softspi.c **** 	lcd_set_4bit(0x08);
 461               	.LM47:
 462 0116 88E0      		ldi r24,lo8(8)
 463 0118 00D0      		rcall lcd_set_4bit
 464               	.LBB52:
 465               	.LBB53:
 467               	.Ltext19:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 469               	.LM48:
 470 011a AFE9      		 ldi r26,lo8(3999)
 471 011c BFE0      	    ldi r27,hi8(3999)
 472 011e 1197      	    1:sbiw r26,1
 473 0120 01F4      	    brne 1b
 474 0122 00C0      		rjmp .
 475 0124 0000      		nop
 476               	.LBE53:
 477               	.LBE52:
 479               	.Ltext20:
  93:lcd_595_softspi.c **** 	_delay_ms(1);
  94:lcd_595_softspi.c **** 
  95:lcd_595_softspi.c **** 	// set display on, cursol off and blink off
  96:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 481               	.LM49:
 482 0126 80E0      		ldi r24,lo8(0)
 483 0128 00D0      		rcall lcd_set_4bit
  97:lcd_595_softspi.c **** 	lcd_set_4bit(0x0c);
 485               	.LM50:
 486 012a 8CE0      		ldi r24,lo8(12)
 487 012c 00D0      		rcall lcd_set_4bit
 488               	.LBB54:
 489               	.LBB55:
 491               	.Ltext21:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 493               	.LM51:
 494 012e 8FE9      		 ldi r24,lo8(3999)
 495 0130 9FE0      	    ldi r25,hi8(3999)
 496 0132 0197      	    1:sbiw r24,1
 497 0134 01F4      	    brne 1b
 498 0136 00C0      		rjmp .
 499 0138 0000      		nop
 500               	.LBE55:
 501               	.LBE54:
 503               	.Ltext22:
  98:lcd_595_softspi.c **** 	_delay_ms(1);
  99:lcd_595_softspi.c **** 
 100:lcd_595_softspi.c **** 	// set entry mode (cursol direction : right, disable shift)
 101:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 505               	.LM52:
 506 013a 80E0      		ldi r24,lo8(0)
 507 013c 00D0      		rcall lcd_set_4bit
 102:lcd_595_softspi.c **** 	lcd_set_4bit(0x06);
 509               	.LM53:
 510 013e 86E0      		ldi r24,lo8(6)
 511 0140 00D0      		rcall lcd_set_4bit
 512               	.LBB56:
 513               	.LBB57:
 515               	.Ltext23:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 517               	.LM54:
 518 0142 AFE9      		 ldi r26,lo8(3999)
 519 0144 BFE0      	    ldi r27,hi8(3999)
 520 0146 1197      	    1:sbiw r26,1
 521 0148 01F4      	    brne 1b
 522 014a 00C0      		rjmp .
 523 014c 0000      		nop
 524               	.LBE57:
 525               	.LBE56:
 527               	.Ltext24:
 103:lcd_595_softspi.c **** 	_delay_ms(1);
 104:lcd_595_softspi.c **** 
 105:lcd_595_softspi.c **** 	// clear display
 106:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 529               	.LM55:
 530 014e 80E0      		ldi r24,lo8(0)
 531 0150 00D0      		rcall lcd_set_4bit
 107:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 533               	.LM56:
 534 0152 81E0      		ldi r24,lo8(1)
 535 0154 00D0      		rcall lcd_set_4bit
 536               	.LBB58:
 537               	.LBB59:
 539               	.Ltext25:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 541               	.LM57:
 542 0156 8FE3      		 ldi r24,lo8(7999)
 543 0158 9FE1      	    ldi r25,hi8(7999)
 544 015a 0197      	    1:sbiw r24,1
 545 015c 01F4      	    brne 1b
 546 015e 00C0      		rjmp .
 547 0160 0000      		nop
 548               	.LBE59:
 549               	.LBE58:
 551               	.Ltext26:
 108:lcd_595_softspi.c **** 	_delay_ms(2);
 109:lcd_595_softspi.c **** 
 110:lcd_595_softspi.c **** 	// clear cursol position
 111:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 553               	.LM58:
 554 0162 80E0      		ldi r24,lo8(0)
 555 0164 00D0      		rcall lcd_set_4bit
 112:lcd_595_softspi.c **** 	lcd_set_4bit(0x02);
 557               	.LM59:
 558 0166 82E0      		ldi r24,lo8(2)
 559 0168 00D0      		rcall lcd_set_4bit
 560               	.LBB60:
 561               	.LBB61:
 563               	.Ltext27:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 565               	.LM60:
 566 016a AFE3      		 ldi r26,lo8(7999)
 567 016c BFE1      	    ldi r27,hi8(7999)
 568 016e 1197      	    1:sbiw r26,1
 569 0170 01F4      	    brne 1b
 570 0172 00C0      		rjmp .
 571 0174 0000      		nop
 572               	.LBE61:
 573               	.LBE60:
 575               	.Ltext28:
 113:lcd_595_softspi.c **** 	_delay_ms(2);
 114:lcd_595_softspi.c **** 
 115:lcd_595_softspi.c **** 	// set data input mode
 116:lcd_595_softspi.c ****     RS      =   1;
 577               	.LM61:
 578 0176 81E0      		ldi r24,lo8(1)
 579 0178 8093 0000 		sts RS,r24
 580               	/* epilogue start */
 117:lcd_595_softspi.c **** }
 582               	.LM62:
 583 017c 0895      		ret
 585               	.Lscope5:
 588               	.global	lcd_set_char
 590               	lcd_set_char:
 118:lcd_595_softspi.c **** 
 119:lcd_595_softspi.c **** // LCD character allocation
 120:lcd_595_softspi.c **** void lcd_locate(unsigned char row, unsigned char col)
 121:lcd_595_softspi.c **** {
 122:lcd_595_softspi.c **** 	// set instruction input mode
 123:lcd_595_softspi.c ****     RS      =   0;
 124:lcd_595_softspi.c **** //	lcd_set_char(0x80 | col | (0x40 * row) );
 125:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 126:lcd_595_softspi.c **** 	// set data input mode
 127:lcd_595_softspi.c ****     RS      =   1;
 128:lcd_595_softspi.c **** }
 129:lcd_595_softspi.c **** 
 130:lcd_595_softspi.c **** // LCD character (1 byte) sending
 131:lcd_595_softspi.c **** void lcd_set_char(unsigned char c)
 132:lcd_595_softspi.c **** {
 592               	.LM63:
 593               	.LFBB6:
 594 017e CF93      		push r28
 595               	/* prologue: function */
 596               	/* frame size = 0 */
 597               	/* stack size = 1 */
 598               	.L__stack_usage = 1
 599 0180 C82F      		mov r28,r24
 133:lcd_595_softspi.c **** 	lcd_set_4bit(c >> 4); // Upper Bit
 601               	.LM64:
 602 0182 8295      		swap r24
 603 0184 8F70      		andi r24,lo8(15)
 604 0186 00D0      		rcall lcd_set_4bit
 134:lcd_595_softspi.c **** 	lcd_set_4bit(0x0f & c); // Lower Bit
 606               	.LM65:
 607 0188 8C2F      		mov r24,r28
 608 018a 8F70      		andi r24,lo8(15)
 609 018c 00D0      		rcall lcd_set_4bit
 610               	.LBB62:
 611               	.LBB63:
 613               	.Ltext29:
 615               	.LM66:
 616 018e 87EC      		 ldi r24,lo8(199)
 617 0190 90E0      	    ldi r25,hi8(199)
 618 0192 0197      	    1:sbiw r24,1
 619 0194 01F4      	    brne 1b
 620 0196 00C0      		rjmp .
 621 0198 0000      		nop
 622               	/* epilogue start */
 623               	.LBE63:
 624               	.LBE62:
 626               	.Ltext30:
 135:lcd_595_softspi.c **** 	_delay_us(50);
 136:lcd_595_softspi.c **** }
 628               	.LM67:
 629 019a CF91      		pop r28
 630 019c 0895      		ret
 632               	.Lscope6:
 636               	.global	lcd_locate
 638               	lcd_locate:
 121:lcd_595_softspi.c **** {
 640               	.LM68:
 641               	.LFBB7:
 642               	/* prologue: function */
 643               	/* frame size = 0 */
 644               	/* stack size = 0 */
 645               	.L__stack_usage = 0
 123:lcd_595_softspi.c ****     RS      =   0;
 647               	.LM69:
 648 019e 1092 0000 		sts RS,__zero_reg__
 125:lcd_595_softspi.c **** 	lcd_set_char(0x80 | ( col + 20*(unsigned int)(row/2) ) | ( 0x40 * (row%2) ) );
 650               	.LM70:
 651 01a2 982F      		mov r25,r24
 652 01a4 9170      		andi r25,lo8(1)
 653 01a6 9295      		swap r25
 654 01a8 990F      		lsl r25
 655 01aa 990F      		lsl r25
 656 01ac 907C      		andi r25,lo8(-64)
 657 01ae 9068      		ori r25,lo8(-128)
 658 01b0 8695      		lsr r24
 659 01b2 24E1      		ldi r18,lo8(20)
 660 01b4 829F      		mul r24,r18
 661 01b6 802D      		mov r24,r0
 662 01b8 1124      		clr r1
 663 01ba 860F      		add r24,r22
 664 01bc 892B      		or r24,r25
 665 01be 00D0      		rcall lcd_set_char
 127:lcd_595_softspi.c ****     RS      =   1;
 667               	.LM71:
 668 01c0 81E0      		ldi r24,lo8(1)
 669 01c2 8093 0000 		sts RS,r24
 670               	/* epilogue start */
 128:lcd_595_softspi.c **** }
 672               	.LM72:
 673 01c6 0895      		ret
 675               	.Lscope7:
 677               	.global	lcd_set_str
 679               	lcd_set_str:
 137:lcd_595_softspi.c **** 
 138:lcd_595_softspi.c **** // LCD String Sending
 139:lcd_595_softspi.c **** void lcd_set_str(unsigned char *s)
 140:lcd_595_softspi.c **** {
 681               	.LM73:
 682               	.LFBB8:
 683 01c8 CF93      		push r28
 684 01ca DF93      		push r29
 685               	/* prologue: function */
 686               	/* frame size = 0 */
 687               	/* stack size = 2 */
 688               	.L__stack_usage = 2
 690               	.LM74:
 691 01cc EC01      		movw r28,r24
 141:lcd_595_softspi.c **** 	while (*s != 0) {
 693               	.LM75:
 694 01ce 00C0      		rjmp .L11
 695               	.L12:
 142:lcd_595_softspi.c **** 		lcd_set_char(*s);
 697               	.LM76:
 698 01d0 00D0      		rcall lcd_set_char
 699               	.L11:
 141:lcd_595_softspi.c **** 	while (*s != 0) {
 701               	.LM77:
 702 01d2 8991      		ld r24,Y+
 703 01d4 8823      		tst r24
 704 01d6 01F4      		brne .L12
 705               	/* epilogue start */
 143:lcd_595_softspi.c **** 		s++;
 144:lcd_595_softspi.c **** 	} 
 145:lcd_595_softspi.c **** }
 707               	.LM78:
 708 01d8 DF91      		pop r29
 709 01da CF91      		pop r28
 710 01dc 0895      		ret
 712               	.Lscope8:
 718               	.global	lcd_set_numeric
 720               	lcd_set_numeric:
 146:lcd_595_softspi.c **** 
 147:lcd_595_softspi.c **** // Display numeric on LCD display
 148:lcd_595_softspi.c **** void lcd_set_numeric(float num, unsigned int Nint, unsigned int Nfrac, unsigned int sign){
 722               	.LM79:
 723               	.LFBB9:
 724 01de 2F92      		push r2
 725 01e0 3F92      		push r3
 726 01e2 4F92      		push r4
 727 01e4 5F92      		push r5
 728 01e6 6F92      		push r6
 729 01e8 7F92      		push r7
 730 01ea 8F92      		push r8
 731 01ec 9F92      		push r9
 732 01ee AF92      		push r10
 733 01f0 BF92      		push r11
 734 01f2 CF92      		push r12
 735 01f4 DF92      		push r13
 736 01f6 EF92      		push r14
 737 01f8 FF92      		push r15
 738 01fa 0F93      		push r16
 739 01fc 1F93      		push r17
 740 01fe CF93      		push r28
 741 0200 DF93      		push r29
 742 0202 CDB7      		in r28,__SP_L__
 743 0204 DEB7      		in r29,__SP_H__
 744 0206 2897      		sbiw r28,8
 745 0208 0FB6      		in __tmp_reg__,__SREG__
 746 020a F894      		cli
 747 020c DEBF      		out __SP_H__,r29
 748 020e 0FBE      		out __SREG__,__tmp_reg__
 749 0210 CDBF      		out __SP_L__,r28
 750               	/* prologue: function */
 751               	/* frame size = 8 */
 752               	/* stack size = 26 */
 753               	.L__stack_usage = 26
 754 0212 6B01      		movw r12,r22
 755 0214 7C01      		movw r14,r24
 756 0216 1A01      		movw r2,r20
 757 0218 2901      		movw r4,r18
 149:lcd_595_softspi.c ****     unsigned long int DivFactor = 1;
 150:lcd_595_softspi.c **** 	unsigned int n, m;
 151:lcd_595_softspi.c **** 	unsigned int d[10];
 152:lcd_595_softspi.c ****     unsigned int valid = 0;
 153:lcd_595_softspi.c ****     
 154:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 759               	.LM80:
 760 021a 80E0      		ldi r24,lo8(0)
 761 021c 90E0      		ldi r25,hi8(0)
 762 021e 4C01      		movw r8,r24
 763 0220 00C0      		rjmp .L14
 764               	.L15:
 155:lcd_595_softspi.c ****         num = num * 10;
 766               	.LM81:
 767 0222 C701      		movw r24,r14
 768 0224 B601      		movw r22,r12
 769 0226 20E0      		ldi r18,lo8(0x41200000)
 770 0228 30E0      		ldi r19,hi8(0x41200000)
 771 022a 40E2      		ldi r20,hlo8(0x41200000)
 772 022c 51E4      		ldi r21,hhi8(0x41200000)
 773 022e 00D0      		rcall __mulsf3
 774 0230 C62E      		mov r12,r22
 775 0232 D72E      		mov r13,r23
 776 0234 E82E      		mov r14,r24
 777 0236 F92E      		mov r15,r25
 154:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 779               	.LM82:
 780 0238 0894      		sec
 781 023a 811C      		adc r8,__zero_reg__
 782 023c 911C      		adc r9,__zero_reg__
 783               	.L14:
 154:lcd_595_softspi.c ****     for(n=0;n<Nfrac;n++){
 785               	.LM83:
 786 023e 8414      		cp r8,r4
 787 0240 9504      		cpc r9,r5
 788 0242 01F4      		brne .L15
 156:lcd_595_softspi.c ****     }
 157:lcd_595_softspi.c ****     
 158:lcd_595_softspi.c ****     // Detect sign
 159:lcd_595_softspi.c ****     if( sign == 1){
 790               	.LM84:
 791 0244 0130      		cpi r16,1
 792 0246 1105      		cpc r17,__zero_reg__
 793 0248 01F4      		brne .L16
 160:lcd_595_softspi.c ****         if( num < 0 ){
 795               	.LM85:
 796 024a C701      		movw r24,r14
 797 024c B601      		movw r22,r12
 798 024e 20E0      		ldi r18,lo8(0x0)
 799 0250 30E0      		ldi r19,hi8(0x0)
 800 0252 A901      		movw r20,r18
 801 0254 00D0      		rcall __ltsf2
 802 0256 87FF      		sbrs r24,7
 803 0258 00C0      		rjmp .L34
 161:lcd_595_softspi.c ****             lcd_set_char('-');
 805               	.LM86:
 806 025a 8DE2      		ldi r24,lo8(45)
 807 025c 00D0      		rcall lcd_set_char
 162:lcd_595_softspi.c ****             num = -num;
 809               	.LM87:
 810 025e F7FA      		bst r15,7
 811 0260 F094      		com r15
 812 0262 F7F8      		bld r15,7
 813 0264 F094      		com r15
 814               	.L16:
 163:lcd_595_softspi.c ****         }else{
 164:lcd_595_softspi.c ****             lcd_set_char('+');
 165:lcd_595_softspi.c ****         }
 166:lcd_595_softspi.c ****     }
 167:lcd_595_softspi.c ****     // end of
 168:lcd_595_softspi.c **** 				
 169:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 170:lcd_595_softspi.c ****         
 171:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 172:lcd_595_softspi.c ****             lcd_set_char('.');
 173:lcd_595_softspi.c ****         }
 174:lcd_595_softspi.c ****         
 175:lcd_595_softspi.c ****         DivFactor = 1;
 176:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 177:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 178:lcd_595_softspi.c ****         }
 179:lcd_595_softspi.c ****         
 180:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 181:lcd_595_softspi.c ****         if( (valid == 0) && ( d[n]!=0 || n==Nint-1) ) valid = 1;
 816               	.LM88:
 817 0266 00E0      		ldi r16,lo8(0)
 818 0268 10E0      		ldi r17,hi8(0)
 819 026a 6624      		clr r6
 820 026c 7724      		clr r7
 169:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 822               	.LM89:
 823 026e 9201      		movw r18,r4
 824 0270 220D      		add r18,r2
 825 0272 331D      		adc r19,r3
 826 0274 3A83      		std Y+2,r19
 827 0276 2983      		std Y+1,r18
 828 0278 2150      		subi r18,lo8(-(-1))
 829 027a 3040      		sbci r19,hi8(-(-1))
 830 027c 3C83      		std Y+4,r19
 831 027e 2B83      		std Y+3,r18
 833               	.LM90:
 834 0280 C101      		movw r24,r2
 835 0282 0197      		sbiw r24,1
 836 0284 9E83      		std Y+6,r25
 837 0286 8D83      		std Y+5,r24
 838 0288 7886      		std Y+8,r7
 839 028a 6F82      		std Y+7,r6
 840 028c 00C0      		rjmp .L19
 841               	.L34:
 164:lcd_595_softspi.c ****             lcd_set_char('+');
 843               	.LM91:
 844 028e 8BE2      		ldi r24,lo8(43)
 845 0290 00D0      		rcall lcd_set_char
 846 0292 00C0      		rjmp .L16
 847               	.L29:
 171:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 849               	.LM92:
 850 0294 0215      		cp r16,r2
 851 0296 1305      		cpc r17,r3
 852 0298 01F4      		brne .L20
 171:lcd_595_softspi.c ****         if( ( n== Nint ) && ( Nfrac!=0 )){
 854               	.LM93:
 855 029a 4114      		cp r4,__zero_reg__
 856 029c 5104      		cpc r5,__zero_reg__
 857 029e 01F0      		breq .L20
 172:lcd_595_softspi.c ****             lcd_set_char('.');
 859               	.LM94:
 860 02a0 8EE2      		ldi r24,lo8(46)
 861 02a2 00D0      		rcall lcd_set_char
 862               	.L20:
 176:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 864               	.LM95:
 865 02a4 3801      		movw r6,r16
 175:lcd_595_softspi.c ****         DivFactor = 1;
 867               	.LM96:
 868 02a6 81E0      		ldi r24,lo8(1)
 869 02a8 882E      		mov r8,r24
 870 02aa 912C      		mov r9,__zero_reg__
 871 02ac A12C      		mov r10,__zero_reg__
 872 02ae B12C      		mov r11,__zero_reg__
 873 02b0 C501      		movw r24,r10
 874 02b2 B401      		movw r22,r8
 176:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 876               	.LM97:
 877 02b4 00C0      		rjmp .L21
 878               	.L22:
 177:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 880               	.LM98:
 881 02b6 2AE0      		ldi r18,lo8(10)
 882 02b8 30E0      		ldi r19,hi8(10)
 883 02ba 40E0      		ldi r20,hlo8(10)
 884 02bc 50E0      		ldi r21,hhi8(10)
 885 02be 00D0      		rcall __mulsi3
 886               	.L21:
 177:lcd_595_softspi.c ****             DivFactor = DivFactor * 10;
 888               	.LM99:
 889 02c0 0894      		sec
 890 02c2 611C      		adc r6,__zero_reg__
 891 02c4 711C      		adc r7,__zero_reg__
 176:lcd_595_softspi.c ****         for(m=n+1;m<Nint+Nfrac;m++){
 893               	.LM100:
 894 02c6 E981      		ldd r30,Y+1
 895 02c8 FA81      		ldd r31,Y+2
 896 02ca 6E16      		cp r6,r30
 897 02cc 7F06      		cpc r7,r31
 898 02ce 00F0      		brlo .L22
 899 02d0 4B01      		movw r8,r22
 900 02d2 5C01      		movw r10,r24
 180:lcd_595_softspi.c ****         d[n] = (unsigned int)( num / DivFactor );
 902               	.LM101:
 903 02d4 00D0      		rcall __floatunsisf
 904 02d6 9B01      		movw r18,r22
 905 02d8 AC01      		movw r20,r24
 906 02da C701      		movw r24,r14
 907 02dc B601      		movw r22,r12
 908 02de 00D0      		rcall __divsf3
 909 02e0 00D0      		rcall __fixunssfsi
 910 02e2 DC01      		movw r26,r24
 911 02e4 CB01      		movw r24,r22
 912 02e6 3C01      		movw r6,r24
 914               	.LM102:
 915 02e8 2F81      		ldd r18,Y+7
 916 02ea 3885      		ldd r19,Y+8
 917 02ec 2115      		cp r18,__zero_reg__
 918 02ee 3105      		cpc r19,__zero_reg__
 919 02f0 01F4      		brne .L30
 921               	.LM103:
 922 02f2 81E0      		ldi r24,lo8(1)
 923 02f4 90E0      		ldi r25,hi8(1)
 924 02f6 9887      		std Y+8,r25
 925 02f8 8F83      		std Y+7,r24
 926 02fa 6114      		cp r6,__zero_reg__
 927 02fc 7104      		cpc r7,__zero_reg__
 928 02fe 01F4      		brne .L23
 930               	.LM104:
 931 0300 ED81      		ldd r30,Y+5
 932 0302 FE81      		ldd r31,Y+6
 933 0304 0E17      		cp r16,r30
 934 0306 1F07      		cpc r17,r31
 935 0308 01F0      		breq .L23
 936 030a 1886      		std Y+8,__zero_reg__
 937 030c 1F82      		std Y+7,__zero_reg__
 938 030e 00C0      		rjmp .L23
 939               	.L30:
 941               	.LM105:
 942 0310 21E0      		ldi r18,lo8(1)
 943 0312 30E0      		ldi r19,hi8(1)
 944 0314 3887      		std Y+8,r19
 945 0316 2F83      		std Y+7,r18
 946               	.L23:
 182:lcd_595_softspi.c ****         num = num - d[n]*DivFactor;
 948               	.LM106:
 949 0318 B301      		movw r22,r6
 950 031a 80E0      		ldi r24,lo8(0)
 951 031c 90E0      		ldi r25,hi8(0)
 952 031e A501      		movw r20,r10
 953 0320 9401      		movw r18,r8
 954 0322 00D0      		rcall __mulsi3
 955 0324 00D0      		rcall __floatunsisf
 956 0326 9B01      		movw r18,r22
 957 0328 AC01      		movw r20,r24
 958 032a C701      		movw r24,r14
 959 032c B601      		movw r22,r12
 960 032e 00D0      		rcall __subsf3
 961 0330 6B01      		movw r12,r22
 962 0332 E82E      		mov r14,r24
 963 0334 F92E      		mov r15,r25
 183:lcd_595_softspi.c ****         
 184:lcd_595_softspi.c ****         if( (valid == 1)|(n == (Nint+Nfrac-1)) ) lcd_set_char(0x30 + d[n]);
 965               	.LM107:
 966 0336 EF81      		ldd r30,Y+7
 967 0338 F885      		ldd r31,Y+8
 968 033a 3097      		sbiw r30,0
 969 033c 01F4      		brne .L33
 970 033e 2B81      		ldd r18,Y+3
 971 0340 3C81      		ldd r19,Y+4
 972 0342 0217      		cp r16,r18
 973 0344 1307      		cpc r17,r19
 974 0346 01F4      		brne .L35
 975               	.L33:
 977               	.LM108:
 978 0348 862D      		mov r24,r6
 979 034a 805D      		subi r24,lo8(-(48))
 980 034c 00C0      		rjmp .L36
 981               	.L35:
 185:lcd_595_softspi.c ****         else if( valid == 0 )                   lcd_set_char(0x20);
 983               	.LM109:
 984 034e 80E2      		ldi r24,lo8(32)
 985               	.L36:
 986 0350 00D0      		rcall lcd_set_char
 987 0352 0F5F      		subi r16,lo8(-(1))
 988 0354 1F4F      		sbci r17,hi8(-(1))
 989               	.L19:
 169:lcd_595_softspi.c ****     for(n=0;n<=Nint+Nfrac-1;n++){
 991               	.LM110:
 992 0356 8B81      		ldd r24,Y+3
 993 0358 9C81      		ldd r25,Y+4
 994 035a 8017      		cp r24,r16
 995 035c 9107      		cpc r25,r17
 996 035e 00F0      		brlo .+2
 997 0360 00C0      		rjmp .L29
 998               	/* epilogue start */
 186:lcd_595_softspi.c ****         else                                    lcd_set_char(0xff);
 187:lcd_595_softspi.c ****     }
 188:lcd_595_softspi.c **** }
 1000               	.LM111:
 1001 0362 2896      		adiw r28,8
 1002 0364 0FB6      		in __tmp_reg__,__SREG__
 1003 0366 F894      		cli
 1004 0368 DEBF      		out __SP_H__,r29
 1005 036a 0FBE      		out __SREG__,__tmp_reg__
 1006 036c CDBF      		out __SP_L__,r28
 1007 036e DF91      		pop r29
 1008 0370 CF91      		pop r28
 1009 0372 1F91      		pop r17
 1010 0374 0F91      		pop r16
 1011 0376 FF90      		pop r15
 1012 0378 EF90      		pop r14
 1013 037a DF90      		pop r13
 1014 037c CF90      		pop r12
 1015 037e BF90      		pop r11
 1016 0380 AF90      		pop r10
 1017 0382 9F90      		pop r9
 1018 0384 8F90      		pop r8
 1019 0386 7F90      		pop r7
 1020 0388 6F90      		pop r6
 1021 038a 5F90      		pop r5
 1022 038c 4F90      		pop r4
 1023 038e 3F90      		pop r3
 1024 0390 2F90      		pop r2
 1025 0392 0895      		ret
 1032               	.Lscope9:
 1034               	.global	lcd_clear
 1036               	lcd_clear:
 189:lcd_595_softspi.c **** 
 190:lcd_595_softspi.c **** // Clear LCD
 191:lcd_595_softspi.c **** void lcd_clear(){
 1038               	.LM112:
 1039               	.LFBB10:
 1040               	/* prologue: function */
 1041               	/* frame size = 0 */
 1042               	/* stack size = 0 */
 1043               	.L__stack_usage = 0
 192:lcd_595_softspi.c **** 	// clear display
 193:lcd_595_softspi.c ****     RS      =   0;
 1045               	.LM113:
 1046 0394 1092 0000 		sts RS,__zero_reg__
 194:lcd_595_softspi.c **** 	lcd_set_4bit(0x00);
 1048               	.LM114:
 1049 0398 80E0      		ldi r24,lo8(0)
 1050 039a 00D0      		rcall lcd_set_4bit
 195:lcd_595_softspi.c **** 	lcd_set_4bit(0x01);
 1052               	.LM115:
 1053 039c 81E0      		ldi r24,lo8(1)
 1054 039e 00D0      		rcall lcd_set_4bit
 1055               	.LBB64:
 1056               	.LBB65:
 1058               	.Ltext31:
 164:/usr/local/CrossPack-AVR-20121207/lib/gcc/avr/4.6.2/../../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 1060               	.LM116:
 1061 03a0 8FE9      		 ldi r24,lo8(3999)
 1062 03a2 9FE0      	    ldi r25,hi8(3999)
 1063 03a4 0197      	    1:sbiw r24,1
 1064 03a6 01F4      	    brne 1b
 1065 03a8 00C0      		rjmp .
 1066 03aa 0000      		nop
 1067               	.LBE65:
 1068               	.LBE64:
 1070               	.Ltext32:
 196:lcd_595_softspi.c **** 	_delay_ms(1);
 197:lcd_595_softspi.c ****     RS      =   1;
 1072               	.LM117:
 1073 03ac 81E0      		ldi r24,lo8(1)
 1074 03ae 8093 0000 		sts RS,r24
 198:lcd_595_softspi.c **** 	lcd_locate(0,0);
 1076               	.LM118:
 1077 03b2 80E0      		ldi r24,lo8(0)
 1078 03b4 60E0      		ldi r22,lo8(0)
 1079 03b6 00D0      		rcall lcd_locate
 1080               	/* epilogue start */
 199:lcd_595_softspi.c **** }
 1082               	.LM119:
 1083 03b8 0895      		ret
 1085               	.Lscope10:
 1089               	.global	lcd_set_CGRAMaddr
 1091               	lcd_set_CGRAMaddr:
 200:lcd_595_softspi.c **** 
 201:lcd_595_softspi.c **** // Set CGRAM address
 202:lcd_595_softspi.c **** void lcd_set_CGRAMaddr(unsigned char code,unsigned char addr)
 203:lcd_595_softspi.c **** {
 1093               	.LM120:
 1094               	.LFBB11:
 1095               	/* prologue: function */
 1096               	/* frame size = 0 */
 1097               	/* stack size = 0 */
 1098               	.L__stack_usage = 0
 204:lcd_595_softspi.c **** 	// set instruction input mode
 205:lcd_595_softspi.c ****     RS      =   0;
 1100               	.LM121:
 1101 03ba 1092 0000 		sts RS,__zero_reg__
 206:lcd_595_softspi.c ****     lcd_set_char(0x40 | code<<3 | addr );
 1103               	.LM122:
 1104 03be 6064      		ori r22,lo8(64)
 1105 03c0 880F      		lsl r24
 1106 03c2 880F      		lsl r24
 1107 03c4 880F      		lsl r24
 1108 03c6 862B      		or r24,r22
 1109 03c8 00D0      		rcall lcd_set_char
 207:lcd_595_softspi.c **** 	// set data input mode
 208:lcd_595_softspi.c ****     RS      =   1;
 1111               	.LM123:
 1112 03ca 81E0      		ldi r24,lo8(1)
 1113 03cc 8093 0000 		sts RS,r24
 1114               	/* epilogue start */
 209:lcd_595_softspi.c **** }
 1116               	.LM124:
 1117 03d0 0895      		ret
 1119               	.Lscope11:
 1120               		.comm DATA,1,1
 1121               		.comm RS,1,1
 1122               		.comm E,1,1
 1127               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 lcd_595_softspi.c
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:2      *ABS*:0000003f __SREG__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:3      *ABS*:0000003e __SP_H__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:4      *ABS*:0000003d __SP_L__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:5      *ABS*:00000034 __CCP__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:7      *ABS*:00000001 __zero_reg__
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:107    .text:00000000 SoftSPI_Init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:130    .text:00000008 SoftSPI_TX
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:230    .text:00000050 send_bits_595
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:285    .text:00000074 lcd_set_4bit
                            *COM*:00000001 DATA
                            *COM*:00000001 E
                            *COM*:00000001 RS
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:334    .text:000000ac lcd_init
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:590    .text:0000017e lcd_set_char
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:638    .text:0000019e lcd_locate
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:679    .text:000001c8 lcd_set_str
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:720    .text:000001de lcd_set_numeric
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:1036   .text:00000394 lcd_clear
/var/folders/v3/wysfpd052nz8jkbx04pk0ym80000gn/T//ccZ9Y4cc.s:1091   .text:000003ba lcd_set_CGRAMaddr

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__mulsf3
__ltsf2
__mulsi3
__floatunsisf
__divsf3
__fixunssfsi
__subsf3
